<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:tan="tag:textalign.net,2015:ns"
    exclude-result-prefixes="#all" version="3.0">
    
    <!-- Create App for XSL -->
    <!-- author: Joel Kalvesmaki -->
    <!-- updated: 2020-04-06 -->
    <!-- To do: 
        refine, test batch process
        develop parallel process for shell, .sh
    -->
    
    <!-- This stylesheet creates a batch file for each of one or more input XSLT stylesheets, to allow 
        anyone who does not have the requisite time, patience, or experience to use XSLT stylesheet
        like an application. A user needs merely to use the File Explorer or Finder to drag files onto 
        the batch file, and get the output programmed into the stylesheet. 
        
        This process will not serve every type of XSLT application. It targets a significant subset of XSLT
        that we will call here MIRU stylesheets, where MIRU stands for Main Input via Resolved Urls.
        In a MIRU stylesheet:
          - the initial, catalyzing input is irrelevant; any XML file, including stylesheet itself, can be the catalyzing input.
          - the main input is determined by a single parameter that takes a sequence of strings representing resolved URLs. 
        A MIRU stylesheet takes the input URLs and applies a given process, normally ignoring the catalyzing XML 
        input. The urls are used to fetch the files that make up the primary input. Many of these files might not be XML, and 
        might in fact not even be text files. In a MIRU stylesheet the primary output (the output determined by the default 
        or initial template) is oftentimes not consequential or it is happily fixed to a specific location, perhaps providing
        a diagnostic report or a log. Typically the more important output files are generated by xsl:result-document, in
        tandem with the input URLs or the static base URI. In these scenarios, such secondary output tends to be more 
        important than the primary output.
        
        The file you are reading is an example of a MIRU stylesheet.
        
        The process should work as will for NIR (no input required) XSLT stylesheets.
    -->
    
    <!-- Catalyzing input: any XML file (including this one) -->
    <!-- Main input: one or more resolved URLs pointing to XSLT stylesheets -->
    <!-- Primary output: nothing, unless diagnostics are on -->
    <!-- Secondary output: a batch file with the same name as the main input -->
    <!-- Adjust parameters below, as needed -->
    
    
    <xsl:import href="../../functions/TAN-A-functions.xsl"/>
    
    <!-- + + + + + + + + + + + + + + -->
    <!-- START OF PARAMETERS -->

    <!-- What are the resolved URLs for the XSLT files that should have an app created? -->
    <xsl:param name="main-input-resolved-urls" as="xs:string+"/>
    
    <!-- Where is the XSLT Processor relative to this stylesheet? -->
    <xsl:param name="processor-path-relative-to-this-stylesheet" as="xs:string"
        >../../processors/saxon9he.jar</xsl:param>

    <!-- What are the standard Saxon options you want to include? See https://saxonica.com/documentation/index.html#!using-xsl/commandline -->
    <xsl:param name="default-saxon-options" as="xs:string?"/>
    
    <!-- What should be the filename of the primary output (if any)? Note, this value populates the -o parameter, and does not dictate whether there will be any primary output, or the handling of secondary output via xsl:result-document -->
    <xsl:param name="primary-output-target-url" as="xs:string">%_xslPath%.output.xml</xsl:param>
    
    <!-- What is the name of the key parameter in the stylesheet? It must be anticipating a sequence of strings representing resolved URLs -->
    <xsl:param name="key-parameter-name" as="xs:string" select="'main-input-resolved-urls'"/>
    
    <!-- Do you want to turn diagnostics on? This parameter does not affect the content of the output file(s). -->
    <xsl:param name="diagnostics-on" as="xs:boolean?" select="false()"/>

    <!-- END OF PARAMETERS -->
    <!-- + + + + + + + + + + + + + + -->
    
    
    <xsl:variable name="processor-path-resolved" as="xs:string"
        select="resolve-uri($processor-path-relative-to-this-stylesheet, static-base-uri())"/>
    
    <xsl:variable name="batch-file-template" as="xs:string"
        select="unparsed-text(resolve-uri('create%20app%20for%20xsl.bat', static-base-uri()))"/>
    
    <xsl:function name="tan:adjust-batch-file" as="xs:string">
        <!-- Input: a template batch file, assorted parameters -->
        <!-- Output: a revised version of the batch file -->
        <xsl:param name="target-url-resolved" as="xs:string"/>
        <xsl:variable name="new-saxon-path"
            select="tan:uri-relative-to($processor-path-resolved, $target-url-resolved)"
        />
        <!-- We process the output in multiple passes, to avoid indentations of too great a depth -->
        <xsl:variable name="output-pass-1" as="xs:string+">
            <!-- set up the path to the Saxon engine and its options (other than -xsl:, -o:, and -s:) -->
            <xsl:analyze-string select="$batch-file-template" regex="(set _saxonPath=)\S*">
                <xsl:matching-substring>
                    <xsl:value-of select="regex-group(1) || $new-saxon-path"/>
                </xsl:matching-substring>
                <xsl:non-matching-substring>
                    <xsl:analyze-string select="." regex="(set _saxonOptions=)\S*">
                        <xsl:matching-substring>
                            <xsl:value-of select="regex-group(1) || $default-saxon-options"/>
                        </xsl:matching-substring>
                        <xsl:non-matching-substring>
                            <xsl:value-of select="."/>
                        </xsl:non-matching-substring>
                    </xsl:analyze-string>
                </xsl:non-matching-substring>
            </xsl:analyze-string>
        </xsl:variable>
        <xsl:variable name="output-pass-2" as="xs:string+">
            <!-- set up option -o: and the key parameter -->
            <xsl:analyze-string select="string-join($output-pass-1)" regex="(set _keyParameter=)\S+">
                <xsl:matching-substring>
                    <xsl:value-of select="regex-group(1) || $key-parameter-name"/>
                </xsl:matching-substring>
                <xsl:non-matching-substring>
                    <xsl:analyze-string select="." regex="(set _xslOutput=)\S+">
                        <xsl:matching-substring>
                            <xsl:value-of select="regex-group(1) || $primary-output-target-url"/>
                        </xsl:matching-substring>
                        <xsl:non-matching-substring>
                            <xsl:value-of select="."/>
                        </xsl:non-matching-substring>
                    </xsl:analyze-string>
                </xsl:non-matching-substring>
            </xsl:analyze-string>
        </xsl:variable>
        <xsl:value-of select="string-join($output-pass-2)"/>
    </xsl:function>
    
    <xsl:output indent="yes"/>
    <xsl:template match="/">
        <xsl:if test="$diagnostics-on">
            <diagnostics>
                <main-input-urls-resolved count="{count($main-input-resolved-urls)}">
                    <xsl:for-each select="$main-input-resolved-urls">
                        <url doc-available="{doc-available(.)}"><xsl:value-of select="."/></url>
                    </xsl:for-each>
                </main-input-urls-resolved>
            </diagnostics>
        </xsl:if>
        <xsl:for-each select="$main-input-resolved-urls">
            <xsl:variable name="this-url" select="."/>
            <xsl:choose>
                <xsl:when test="doc-available($this-url)">
                    <xsl:variable name="this-doc" select="doc($this-url)"/>
                    <xsl:variable name="this-is-xslt" select="exists($this-doc/(xsl:stylesheet, xsl:transform))"/>
                    <xsl:variable name="these-params" select="$this-doc/*/xsl:param"/>
                    <xsl:variable name="these-possible-key-params" select="$these-params[not(@as) or (@as = ('xs:string+', 'xs:string*'))]"/>
                    <xsl:variable name="this-key-param" select="$these-params[@name = $key-parameter-name]"/>
                    <xsl:variable name="this-valid-key-param"
                        select="$these-possible-key-params[@name = $key-parameter-name]"/>
                    <xsl:choose>
                        <xsl:when test="$this-is-xslt and exists($this-valid-key-param)">
                            <xsl:variable name="target-href" select="replace($this-url, '.[^\.]+$', '.bat')"/>
                            <xsl:message select="'Saving batch file at ' || $target-href"/>
                            <xsl:result-document method="text" href="{$target-href}">
                                <xsl:value-of select="tan:adjust-batch-file($target-href)"/>
                            </xsl:result-document>
                        </xsl:when>
                        <xsl:when test="$this-is-xslt and exists($this-key-param)">
                            <xsl:message select="$this-url || ' is an XSLT document, and there is a key param named ' || $key-parameter-name || 
                                ' but it is not defined as taking a sequence of strings.'"/>
                        </xsl:when>
                        <xsl:when test="$this-is-xslt">
                            <xsl:message select="$this-url || ' is an XSLT document, but there is no key param named ' || 
                                $key-parameter-name || '. This operation expects a single parameter defined as accepting a sequence of strings. ' || 
                                string(count($these-possible-key-params)) || ' valid parameters exist. ' || string-join($these-possible-key-params/@name, ', ')"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message select="$this-url || ' is not an XSLT document'"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:message select="$this-url || ' is not available'"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:for-each>
    </xsl:template>
</xsl:stylesheet>
