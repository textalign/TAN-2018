<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
   xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0">
   <info>
      <title>The Text Alignment Network: Official Guidelines</title>
      <legalnotice>
         <info>
            <title>Text Alignment Network: Official Guidelines</title>
            <copyright>
               <year>2015-present</year>
               <holder>Joel Kalvesmaki</holder>
            </copyright>
            <author>
               <personname>Joel Kalvesmaki</personname>
               <email>kalvesmaki@gmail.com</email>
            </author>
         </info>
         <remark>All software, code, and dependencies (/applications, /functions, /schemas,
            /vocabularies) are released under a GNU General Public License, <link
               xlink:href="https://opensource.org/licenses/GPL-3.0"
               >https://opensource.org/licenses/GPL-3.0</link>.</remark>
         <remark>All other materials (such as this document), unless otherwise specified, are
            licensed under a Creative Commons Attribution 4.0 International License:
            http://creativecommons.org/licenses/by/4.0/ </remark>
      </legalnotice>
      <revhistory>
         <info>
            <releaseinfo>Latest stable version: <link
                  xlink:href="http://textalign.net/release/TAN-2020/guidelines/"
                  >http://textalign.net/release/TAN-2020/guidelines/</link>.</releaseinfo>
            <releaseinfo>Development version: <link
                  xlink:href="https://github.com/textalign/TAN-2020/tree/dev"
                  >https://github.com/textalign/TAN-2020/tree/dev</link></releaseinfo>
         </info>
         <revision>
            <revnumber>dev</revnumber>
            <date>2020-01-09</date>
            <revdescription>
               <para>Formats: <link
                     xlink:href="http://textalign.net/release/TAN-2020/guidelines/xhtml/index.xhtml"
                     >HTML</link> • <link
                     xlink:href="http://textalign.net/release/TAN-2020/guidelines/pdf/TAN-2020-guidelines.pdf"
                     >PDF</link> • <link
                     xlink:href="http://textalign.net/release/TAN-2020/guidelines/main.xml"
                     >Docbook</link> (master)</para>
               <warning>
                  <para>In case of contradictions, apparent or not, between these guidelines and the
                     core TAN files, priority should be given to the RELAX-NG schemas (compact
                     syntax), then to the functions, and then to these guidelines.</para>
               </warning>
            </revdescription>
         </revision>
      </revhistory>
   </info>
   <part xml:id="general_overview">
      <title>General Overview</title>
      <chapter>
         <title>Introduction</title>
         <section xml:id="tan_definition">
            <title>Definition and purpose </title>
            <para>The Text Alignment Network (TAN) is a suite of highly regulated XML formats,
               designed to maximize the syntactic and semantic interoperable alignment and exchange
               of texts, annotations, and language resources across projects. </para>
            <para>TAN is particularly suited to aligning texts with multiple versions (copies,
               translations, paraphrases), and to annotating quotations, translation clusters
               (word-to-word), and lexicomorphological features. Simple, modular, and networked, TAN
               files allow users, working independently and collaboratively, to find, create, edit,
               study, align, and share their texts and annotations. TAN's extensive validation rules
               rely upon a library of functions that definitively interpret the format and provide
               the foundation for a variety of tools.</para>
            <para>Although expressive of scholarly nuance and complexity, the TAN format has been
               designed to benefit everyone, scholars and non-scholars alike, and can be used
               broadly for reading, teaching, publishing, research, analysis, and language learning.
            </para>
         </section>
         <section>
            <title>Rationale and Purpose</title>
            <para>Scholars working with texts frequently need to study numerous versions. Some texts
               have been lost in their original form and can be studied only through later
               translations, paraphrases, or fragmentary quotations. Even when an original survives,
               its later versions are often worth study, revealing as they do something of how
               words, concepts, and works were preserved, altered, or combined by generations and
               cultures who created, read, and circulated the versions.</para>
            <para>Such textual comparison requires words, sentences, paragraphs, and other text
               segments to be aligned. Such alignment can be challenging. Some versions might be
               defective, or follow an idiosyncratic sequence. One editor may have divided the text
               according to a system not easily applied to other versions. Identifying which words
               or phrases in a translation correspond to which words or phrases in the original
               might result in complex, overlapping spans. And even larger segments such as
               sentences and paragraphs may not line up well. Further, every version of a text is
               part of a much larger, complex history of text reuse, and a complete study of that
               context requires not engagement with other works and other languages, requiring
               collaboration across projects and fields of study.</para>
            <para>Text Alignment Network (TAN) XML facilitates the exchange of multiple versions of
               texts and annotations on those texts. TAN files adopt a syntax suitable for humans to
               read and edit, expressive enough to allow scholars to register doubt and nuance, and
               sufficiently structured to permit complex computer-based queries across independent
               datasets. TAN is actually a suite of formats, built modularly, with each format
               designed to allow an editor to focus exclusively on a single set of tasks. Each
               format encourages or requires editors to declare their views or assumptions about
               language and texts in a structured manner, so that other users of the data (whether
               human or computer) can determine whether the data is suitable for their needs.
               Because nearly all TAN data must be expressed in way that computers can parse, the
               information can be used in semantic web applications.</para>
            <para>TAN has been designed to support two kinds of scholarly activity: <emphasis
                  role="bold">creation</emphasis> and <emphasis role="bold"
               >research</emphasis>.</para>
            <para>When we <emphasis role="bold">create</emphasis> our primary sources or analyses of
               them, we normally want what we create to be useful to our colleagues. TAN was
               designed to augment the utility of creative scholarly activities such as:</para>
            <para>
               <itemizedlist>
                  <listitem>
                     <para>Creating and sharing a transcription of a particular version of a textual
                        work such that it is most likely to align with any other TAN version of that
                        text created by someone else;</para>
                  </listitem>
                  <listitem>
                     <para>Creating an index of quotations that is semantically rich and can be
                        applied to any other version of the quoting or quoted works;</para>
                  </listitem>
                  <listitem>
                     <para>Specifying exactly (e.g., word-for-word) where a source and its
                        translation correspond, even when there may be messy overlapping or
                        ambiguous relationships, or where doubt or alternative possibilities of
                        alignment need to be expressed;</para>
                  </listitem>
                  <listitem>
                     <para>Listing the lexicomorphogical features of each word in a text or a
                        language such that the linguistic data has meaning above and beyond a
                        particular coding scheme, and can be collated with lexicomorphological data
                        for other languages.</para>
                  </listitem>
               </itemizedlist>
            </para>
            <para>Shared TAN files form a decentralized, interoperable corpus of texts, a kind of
               Internet of primary sources. As this TAN-compliant corpus expands across linguistic,
               chronological, and spatial boundaries, third-party tools and applications can expand
               the repertoire of <emphasis role="bold">research</emphasis> questions beyond any
               single corpus, to help scholars fruitfully investigate broader, comparative questions
               such as:<itemizedlist>
                  <listitem>
                     <para>For classical Greek texts, how were words with the root -ιστημι ("stand")
                        translated into ancient Latin? In what specific ways did the vocabulary of
                        technical terms shift from pre-Christian translations into later, Christian
                        ones?</para>
                  </listitem>
                  <listitem>
                     <para>How do the reformed Chinese translation technique of Sanskrit Buddhist
                        texts, attested by Dao An (312-385 CE), compare to reforms in the seventh
                        and eighth centuries of Syriac translations of Greek texts?</para>
                  </listitem>
                  <listitem>
                     <para>How do Arabic translations of Greek texts from the Abbasid period differ
                        from contemporaneous translations from Sanskrit into Arabic?</para>
                  </listitem>
                  <listitem>
                     <para>Can an anonymous English translation of a modern French novel be
                        identified with known translators of French novels from the same
                        period?</para>
                  </listitem>
                  <listitem>
                     <para>How do present-day translations of official United Nations documents
                        differ across languages?</para>
                  </listitem>
               </itemizedlist></para>
            <para>This is not to say that the TAN format, in itself, it answers such questions. It
               merely lays a framework within which such questions can be investigated. </para>
            <para>TAN differs from other formats such as HTML, Word documents, PDF, and Docbook.
               Each of those formats are interoperable only in the sense that they can be opened and
               displayed by the same software. But being laissez faire formats, they do not provide
               a way for creators to do anything more than link to other other documents.If you
               received from different people two versions of a particular work, even if those files
               were in one of those formats, there would be little likelihood that you could align
               them, without a lot of extra work.</para>
            <para>The closest analogue to TAN is the Text Encoding Initiative, an XML format that
               inspired TAN (and is even its foundation). TAN tries to go beyond TEI validation
               rules, and provide an infrastructure for greater cross-project interoporeability.
               (For more on comparisons between TAN and TEI see <xref linkend="TEI"/>.)</para>
            <para>Some other caveats:<itemizedlist>
                  <listitem>
                     <para>Although TAN comes with an extensive library of functions and templates,
                        it is not a tool per se. It does not provide software or applications to
                        create, edit, or display TAN-compliant files, nor does it dictate how such
                        tools should behave. Rather, it allows you or a programmer (especially an
                        XML developer) to create customized applications and tools.</para>
                  </listitem>
                  <listitem>
                     <para>The TAN formats are specialized. They supplement, and do not replace,
                        other common text formats such as TEI, Docbook, and so forth, or other
                        alignment formats such as XLIFF or TMX. Converting from TAN into these
                        formats is usually straightforward, but will normally entail loss. On the
                        other hand, converting from one of these formats into TAN normally will not
                        entail loss, but the process will be imperfect or incomplete, because the
                        TAN format requires data not required in the other formats. Conversion must
                        be given careful thought, and can only be semiautomated.</para>
                  </listitem>
                  <listitem>
                     <para>TAN has a restricted field of inquiry (defined and explained in these
                        guidelines). The format is not suitable for many research interests
                        supported by other formats, e.g., representing how a text appears in a
                        particular edition.</para>
                  </listitem>
                  <listitem>
                     <para>TAN has been designed to prioritize legibility and readability of the
                        format, even when it results in computational efficiency. The extensive TAN
                        validation routines—essential to aiding interoperability—can be taxing to
                        run on numerous or large files. There are work-arounds, but many of them
                        require development and experimentation.</para>
                  </listitem>
               </itemizedlist></para>
         </section>
         <section xml:id="tan_participation">
            <title>Participation</title>
            <para>Changes are being made regularly to TAN, mainly in its <link
                  xlink:href="https://github.com/textalign/TAN-2020/tree/dev">development
                  branch</link>. If you have a TAN library, sharing it with other participants,
               particularly via Git, will help test any changes that have been made, and allow
               others to offer updates or corrections to your library.</para>
            <para>Participants in testing, using, and developing the Text Alignment Network are
               welcome. Our core purpose is to develop and maintain the schemas, the guidelines,
               functions, and applications. Inquiries about participation should be sent to the
               project director, <link xlink:href="http://kalvesmaki.com/">Joel Kalvesmaki</link>,
               by email: directory at textalign.net.</para>
            <para>Official announcements are made by <link
                  xlink:href="http://groups.google.com/group/textalign?hl=en">email (Google
                  Group)</link> and by <link xlink:href="https://twitter.com/textalign"
                  >Twitter</link>.</para>
         </section>
      </chapter>
      <chapter xml:id="gentle_guide">
         <title>Starting off with the TAN Format</title>
         <para>If you are new to markup languages, or if you are unfamiliar with acronyms such as
               <emphasis role="italic">XML</emphasis>, <emphasis role="italic">RDF</emphasis>,
               <emphasis role="italic">XPath</emphasis>, or technical terms such as
               <emphasis>Unicode</emphasis>, you should start with this chapter, which uses a simple
            example to illustrate the steps typically taken to create and and edit TAN files. By the
            end, you will have a sense of how to create and edit a simple collection of TAN
            transcriptions and alignments.<note xml:id="transcription_and_transliteration">
               <para>In the TAN system, a <emphasis>transcription</emphasis> is a plain digital text
                  that reproduces the script and spelling of a text found somewhere else. By typing
                  "In pluribus unum" I have just now provided a transcription of a part of the
                  United States dollar. The term should be distinguished from a
                     <emphasis>transliteration</emphasis>, which is a transcription rendered in a
                  script other than the original. For example, εν πλουριμπυς ουνεμ, would be one way
                  to render my transcription in a Greek transliteration.</para>
            </note></para>
         <para>The chapter touches on a number of general concepts that are discussed only briefly.
            If you find the concept new or confusing, follow the prompts for further reading, to get
            better grounded in a particular topic or technology. If you are familiar with basic
            markup concepts, you may wish to read through the chapter very quickly, or skip it
            altogether.</para>
         <section>
            <title>Creating TAN Transcription and Alignment Data</title>
            <para>Let us take a simple example, that of aligning two English versions of the nursery
               rhyme <emphasis role="italic">Ring-a-ring-a-roses</emphasis>, sometimes known as
                  <emphasis role="italic">Ring around the Rosie</emphasis>. Our goal here is to
               publish two versions of the nursery rhyme in the TAN format so that they are most
               likely alignable with any other TAN version of the poem that someone might
               create.</para>
            <para>We begin by finding previously published versions that haven't been digitized. In
               this case we have taken an interest in the versions published in <link
                  xlink:href="http://lccn.loc.gov/12032709">1881</link> and <link
                  xlink:href="http://lccn.loc.gov/87042504">1987</link> (one published in the UK and
               the other, the US). Each of these books have other rhymes, but we've already decided
               to focus upon the one particular nursery rhyme, so we type up (transcribe) those
               parts and nothing else:<table frame="all">
                  <title>Ring around the Rosie</title>
                  <tgroup cols="2">
                     <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                     <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                     <thead>
                        <row>
                           <entry>1881 (UK) version</entry>
                           <entry>1987 (US) version</entry>
                        </row>
                     </thead>
                     <tbody>
                        <row>
                           <entry>
                              <para>Ring-a-ring-a-roses,</para>
                              <para>A pocket full of posies;</para>
                              <para>Hush! Hush! Hush! Hush!</para>
                              <para>We're all tumbled down.</para>
                           </entry>
                           <entry>
                              <para>Ring-a-round the rosie,</para>
                              <para>A pocket full of posies,</para>
                              <para>Ashes! Ashes!</para>
                              <para>We all fall down.</para>
                           </entry>
                        </row>
                     </tbody>
                  </tgroup>
               </table></para>
            <para>We must be sure to save each of the two transcriptions as plain text. Do not
               bother with word processor (Word, OpenOffice, Google Docs, and so forth), because
               those programs are too sophisticated for what we need to do. Word processors
               sometimes generate erroneous data, even when you export to plain text. And we will
               not be concerned with italics, colors, fonts, margins, and so forth. Much better for
               us is a <link xlink:href="http://en.wikipedia.org/wiki/Text_editor">text
                  editor</link>, which works only on plain text. But even those do not check to see
               if the rules of the TAN format have been followed. So the best tool is an <link
                  xlink:href="http://en.wikipedia.org/wiki/XML_editor">XML editor</link>, which does
               the same thing a text editor does, but saves a lot of typing, and prevents syntax
               errors. More important, an XML editor will tell us when our TAN file is invalid, and
               will provide important information and help as we edit.<note>
                  <para>Software suitable for your needs comes in many styles and prices. In
                     addition to the links in the paragraph above, you may wish to visit the
                     comparative lists for both <link
                        xlink:href="http://en.wikipedia.org/wiki/Comparison_of_text_editors">text
                        editors</link> and <link
                        xlink:href="http://en.wikipedia.org/wiki/Comparison_of_XML_editors">XML
                        editors</link>. TAN was developed using <link
                        xlink:href="https://www.oxygenxml.com">oXygen</link>, which is very powerful
                     but possibly confusing to new users. To avoid exasperation or despair, take
                     advantage of tutorials and documentation associated with the XML editor you
                     have chosen. </para>
               </note></para>
            <para>Our first task is to get these two versions into separate files with the
               appropriate markup. Each TAN transcription file has two major parts: a head and a
               body. For now, we focus on only the second part, the body, as well as a few the
               necessary preliminary lines that stand above both the head and the body. First, the
               1881 (UK) version:
               <programlisting><emphasis role="bold">&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;?xml-model href="http://textalign.net/release/TAN-2020/schemas/TAN-T.rnc" 
    type="application/relax-ng-compact-syntax"?>
&lt;?xml-model href="http://textalign.net/release/TAN-2020/schemas/TAN-T.sch" 
    type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
&lt;TAN-T xmlns="tag:textalign.net,2015:ns" TAN-version="2020" 
    id="tag:parkj@textalign.net,2015:ring01">
    &lt;head>
    . . . . . . .
    &lt;/head>
    &lt;body xml:lang="eng">
        &lt;div type="line" n="1"></emphasis>Ring-a-ring-a-roses,<emphasis role="bold">&lt;/div>
        &lt;div type="line" n="2"></emphasis>A pocket full of posies;<emphasis role="bold">&lt;/div>
        &lt;div type="line" n="3"></emphasis>Hush! Hush! Hush! Hush!<emphasis role="bold">&lt;/div>
        &lt;div type="line" n="4"></emphasis>We're all tumbled down.<emphasis role="bold">&lt;/div>
    &lt;/body>
&lt;/TAN-T></emphasis></programlisting>
               And now the 1987 (US) version:
               <programlisting><emphasis role="bold">&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;?xml-model href="http://textalign.net/release/TAN-2020/schemas/TAN-T.rnc" 
   type="application/relax-ng-compact-syntax"?>
&lt;?xml-model href="http://textalign.net/release/TAN-2020/schemas/TAN-T.sch" 
   type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
&lt;TAN-T xmlns="tag:textalign.net,2015:ns" TAN-version="2020" 
   id="tag:parkj@textalign.net,2015:ring02">
   &lt;head>
   . . . . . . .
   &lt;/head>
   &lt;body xml:lang="eng">
      &lt;div type="l" n="1"></emphasis>Ring-a-round the rosie,<emphasis role="bold">&lt;/div>
      &lt;div type="l" n="2"></emphasis>A pocket full of posies,<emphasis role="bold">&lt;/div>
      &lt;div type="l" n="3"></emphasis>Ashes! Ashes!<emphasis role="bold">&lt;/div>
      &lt;div type="l" n="4"></emphasis>We all fall down.<emphasis role="bold">&lt;/div>
   &lt;/body>
&lt;/TAN-T></emphasis></programlisting>
            </para>
            <para>These are standard eXtensible Markup Language (XML) files. (If you are already
               familiar with XML you may wish to skip ahead to the next section.) XML lets you take
               a text or a collection of data and structure it via markup. In the examples above,
               the markup is in boldface.</para>
            <para>Each file begins with a <emphasis role="bold">prolog</emphasis>, marked by the
               lines that begin with <code>&lt;?</code>. The first line in each prolog simply states
               that what follows is an XML document. The next pair of two lines in each example are
                  <emphasis role="bold">processing instructions</emphasis> that point to the
                  <emphasis role="bold">schemas</emphasis>: files that will be used to check to see
               whether or not our XML follows the rules, a process called <emphasis role="bold"
                  >validation</emphasis>. For now we will not explain the details of those first
               three lines, which will be identical, or nearly so, from one TAN file to the next. We
               can simply cut and paste those lines when we want to start a new TAN file.</para>
            <para>The fourth line is the <emphasis role="bold">opening tag</emphasis> of what is
               called the root <emphasis role="bold">element</emphasis>, here called <code><link
                     linkend="element-TAN-T">&lt;TAN-T></link></code>. That opening tag,
                  <code>&lt;TAN-T...></code> is answered by a <emphasis role="bold">closing
                  tag</emphasis>, <code>&lt;/TAN-T></code>, the last line. The paired-tag
               relationship is true for all the other elements in this example. <code><link
                     linkend="element-head">&lt;head></link></code> is answered by
                  <code>&lt;/head></code>, <code><link linkend="element-body"
                  >&lt;body></link></code> by <code>&lt;/body></code> and each
                  <code>&lt;div...></code> by <code>&lt;/div></code>. These elements nest within or
               beside each other, but they never overlap. (The prohibition on overlapping elements
               is one of the cardinal rules of XML.) This relationship means that every XML file can
               be thought of as a tree, with the root at the trunk and the enveloped elements as
               branches, terminating in metaphorical leaves. It is helpful to use the tree metaphor
               when we describe the path we take, toward either the leaves or the root. In these
               guidelines, we may use the terms <emphasis role="italic">rootward</emphasis> and
                  <emphasis role="italic">leafward</emphasis> when we want to trace movement up and
               down the levels of hierarchy in an XML document.</para>
            <para>An XML document is also profitably thought of as a family tree, a metaphor that
               provides commonly used terminology. In our examples above, <code><link
                     linkend="element-TAN-T">&lt;TAN-T></link></code> is the <emphasis role="italic"
                  >parent</emphasis> of <code><link linkend="element-body">&lt;body></link></code>,
               and <code><link linkend="element-body">&lt;body></link></code> the parent of the four
                     <code><link linkend="element-div">&lt;div></link></code> elements. Likewise,
               each <code><link linkend="element-div">&lt;div></link></code> is the <emphasis
                  role="italic">child</emphasis> of <code><link linkend="element-body"
                     >&lt;body></link></code>, and <code><link linkend="element-body"
                     >&lt;body></link></code> is the child of <code><link linkend="element-TAN-T"
                     >&lt;TAN-T></link></code>. Distant parental relationships can be described with
               the terms <emphasis role="italic">ancestor</emphasis> and <emphasis role="italic"
                  >descendant</emphasis>. <code><link linkend="element-TAN-T"
                  >&lt;TAN-T></link></code> is the ancestor of every element it encompasses, and
               every element encompassed by <code><link linkend="element-TAN-T"
                  >&lt;TAN-T></link></code> is its descendant. Paratactic relationships are also
               important. <code><link linkend="element-head">&lt;head></link></code> and <code><link
                     linkend="element-body">&lt;body></link></code> are <emphasis role="italic"
                  >siblings</emphasis> to each other, and every <code><link linkend="element-div"
                     >&lt;div></link></code> is a sibling to every other <code><link
                     linkend="element-div">&lt;div></link></code>.</para>
            <para>Inside of the opening tags for the <code><link linkend="element-TAN-T"
                     >&lt;TAN-T></link></code>, <code><link linkend="element-body"
                  >&lt;body></link></code>, and <code><link linkend="element-div"
                  >&lt;div></link></code> elements are stretches of text that are characterized by
               some word, followed by an equals sign, then something within quotation marks or
               apostrophes. These stretches of text are called <emphasis role="bold"
                  >attributes</emphasis>. The left side of the equals sign is the attribute name,
               and on the right side, within the quotation marks, is the attribute value.
                     <code><link linkend="element-TAN-T">&lt;TAN-T></link></code> has three
               attributes, <code>@xmlns</code>, <code><link linkend="attribute-TAN-version"
                     >@TAN-version</link></code>, and <code><link linkend="attribute-id"
                  >@id</link></code> (when we discuss an attribute outside its original context, we
               often preface the name with @). We will skip <code>@xmlns</code> for now; this
               attribute (actually, a pseudo-attribute) specifies the <emphasis role="bold"
                  >namespace</emphasis> of the XML file, an advanced topic that need not be
               discussed now. </para>
            <para>The value of <code><link linkend="attribute-TAN-version"
                  >@TAN-version</link></code> indicates that the 2020 version of TAN is being used. </para>
            <para><code><link linkend="attribute-id">@id</link></code> is quite important. Every TAN
               file has an <code><link linkend="attribute-id">@id</link></code> that uniquely and
               permanently identifies the file itself. It should not be changed, even as we make
               edits. If you change the filename or a copy of it winds up being incorporated into
               another project, a stable <code><link linkend="attribute-id">@id</link></code> will
               be quite important for finding it. </para>
            <para>The value of <code><link linkend="attribute-id">@id</link></code> must always be
               what is called a tag uniform resource name (tag URN). A tag URN begins with
                  <code>tag:</code>, followed by an email address or domain name that we own or
               owned. It is okay to use an obsolete address or domain; its purpose is to uniquely
               identify you, not necessarily to contact you, although that might be a nice side
               benefit. After that email address or domain name comes a comma (no spaces) and a date
               on which we owned it, in the form of year, year + month, or year + month + date, each
               item joined by hyphens, e.g., 2014-12-31. If we leave off a day value, it is assumed
               to be the first of the month; if we leave off the month value it is assumed to be
               January. </para>
            <para>In the examples above, <code>parkj@textalign.net,2015</code> points to our fictive
               self, Jenny Park, who owned that particular email address on the stroke of midnight
               (Coordinated Universal Time) January 1, 2015. After that comes a colon, and then any
               name we wish to assign to the file. </para>
            <para>We have anticipated a simple collection of texts, so we've called the files
                  <code>ring01</code> and <code>ring02</code>. If we run out of names, or want to
               restart, we can simply use a new email-date preface, e.g.,
                  <code>parkj@textalign.net,2015-01-02</code>. Or we could change the way we build
               our tag URNs.</para>
            <para>The idea here is that hundreds of years from now, when that email will be defunct
               or owned by someone else, users might still be able to identify the person or
               organization responsible for creating the file.</para>
            <para>The element <code><link linkend="element-body">&lt;body></link></code> contains
               our transcription. <code><link linkend="attribute-xmllang">@xml:lang</link></code>,
               required, specifies the principal language of the transcribed text. We use the
               standard 3-letter abbreviation for English. (See <xref xlink:href="#language"/> for
               more complex requirements.) </para>
            <para>Our transcription has been divided into four <code><link linkend="element-div"
                     >&lt;div></link></code> elements. How we divide up the work is entirely up to
               us. But we must make sure that every bit of text is enclosed by a leaf <code><link
                     linkend="element-div">&lt;div></link></code> (one that contains no other
                     <code><link linkend="element-div">&lt;div></link></code>). Every <code><link
                     linkend="element-div">&lt;div></link></code> must be the parent of only other
                     <code><link linkend="element-div">&lt;div></link></code>s, or none at all. No
                     <code><link linkend="element-div">&lt;div></link></code> may mix text with
               other elements. The values of <code><link linkend="attribute-type"
                  >@type</link></code> and <code><link linkend="attribute-n">@n</link></code>
               indicate, respectively, the type of division and the name of the division. We have
               used <code>line</code> in the first example, but we could easily have also used
                  <code>l</code> (as we did in the second) or <code>ln</code> or any other phrase
               that we think will make intuitive sense to other users. The value is arbitrary (we
               will see why below). We have used arabic numerals for the values of <code><link
                     linkend="attribute-n">@n</link></code>, but the value, once again, could have
               been anything. We could have used Roman numerals, or some other naming scheme that is
               standard in the field. It is most important that <code><link linkend="attribute-n"
                     >@n</link></code> draw from a reference system that applies to multiple
               versions of the work.</para>
            <para>Aside from the <code><link linkend="element-head">&lt;head></link></code> element
               (discussed later), that's all we need in the transcription. We can now move to
               alignment and annotation.</para>
            <para>The TAN-A format allows us to align and annotate as many TAN-T or TAN-TEI files as
               we wish, and to make claims about them. Let's begin (once again suppressing
                     <code><link linkend="element-head"
               >&lt;head></link></code>):<programlisting>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;?xml-model href="http://textalign.net/release/TAN-2018/schemas/<emphasis role="bold">TAN-A.rnc</emphasis>" 
    type="application/relax-ng-compact-syntax"?>
&lt;?xml-model href="http://textalign.net/release/TAN-2018/schemas/<emphasis role="bold">TAN-A.sch</emphasis>" 
    type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
&lt;<emphasis role="bold">TAN-A</emphasis> xmlns="tag:textalign.net,2015:ns" TAN-version="2020" 
    id="tag:parkj@textalign.net,2015:<emphasis role="bold">ring-alignment</emphasis>">
    &lt;head>
    . . . . . . .
    &lt;/head>
    <emphasis role="bold">&lt;body/>
</emphasis>&lt;/TAN-A></programlisting></para>
            <para>In the prolog, the first line is identical to the first line of our transcription
               files. The second and third lines, the processing instructions, are identical, except
               that <code>href</code> points to the validation files specific to the TAN-A format.
               Even the fourth line looks like the two TAN-T files, other than the new name for the
               root element, <code><link linkend="element-TAN-A">&lt;TAN-A></link></code>, and the
               new value for <code><link linkend="attribute-id">@id</link></code>.</para>
            <para>The penultimate line, <code>&lt;body/></code>, is what is called an empty element,
               and is equivalent to an opening tag immediately followed by a closing tag, i.e.,
                     <code><link linkend="element-body">&lt;body></link>&lt;/body></code>. The
               alternative form, <code>&lt;body/></code>, is a shorter and easier way to indicate an
               elements that contains nothing. It will become apparent, when we discuss <code><link
                     linkend="element-head">&lt;head></link></code> below, why our <code><link
                     linkend="element-body">&lt;body></link></code> can be empty.</para>
            <para>The other kind of alignment, TAN-A-tok, takes a bit more work, because we must
               first identify words that correspond with each other. Even before we do that, we need
               to decide what kind of relationship holds between the two texts. Let us pretend, for
               the sake of example, that the 1987 version is a direct descendant (and therefore
               variation) of the 1881 one. So our task is to show exactly what parts of the the
               older version correspond to those of the newer one. We will simplify in this case,
               and assume an interest only in words, ignoring space and punctuation. We will also
               call these words <emphasis>tokens</emphasis> (<emphasis role="italic">word</emphasis>
               is notoriously difficult to define, and has connotations lacking in
                  <emphasis>token</emphasis>).</para>
            <para>We now create a TAN-A-tok
               file:<programlisting>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;?xml-model href="http://textalign.net/release/TAN-2020/schemas/<emphasis role="bold">TAN-A-tok.rnc</emphasis>" 
    type="application/relax-ng-compact-syntax"?>
&lt;?xml-model href="http://textalign.net/release/TAN-2020/schemas/<emphasis role="bold">TAN-A-tok.sch</emphasis>" 
    type="application/xml" schematypensrc="http://purl.oclc.org/dsdl/schematron"?>
&lt;<emphasis role="bold">TAN-A-tok</emphasis> xmlns="tag:textalign.net,2015:ns" 
    id="tag:parkj@textalign.net,2015:<emphasis role="bold">TAN-A-tok,ring01+ring02</emphasis>">
    &lt;head>
    . . . . . . .
    &lt;/head>
    &lt;body <emphasis role="bold">bitext-relation="B-descends-from-A" reuse-type="general_adaptation"</emphasis>>
        <emphasis role="bold">&lt;!-- Examples of picking tokens by number -->
        &lt;align>
            &lt;tok src="ring1881" ref="1" pos="1"/>
            &lt;tok src="ring1987" ref="1" pos="1"/>
        &lt;/align>
        &lt;align>
            &lt;tok src="ring1881" ref="1" pos="2"/>
            &lt;tok src="ring1987" ref="1" pos="2"/>
        &lt;/align>
        &lt;align>
            &lt;tok src="ring1881" ref="1" pos="3"/>
            &lt;tok src="ring1987" ref="1" pos="3"/>
        &lt;/align>
        &lt;align>
            &lt;tok src="ring1881" ref="1" pos="4"/>
            &lt;tok src="ring1987" ref="l" pos="4"/>
        &lt;/align>
        &lt;align>
            &lt;tok src="ring1881" ref="1" pos="5"/>
            &lt;tok src="ring1987" ref="1" pos="5"/>
        &lt;/align>
        &lt;!-- Examples of picking tokens by value -->
        &lt;align>
            &lt;tok src="ring1881" ref="2" val="A"/>
            &lt;tok src="ring1987" ref="2" val="A"/>
        &lt;/align>
        &lt;align>
            &lt;tok src="ring1881" ref="2" val="pocket"/>
            &lt;tok src="ring1987" ref="2" val="pocket"/>
        &lt;/align>
        &lt;align>
            &lt;tok src="ring1881" ref="2" val="full"/>
            &lt;tok src="ring1987" ref="2" val="full"/>
        &lt;/align>
        &lt;align>
            &lt;tok src="ring1881" ref="2" val="of"/>
            &lt;tok src="ring1987" ref="2" val="of"/>
        &lt;/align>
        &lt;align>
            &lt;tok src="ring1881" ref="2" val="posies"/>
            &lt;tok src="ring1987" ref="2" val="posies"/>
        &lt;/align>
        &lt;!-- Examples of picking ranges of tokens -->
        &lt;align>
            &lt;tok src="ring1881" ref="3" pos="1, 2"/>
            &lt;tok src="ring1987" ref="3" pos="1"/>
        &lt;/align>
        &lt;align>
            &lt;tok src="ring1881" ref="3" pos="3 - 4"/>
            &lt;tok src="ring1987" ref="3" pos="2"/>
        &lt;/align>
        &lt;align>
            &lt;tok src="ring1881" ref="4" pos="1"/>
            &lt;tok src="ring1987" ref="4" pos="1"/>
        &lt;/align>
        &lt;align>
            &lt;tok src="ring1881" ref="4" pos="2"/>
        &lt;/align>
        &lt;align>
            &lt;tok src="ring1881" ref="4" pos="3"/>
            &lt;tok src="ring1987" ref="4" pos="2"/>
        &lt;/align>
        &lt;!-- examples of using "last" -->
        &lt;align>
            &lt;tok src="ring1881" ref="4" pos="last-1"/>
            &lt;tok src="ring1987" ref="4" pos="last-1"/>
        &lt;/align>
        &lt;align>
            &lt;tok src="ring1881" ref="4" ord="last"/>
            &lt;tok src="ring1987" ref="4" ord="last"/>
        &lt;/align></emphasis>
    &lt;/body>
&lt;/TAN-A-tok></programlisting></para>
            <para>Once again, the first four lines, the prolog and root element, should look
               familiar, with the only significant changes being the names of the validation files,
               the name of the root element (<code><link linkend="element-TAN-A-tok"
                     >&lt;TAN-A-tok></link></code>) and the value of <code><link
                     linkend="attribute-id">@id</link></code>.</para>
            <para>The heart of the data is <code><link linkend="element-body"
                  >&lt;body></link></code>, which has two key attributes, <code><link
                     linkend="attribute-reuse-type">@reuse-type</link></code>, which specifies the
               default type of relationship between the two sources, and <code><link
                     linkend="attribute-bitext-relation">@bitext-relation</link></code>, which
               specifies how the versions relate to each other. Our two values,
                  <code>B-descends-from-A</code> and <code>general_adaptation</code>, are arbitrary
               names that we define in the <code><link linkend="element-head"
                  >&lt;head></link></code> (discussed later). </para>
            <para>You will also notice some lines that begin <code>&lt;!--</code> and end
                  <code>--></code>. These are <emphasis role="bold">comments</emphasis>, and can be
               placed within or beside any element, and can enclose any text we like, including line
               breaks.</para>
            <para><code><link linkend="element-body">&lt;body></link></code> is the parent of one or
               more <code><link linkend="element-align">&lt;align></link></code> elements, each of
               which correlates a set of tokens in the two texts through its <code><link
                     linkend="element-tok">&lt;tok></link></code> children. Each <code><link
                     linkend="element-tok">&lt;tok></link></code> has, in this example, three
               attributes. <code><link linkend="attribute-src">@src</link></code> takes a nickname
               (an <code><link linkend="attribute-id">@id</link></code> reference) that points to
               one of the two transcriptions; we have used <code>ring1881</code> and
                  <code>ring1987</code> but we could have just as easily used anything else such as
                  <code>a</code> and <code>b</code> or <code>uk</code> and <code>us</code>.
                     <code><link linkend="attribute-ref">@ref</link></code> has a value that points
               to a specific <code><link linkend="element-div">&lt;div></link></code> in the source
               TAN-T transcription; and <code><link linkend="attribute-pos">@pos</link></code> or
                     <code><link linkend="attribute-val">@val</link></code> specify which token is
               intended, either by word number (<code><link linkend="attribute-pos"
                  >@pos</link></code>) or text of the actual word (<code><link
                     linkend="attribute-val">@val</link></code>). Either technique is fine, and can
               be mixed, as in the example. You may also notice that the comma and hyphen can be
               used in <code><link linkend="attribute-pos">@pos</link></code> to point to multiple
               words within the same <code><link linkend="element-div">&lt;div></link></code>, and
               that <code>last</code> and <code>last-X</code> (where <code>X</code> is a digit) can
               be used to point to a token relative to the last one in a <code><link
                     linkend="element-div">&lt;div></link></code>.</para>
            <para>Each <code><link linkend="element-align">&lt;align></link></code> can establish
               one-to-one, one-to-many, many-to-one, or many-to-many relationships between tokens
               from the two texts. A token may feature in multiple <code><link
                     linkend="element-align">&lt;align></link></code> elements. And if an
                     <code><link linkend="element-align">&lt;align></link></code> has <code><link
                     linkend="element-tok">&lt;tok></link></code> elements belonging to only one
               source, such as in the fourth-to-last <code><link linkend="element-align"
                     >&lt;align></link></code> above, we have what is called, in these guidelines, a
                  <emphasis>half-null alignment</emphasis>. This half-null alignment indicates that
               the second word of line four of the 1881 version is excluded from the act that we
               have called <code>adaptation</code> (a term that, as we shall see, is explained in
               the <code><link linkend="element-head">&lt;head></link></code>). If this were a
               translation, it would be as if we were saying that this word was excluded from the
               translation. (A half-null alignment containing tokens only of the later source might
               point to words that the translator added, i.e., explicitation.) </para>
            <para>A half-null alignment should not be confused with silence. As creators of this
               file, we make no claim to providing an exhaustive account, and we are under no
               obligation to indicate every word-for-word correspondence. If we fail to mention
               certain words, all that can be implied is that we opted not to say anything about
               them.</para>
            <para>We could have aligned the two texts in different ways. Perhaps further study will
               reveal that we were in error to associate the second "ring" with "round" in line 1.
               We can make corrections, even after publication, and signal the change to users of
               our data. There are also ways to express doubt or alterative opinions, and to credit
               (or blame) those opinions to the person making them. We can even correlate fragments
               of tokens (letters, prefixes, infixes, or suffixes). All these more advanced uses are
               discussed at <xref xlink:href="#tan-a-tok"/>.</para>
         </section>
         <section>
            <title>The Principles of TAN Metadata (<code><link linkend="element-head"
                     >&lt;head></link></code>)</title>
            <para>At this point, we have finished four TAN files: two transcriptions, one TAN-A
               file, and one TAN-A-tok file. But we've suppressed the <code><link
                     linkend="element-head">&lt;head></link></code> in all of them, until now.
               Before getting into details, we need first to explain a few principles behind
               TAN.</para>
            <para>Unlike <code><link linkend="element-body">&lt;body></link></code>, which carries
               the raw data, <code><link linkend="element-head">&lt;head></link></code> contains
               what is oftentimes called metadata. That is, <code><link linkend="element-head"
                     >&lt;head></link></code> contains data about the data that is in <code><link
                     linkend="element-body">&lt;body></link></code>. Because the TAN format is
               intended primarily to serve scholars, and because the format is heavily regulated
               (that is, there are numerous validation rules that supplement the standard XML ones),
               the metadata requirements are stricter than they are for Word documents, HTML, TEI,
               or other formats you might know better. Scholars who find our file really must know
               some things about it before they can responsibly use it. For example, what are the
               sources we have used? Who produced the data? When? What changes or adjustments have
               been made? What licenses govern the use of the data? The questions are not difficult
               to answer, but they are critical, and require thought, care, and some time.</para>
            <para>Some metadata questions are specific to certain formats. For example, in a
               TAN-A-tok file, we ask what relationship holds between the two sources. But that
               question makes no sense for a TAN-T file, which is merely a transcription. Some
               questions apply universally across all TAN files, no matter what kind of data. The
               TAN formats have been designed so that common questions are handled in the same place
               in the <code><link linkend="element-head">&lt;head></link></code> , and questions
               unique to a particular format are in a predictable place. This reduces potential
               confusion, and helps other people using our data to find the information they want.
               More importantly, what we write in one file could be incorporated in another, and
               will reduce the need for duplication.</para>
            <para>Another TAN principle is that each <code><link linkend="element-head"
                     >&lt;head></link></code> should focus exclusively upon a primary task, namely
               the data in <code><link linkend="element-body">&lt;body></link></code>, and not on
               other things. For example, in a TAN-T file, we must indicate the source of the
               transcription. But we don't need to describe that source further. We are not library
               catalogers, nor should we be. A TAN-T file is for transcribing, not to curate
               bibliographical data. Our obligation is merely to point somewhere a reader can get
               more complete information.</para>
            <para>TAN was also designed under the principle that all metadata should be useful to
               both humans and computers. For our example above, we must describe the work we have
               chosen (<emphasis role="italic">Ring around the Rosie</emphasis>) in a way that is
               comprehensible not just to the reader but to the computer.</para>
            <para>Take for example the 1881 book we have used for our first transcription. For the
               human reader we can write something like "Kate Greenaway, <emphasis>Mother
                  Goose</emphasis>, New York, G. Routledge and sons [1881]". But this human-readable
               string is too complex, and syntactically opaque for computers and algorithms. A more
               computer-friendly identifier would be international standard book numbers (ISBNs),
               which distinguish the 1984 version of <emphasis>Mother Goose</emphasis> illustrated
               by Kayoko Okumura from the one of the same year illustrated by William Joyce. The
               ISBNs for the Okumura version, 0671493159, and for Joyce's, 0394865340, can be
               converted into a machine-actionable string called universal resource names (URNs), in
               this case <code>urn:isbn:0-671493159</code> and <code>urn:isbn:0-394865340</code>.
               (Our 1881 version was published before the ISBN program was introduced. We will see
               below another way to name it.)</para>
            <para>There are different types of URNs, schemes for journals (via ISSNs,
                  <code>urn:issn:...</code>), articles (DOIs, <code>urn:doi:...</code>), and movies
               (ISANs, <code>urn:isan:...</code>), which means that anyone can use them to refer
               unambiguously to a particular kind of thing. URN naming schemes must be registered
               with the Internet Assigned Numbers Authority (IANA) to ensure permanent, persistent,
               unique names for various types of things. (See <link
                  xlink:href="https://www.iana.org/assignments/urn-namespaces/urn-namespaces.xhtml"
                  >IANA's registry</link> and <xref xlink:href="#variable-official-urn-namespaces"/>
               for a complete list.)</para>
            <para>All URNs are simply names. They don't tell you where an object is. To provide a
               unique <emphasis role="italic">location</emphasis>, however, we have universal
               resource locators (URLs), a term that might be more familiar from daily use of the
               Internet, e.g., <code>http://academia.edu</code>. Like URNs, URLs are also centrally
               regulated, with individuals or organizations buying the rights to domain names from a
               central registry (usually through a third-party vendor).</para>
            <para>Both URNs and URLs can be thought of as the same type of thing, namely, a
               universal resource identifier (URI), sometimes called an international resource
               identifier (IRI). An IRI is a type of URN that allows any alphabet in Unicode, not
               just Latin. URIs/IRIs are, in essence, nothing more than the set of all URNs and
               URLs. These four acronyms can be easily confused, and it is best to disambiguate them
               by thinking of the last letter in each. UR<emphasis role="bold"
                  >I</emphasis>s/IR<emphasis role="bold">I</emphasis>s <emphasis role="bold"
                  >I</emphasis>ncorporate both <emphasis role="bold">L</emphasis>ocators
                  (UR<emphasis role="bold">L</emphasis>) and <emphasis role="bold">N</emphasis>ames
                  (UR<emphasis role="bold">N</emphasis>).</para>
            <para>If those acronyms are confusing, don't worry. For our purposes, they are pretty
               much are the same, and from this point onward we'll stick with the term IRI (unless
               we really mean a location, which we'll call a URL).</para>
            <para>IRIs are essential to a system frequently called the semantic web or linked (open)
               data, which relies upon IRIs as the basis for a simple universal data model. The
               semantic web allows people to make assertions in a way that computers can
               "understand." If people, working independently, happen to use the same IRIs to
               describe the same things, then computers can be programmed to make associations
               between disparate, heterogenous datasets. The result is a network of linked data that
               allows us or anyone else to discover connections across disciplines and projects, and
               make inferences that transcend any single project.</para>
            <para>TAN has been designed to be linked-data friendly, and so requires in its
                     <code><link linkend="element-head">&lt;head></link></code> almost all data to
               be representable not just human-readable but also computer-readable, normally as an
               IRI. </para>
            <para>Our first task, then, in writing the <code><link linkend="element-head"
                     >&lt;head></link></code> sections of our four TAN files is to look for IRI
               vocabulary that will be familiar to the people most likely to use our files. In
               trying to find suitable IRIs, we will find that the persons, things, and concepts we
               want to describe will range from the highly familiar to the unfamiliar.</para>
            <para><emphasis role="italic">Highly familiar</emphasis>: The two books that provide the
               basis of our transcription are well catalogued and generally known. A number of
               services provided by librarians provide controlled IRI vocabularies that can be used
               by anyone to unambiguously identify a particular version of a book. <link
                  xlink:href="http://www.worldcat.org">WorldCat</link> (run by OCLC) and the <link
                  xlink:href="http://catalog.loc.gov">Library of Congress</link> are good examples.
               In our case, we have found accurate Library of Congress IRIs for both editions of
                  <emphasis>Mother Goose</emphasis>: <code>http://lccn.loc.gov/12032709</code> and
                  <code>http://lccn.loc.gov/87042504</code>. Observe that these two IRIs are also,
               perhaps confusingly, URLs (locations). If we paste these strings into our browser, we
               retrieve a record that describes the book. This locator does not lead us to the book
               itself, only to information <emphasis role="italic">about</emphasis> the book.
               Nevertheless, the Library of Congress has decided to make this URL also a name for
               the book, which means that it does double duty, both as a web page and a name. Anyone
               who owns a domain name can designate a URL as a name for an object, a practice that
               can easily confuse anyone new to the semantic web, because such URLs name in reality
               two types of things: an entity and a location to find out more information about that
               entity. </para>
            <para>We now have IRIs for the sources. Let's now find an IRI to name the work,
                  <emphasis role="italic">Ring around the Rosie</emphasis>. The work is widely
               known, and even has a <link
                  xlink:href="http://en.wikipedia.org/wiki/Ring_a_Ring_o%27_Roses">Wikipedia
                  entry</link>. That Wikipedia entry is a benefit. The Universities of Leipzig and
               Mannheim and Openlink Software have collaborated on a project called <link
                  xlink:href="http://wiki.dbpedia.org/About">DBPedia</link>, which provides a unique
               URN for every Wikipedia entry in the major languages. The DBPedia URN in this case is
                  <code>http://dbpedia.org/resource/Ring_a_Ring_o%27_Roses</code>. Once again, this
               is both a name and a locator. It names a specific intangible object, namely a nursery
               rhyme that we've called <emphasis>Ring around the Rosie</emphasis>, no matter what
               specific version. But if you put that name into your browser, you will get back more
               information about that named object.</para>
            <para><emphasis role="italic">Familiar, but only in small circles</emphasis>: We will
               need to have IRIs for some of the people who edited the file. Here we're not
               interested in the authors of our books. We are interested in identifying the people
               who helped make the TAN file. Most people who write and edit TAN files will not be
               well-known, public figures. If they are, and if they are famous enough to have a
               Wikipedia entry, then a DBPedia IRI could be used. Or if some of the contributors are
               also published authors, there is a good chance that they are listed in the databases
               of either <link xlink:href="http://viaf.org">VIAF</link> or <link
                  xlink:href="http://isni.org">ISNI</link>, both of which publish unique IRIs for
               persons. </para>
            <para>Most contributors to TAN files, however, will not be listed in these databases. In
               those cases, we can name these participants with an IRI that we "own." We have
               already done something like this by assigning tag URNs to our four TAN files (the
               value of <code><link linkend="attribute-id">@id</link></code> in the root element).
               Our editors can do the same thing. If a student Robin Smith has been helping with
               proofreading, Robin can take an email address (even one that doesn't work any more)
               and a date when the email address was used and construct a tag URN such as
                  <code>tag:smith.robin@example.com,2012:self</code>. This has a slight drawback in
               that we cannot type this string into our browser to find out more about the Robin,
               but it at least allows us to assign a name that will not be confused as another Robin
               Smith, for example the one identified by ISNI as
                  <code>http://isni.org/isni/0000000043306406</code>. (If we want to go a step
               further, Robin could mint a URN from a domain name that she owns, and set up a linked
               data service that offers more information, human- and computer-readable. But this is
               not required, and it can be a lot of work to set up and maintain.)</para>
            <para>Let's take a more difficult challenge, that of defining <code><link
                     linkend="attribute-bitext-relation">@bitext-relation</link></code> in our
               TAN-A-tok file. We have to find an IRI that describes the relationship that we claim
               holds between two text-bearing objects. Making that clear is important, because our
               perspective about the relationship between the two books affects the specifics of our
               word-for-word alignments, and other scholars using our files will want to know what
               assumptions we brought to our task. </para>
            <para>We are assuming for the sake of illustration that the version published in the
               1987 <emphasis>Mother Goose</emphasis> is a direct descendant of the 1881 version.
               Because no suitable IRI vocabulary yet exists for such concepts, TAN has coined an
               IRI that can be used by anyone wishing to declare that, given two ordered sources,
               the second descends from the first through an unknown number of intermediaries:
                  <code>tag:textalign.net,2015:bitext-relation:a/x+/b</code>. We'll use that one for
               now.</para>
            <para>We face a similar issue when thinking about text reuse. We generally consider the
               1987 version to be an adaptation of the 1881 version. And there are not stable,
               well-published IRI vocabularies for text reuse. So we adopt a TAN-coined IRI,
                  <code>tag:textalign.net,2015:reuse-type:adaptation:general</code>.</para>
            <para>In the previous two cases, we could have come up with our own vocabulary. But the
               idea behind the semantic web is that we should be drawing from a common vocabulary
               whenever possible. The built-in TAN vocabulary simply gives us a convenient lingua
               franca for describing some important but abstract concepts. For other examples of
               IRIs coined by TAN, see <xref linkend="vocabularies-master-list"/>.</para>
            <para><emphasis role="italic">Generally unfamiliar</emphasis>: Some things or concepts
               will be unknown to very few people, perhaps even us. If we plan to refer to that
               thing or concept often, it is preferable to coin a tag URN, as described above. But
               in some cases, we might find that a tag URN we minted for some concept or thing was,
               in hindsight, misleading or poorly constructed, because we hadn't thought as
               thoroughly as we could have about the category. If we wish to avoid such situations,
               we can assign a randomly generated IRI called a universally unique identifier (UUID),
               e.g., <code>urn:uuid:3fd9cece-b246-4556-b229-48f22a5ae2e0</code>. Uuid URNs are very
               useful. The likelihood that a randomly generated uuid will be identical to any other
               uuid is astronomically improbable, making them reliably unique names for anything
               (barring someone copying and reusing that uuid URN to name some other object or
               concept). Numerous free UUID generators can be found online.</para>
            <para>To humans, a UUID on its own is meaningless, unmemorable, and rather ugly. But it
               is a start. We always have the option, later, of supplementing it with other IRIs.
               It's perfectly fine to give one object or concept multiple IRIs. But the reverse is
               never true. One should never use one IRI to identify more than one object or
               concept.</para>
         </section>
         <section>
            <title>Creating TAN Metadata (<code><link linkend="element-head"
               >&lt;head></link></code>)</title>
            <para>Now that we have explored various IRI vocabularies for concepts around our
               versions of <emphasis>Ring-a-ring-a-roses</emphasis>, we can now complete the
               metadata in our four TAN files. Let us start with the TAN-T file of the 1881
               version:<programlisting>&lt;TAN-T xmlns="tag:textalign.net,2015:ns" TAN-version="2020" 
    id="tag:parkj@textalign.net,2015:ring01">
    &lt;head>
        <emphasis role="bold">&lt;name>TAN transcription of Ring a Ring o' Roses&lt;/name>
        &lt;master-location 
            href="http://textalign.net/release/TAN-2020/examples/ring-o-roses.eng.1881.xml"/>
        &lt;license licensor="park">
            &lt;IRI>http://creativecommons.org/licenses/by/4.0/&lt;/IRI>
            &lt;name>Attribution 4.0 International&lt;/name>
        &lt;/license>
        &lt;work>
            &lt;IRI>http://dbpedia.org/resource/Ring_a_Ring_o%27_Roses&lt;/IRI>
            &lt;name>"Ring a Ring o' Roses" or "Ring Around the Rosie"&lt;/name>
        &lt;/work>
        &lt;source>
            &lt;IRI>http://lccn.loc.gov/12032709&lt;/IRI>
            &lt;name>Kate Greenaway, Mother Goose, New York, G. Routledge and sons [1881]&lt;/name>
        &lt;/source>
        &lt;vocabulary-key>
            &lt;person xml:id="park">
                &lt;IRI>tag:parkj@textalign.net,2015:self&lt;/IRI>
                &lt;name>Jenny Park&lt;/name>
            &lt;/person>
            &lt;div-type xml:id="line">
                &lt;IRI>http://dbpedia.org/resource/Line_(poetry)&lt;/IRI>
                &lt;name>line of poetry&lt;/name>
            &lt;/div-type>
            &lt;role xml:id="creator">
                &lt;IRI>http://schema.org/creator&lt;/IRI>
                &lt;name xml:lang="eng">creator&lt;/name>
            &lt;/role>
        &lt;/vocabulary-key>
        &lt;file-resp who="park"/>
        &lt;resp roles="creator" who="park"/>
        &lt;change when="2014-08-13" who="park">Started file&lt;/change>
        &lt;to-do/></emphasis>
    &lt;/head>
    . . . . . . .
&lt;/TAN-T></programlisting></para>
            <para><code><link linkend="element-name">&lt;name></link></code>, the human readable
               counterpart to the <code><link linkend="attribute-id">@id</link></code> that is
               inside the root element, can be anything. And we can supply more than one <code><link
                     linkend="element-name">&lt;name></link></code>, in case we wish to provide
               names of the file in different languages or variations.</para>
            <para>One or more <code><link linkend="element-master-location"
                     >&lt;master-location></link></code>s provide URLs where master versions of the
               file are kept (and updated). We provide this as a courtesy to others who might be
               using our data. Anyone who validates a local copy of the file will be warned if it
               does not match the master version, and be told the most recent changes. This allows
               users to found out if changes have been made, and it allows us to make corrections
               and silently notify other users of our alterations. To communicate this, we do not
               have to keep track of who is using the file. <code><link
                     linkend="element-master-location">&lt;master-location></link></code> is
               mandatory only if we are keeping a to-do list, which is specified at <code><link
                     xlink:href="#xml">&lt;to-do></link></code>. If that element is empty, then we
               imply that we do not intend to do further work on the file. Conversely, any elements
               in <code><link xlink:href="#xml">&lt;to-do></link></code> specify what remains to be
               done, to warn (or enlist the help of) other people who might use our data. </para>
            <para><code><link linkend="element-license">&lt;license></link></code> specifies the
               license under which we are releasing our data. This element has nothing to do with
               the copyright of the source we have used (although, having been published in 1881,
               the book is clearly in the public domain). That is, we are specifying what rights are
               attached to the data, not its source, i.e., if we have placed additional strictures
               on the file. In this example, we have released the data under a creative commons
               license. The child element <code><link linkend="element-IRI">&lt;IRI></link></code>
               specifies a Creative Commons IRI, and <code><link linkend="element-name"
                     >&lt;name></link></code> is the human-readable form.</para>
            <para><code><link xlink:href="#attribute-licensor">@licensor</link></code> specifies who
               has granted the license, in this case our fictive Jenny Park (see below).</para>
            <para>The conjunction of <code><link linkend="element-IRI">&lt;IRI></link></code> and
                     <code><link linkend="element-name">&lt;name></link></code>, the <emphasis>IRI +
                  name pattern</emphasis>, recurs throughout TAN files. We may include any number of
                     <code><link linkend="element-IRI">&lt;IRI></link></code> or <code><link
                     linkend="element-name">&lt;name></link></code> elements in an IRI + name
               pattern. But if we do so, we are stating that they are synonymous, i.e., that they
               all name the same thing.</para>
            <para><code><link linkend="element-work">&lt;work></link></code> uses the IRI + name
               pattern to name the work we have chosen to transcribe. <code><link
                     linkend="element-source">&lt;source></link></code> points, through its IRI +
               name pattern, to a computer- and human-readable description of the book we have
               chosen. </para>
            <para><code><link linkend="element-vocabulary-key">&lt;vocabulary-key></link></code>
               contains vocabulary that we are using in our file. In this element we place elements
               defined by the IRI + name pattern and connect them to ids that uniquely name the
               concepts in our file. For example, an IRI + name pattern is used for <code><link
                     linkend="element-person">&lt;person></link></code>, which identifies through a
               tag URN Jenny Park. The value of <code><link linkend="attribute-xmlid"
                  >@xml:id</link></code> allows us to use <code>park</code> any time we want to
               mention Jenny. In fact, we already have, at <code><link
                     xlink:href="#attribute-licensor">@licensor</link></code>. The TAN function
               library is written so that any time <code>park</code> is mentioned in an attribute to
               associate it with the IRI + name pattern defined in <code><link
                     linkend="element-vocabulary-key">&lt;vocabulary-key></link></code>.</para>
            <para>There are a few other concepts put into <code><link
                     linkend="element-vocabulary-key">&lt;vocabulary-key></link></code>. <code><link
                     linkend="element-div-type">&lt;div-type></link></code> specifies an IRI + name
               pattern for line divisions, and the value of <code><link linkend="attribute-xmlid"
                     >@xml:id</link></code> means that we can use <code>line</code> any time we want
               to invoke the concept. Similarly we have a <code><link linkend="element-role"
                     >&lt;role></link></code>. The <code><link linkend="element-IRI"
                  >&lt;IRI></link></code> value of <code><link linkend="element-role"
                     >&lt;role></link></code> comes from the vocabulary of <link
                  xlink:href="http://schema.org">schema.org</link>, which is maintained by Bing,
               Google, and Yahoo! in conjunction with the W3C (the nonprofit organization dedicated
               to universal Internet standards), but we could have used Dublin Core or some other
               IRI vocabulary describing behaviors, responsibilities, and roles.</para>
            <para>After the <code><link linkend="element-vocabulary-key"
                  >&lt;vocabulary-key></link></code>, we get into parts of the file that specify who
               did what, when. First is a <code><link xlink:href="#element-file-resp"
                     >file-resp</link></code>, which specifies through <code>park</code> that Jenny
               Park is the one primarily responsible for the file. <code><link
                     linkend="element-resp">&lt;resp></link></code> specifies further who was
               responsible for doing what.<note>
                  <para>If you decide to modify someone else's TAN file, you are assuming
                     responsibility for changes. Your first point of order should be add a
                           <code><link linkend="element-person">&lt;person></link></code> to the
                     head, identifying yourself. You can then either add a <code><link
                           linkend="element-change">&lt;change></link></code> (see below) or a
                           <code><link linkend="element-resp">&lt;resp></link></code> (you might
                     need to specify a <code><link linkend="element-role">&lt;role></link></code> in
                     the <code><link linkend="element-vocabulary-key"
                        >&lt;vocabulary-key></link></code>). You need not change the document's
                           <code><link linkend="attribute-id">@id</link></code>, but you should take
                     responsibility for any changes you make, otherwise you are incorrectly
                     attributing your changes to someone else.</para>
               </note></para>
            <para>Remember that <code><link linkend="element-head">&lt;head></link></code> is
               focused on the data, not its sources, so the claim that Jenny Park is the creator
               pertains only to the data. No inference should be made about who was responsible for
               the source. If someone wants to know anything about the source, they should pursue
               the IRI identifier we have provided under <code><link linkend="element-source"
                     >&lt;source></link></code>.</para>
            <para><code><link linkend="element-change">&lt;change></link></code> has attributes
                     <code><link linkend="attribute-when">@when</link></code> and <code><link
                     linkend="attribute-who">@who</link></code> to specify who made the change and
               when. The value of <code><link linkend="attribute-when">@when</link></code> is always
               a date or a date + time, formatted according to the standard
                  <code>[YYYY]-[MM]-[DD]</code> or <code>[YYYY]-[MM]-[DD]T[HH]:[MM]:[SS]</code>.
                     <code><link linkend="attribute-who">@who</link></code> always carries a inref
               that points to a person or organization. <code><link linkend="element-change"
                     >&lt;change></link></code> does not take the IRI + name pattern, or even any
               children at all.</para>
            <para>So now we have finished one transcription file's metadata. The other one will look
               similar, but we'll take a couple of
               shortcuts:<programlisting>&lt;TAN-T xmlns="tag:textalign.net,2015:ns" TAN-version="2020" 
    id="tag:parkj@textalign.net,2015:ring02">
    &lt;head>
      &lt;name>TAN transcription of <emphasis role="bold">Ring around the Rosie</emphasis>&lt;/name>
      &lt;master-location>ring-o-roses.eng.<emphasis role="bold">1987.xml</emphasis>&lt;/master-location>
      &lt;license <emphasis role="bold">which="by 4.0"</emphasis> licensor="park"/>
      &lt;work>
         &lt;IRI>http://dbpedia.org/resource/Ring_a_Ring_o%27_Roses&lt;/IRI>
         &lt;name>Ring around the Rosie&lt;/name>
      &lt;/work>
      &lt;source>
         &lt;IRI><emphasis role="bold">http://lccn.loc.gov/87042504</emphasis>&lt;/IRI>
         &lt;name><emphasis role="bold">Mother Goose, from nursery to literature / by Gloria T. Delama, 1987.</emphasis>&lt;/name>
      &lt;/source>
      <emphasis role="bold">&lt;adjustments>
         &lt;normalization which="no hyphens"/>
      &lt;/adjustments></emphasis>
      &lt;vocabulary-key>
         <emphasis role="bold">&lt;div-type xml:id="l" which="line (verse)"/></emphasis>
         &lt;person xml:id="park" roles="creator">
            &lt;IRI>tag:parkj@textalign.net,2015:self&lt;/IRI>
            &lt;name xml:lang="eng">Jenny Park&lt;/name>
         &lt;/person>
      &lt;/vocabulary-key>
      &lt;resp roles="creator" who="park"/>
      &lt;change when="2014-10-24" who="park">Started file&lt;/change>
      <emphasis role="bold">&lt;comment when="2014-10-24" who="park">See p. 39 of source.&lt;/comment></emphasis>
      &lt;to-do/>
   &lt;/head>
   . . . . . .
&lt;/TAN-T></programlisting></para>
            <para>In this example, <code><link linkend="element-name">&lt;name></link></code>,
                     <code><link linkend="element-master-location"
                  >&lt;master-location></link></code>, and <code><link linkend="element-source"
                     >&lt;source></link></code> have been modified to describe this file. Note, we
               haven't had to change <code><link linkend="element-work"
               >&lt;work></link></code>.</para>
            <para><code><link linkend="element-license">&lt;license></link></code> looks different,
               but in reality it is identical to our previous example, and that is because the IRI +
               name pattern has been replaced with <link linkend="attribute-which"
                     ><code>@which</code></link>. You may replace any IRI + name pattern with <link
                  linkend="attribute-which"><code>@which</code></link>, whose value should match a
                     <code><link linkend="element-name">&lt;name></link></code> in customized or
               standard vocabulary (a TAN-voc file). In TAN's standard vocabulary for licenses (see
                  <xref xlink:href="#vocabularies-licenses"/>) is the following item:</para>
            <para>
               <programlisting>&lt;<emphasis role="bold">TAN-voc</emphasis> xmlns="tag:textalign.net,2015:ns" TAN-version="2020" 
   id="tag:textalign.net,2015:<emphasis role="bold">tan-voc:licenses</emphasis>">
    . . . . . . .
   &lt;body <emphasis role="bold">affects-element="license"</emphasis>>
      <emphasis role="bold">&lt;item>
         &lt;IRI>http://creativecommons.org/licenses/by/4.0/&lt;/IRI>
         &lt;IRI>tag:textalign.net,2015:license:by/4.0/&lt;/IRI>
         &lt;name>by 4.0&lt;/name>
         &lt;desc>attribution 4.0 international&lt;/desc>
      &lt;/item></emphasis>
    . . . . . . .
   &lt;/body>
&lt;/TAN-voc></programlisting>
            </para>
            <para>Because the validation rules for TAN-voc files require every <code><link
                     linkend="element-name">&lt;name></link></code> to be unique, that element can
               be treated as a unique identifier, similar to <code><link linkend="attribute-xmlid"
                     >@xml:id</link></code>. We could have repeated the <code><link
                     linkend="element-license">&lt;license></link></code> from the previous TAN-T
               file. But the <link linkend="attribute-which"><code>@which</code></link> method is so
               much quicker and cleaner, don't you think?</para>
            <para>Before <code><link linkend="element-vocabulary-key"
                  >&lt;vocabulary-key></link></code> comes a new element, <code><link
                     linkend="element-adjustments">&lt;adjustments></link></code>, which contains a
                     <code><link linkend="element-normalization">&lt;normalization></link></code>
               statement whose <link linkend="attribute-which"><code>@which</code></link> says
                  <code>no hyphens</code>. That too points to a standard TAN vocabulary for
               normalizations that provides an item with an IRI + name pattern for eliminating
               discretionary hyphens (see <xref xlink:href="#vocabularies-normalizations"/>):</para>
            <para>
               <programlisting>&lt;<emphasis role="bold">TAN-voc</emphasis> xmlns="tag:textalign.net,2015:ns" TAN-version="2020" id="tag:textalign.net,2015:<emphasis role="bold">tan-voc:normalizations</emphasis>">
    . . . . . . .
   &lt;body <emphasis role="bold">affects-element="normalization"</emphasis>>
      <emphasis role="bold">&lt;item>
         &lt;IRI>tag:textalign.net,2015:normalization:hyphens-discretionary-removed&lt;/IRI>
         &lt;name>no hyphens&lt;/name>
         &lt;desc>Discretionary word-break line-end hyphens have been deleted.&lt;/desc>
      &lt;/item></emphasis>
    . . . . . . .
   &lt;/body>
&lt;/TAN-voc></programlisting>
            </para>
            <para>As you might have inferred, the <code><link linkend="element-normalization"
                     >&lt;normalization></link></code> indicates an adjustment we have made to the
               data, namely, that we have opted to remove word-break line-end hyphenation. In other
               transcriptions we could use <code><link linkend="element-normalization"
                     >&lt;normalization></link></code> to declare other kinds of changes we felt
               compelled to make, such as removing editorial comments or footnote signals. A healthy
               list of <code><link linkend="element-normalization">&lt;normalization></link></code>s
               is a courtesy to users of our data, some of whom might passionately care about
               line-end hyphenation. </para>
            <para>Back to our example. <code><link linkend="element-div-type"
                  >&lt;div-type></link></code> has a new value for <code><link
                     linkend="attribute-xmlid">@xml:id</link></code>, the letter <code>l</code>, and
               in it too the IRI + name pattern has been replaced by <link linkend="attribute-which"
                     ><code>@which</code></link>, whose value, <code>line (poetry)</code>, is a
               standard vocabulary item (see <xref xlink:href="#vocabularies-div-types"/>.</para>
            <para>There is a also new <code><link linkend="element-comment"
                  >&lt;comment></link></code> element, which is built much the same as <code><link
                     linkend="element-change">&lt;change></link></code>.</para>
            <para>That seems all there is. But if you've been attentive, you will have noticed that
                     <code><link linkend="element-role">&lt;role></link></code> from our first TAN-T
               file (inside <code><link linkend="element-vocabulary-key"
                  >&lt;vocabulary-key></link></code>) is missing. That's because we don't need it,
               based on the same principle that lets us resolve <link linkend="attribute-which"
                     ><code>@which</code></link>. A vocabulary <code><link linkend="element-name"
                     >&lt;name></link></code> can be invoked not only in <link
                  linkend="attribute-which"><code>@which</code></link>, but in any attribute that
               points to values of <code><link linkend="attribute-xmlid">@xml:id</link></code>, in
               this case <code><link linkend="attribute-roles">@roles</link></code>. There is
               already a standard TAN vocabulary item with the <code><link linkend="element-name"
                     >&lt;name></link></code>
               <code>creator</code>, so we can use it directly without having to reassign the
               vocabulary item an <code><link linkend="attribute-xmlid">@xml:id</link></code>. If we
               had defined something else in <code><link linkend="element-vocabulary-key"
                     >&lt;vocabulary-key></link></code> with a <code><link linkend="attribute-xmlid"
                     >@xml:id</link></code> of <code>creator</code>, that item would take
               precedence. But we haven't, so the standard TAN vocabularies are our fallback.</para>
         </section>
         <section>
            <title>Building TAN Vocabulary</title>
            <para>The first TAN-T transcription had a longer <code><link linkend="element-head"
                     >&lt;head></link></code> than the second one did, and that is because we
               started with a more traditional method, that of specifying every IRI and name, and
               then adopted shortcuts that took advantage of TAN vocabulary. TAN vocabularies are
               meant not merely to be a convenience; they are intended to avoid problems that
               typically arise when you begin to create many files that repeat the same data. When
               (not if) you make changes to one file you have to remember where else you need to
               make the same changes. The old programmer's adage "Don't repeat yourself" (DRY) is
               operative here. As we create a cohesive TAN collection, we should do everything we
               can to avoid copying the same data, so that when we make changes, we have to do so
               only at a single point.</para>
            <para>The previous examples drew from standard TAN vocabulary, which is written in one
               of the other TAN formats, TAN-voc. We can write our own TAN-voc files, to collect the
               vocabulary items that we will repeatedly use from one file to the next. For
               example:</para>
            <para>
               <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;?xml-model href="../../schemas/<emphasis role="bold">TAN-voc.rnc</emphasis>" type="application/relax-ng-compact-syntax"?>
&lt;?xml-model href="../../schemas/<emphasis role="bold">TAN-voc.sch</emphasis>" type="application/xml" 
    schematypens="http://purl.oclc.org/dsdl/schematron"?>
&lt;TAN-voc xmlns="tag:textalign.net,2015:ns" TAN-version="2020" 
    id="tag:parkj@textalign.net,2015:<emphasis role="bold">TAN-voc:standard</emphasis>">
    &lt;head>
        <emphasis role="bold">&lt;name>Keywords for TAN files edited by Jenny Park&lt;/name></emphasis>
        &lt;license licensor="park" which="by 4.0"/>
        &lt;vocabulary-key>
            <emphasis role="bold">&lt;person which="Jenny Park" xml:id="park"/></emphasis>
        &lt;/vocabulary-key>
        &lt;file-resp who="park"/>
        &lt;resp roles="creator" who="park"/>
        &lt;change when="2019-10-08" who="park">Started file&lt;/change>
        &lt;to-do>
            <emphasis role="bold">&lt;comment when="2020-01-04" who="park">Need to check files for new vocabulary items.&lt;/comment></emphasis>
        &lt;/to-do>
    &lt;/head>
    &lt;body>
        <emphasis role="bold">&lt;group affects-element="person">
            &lt;item>
                &lt;IRI>tag:parkj@textalign.net,2015:self&lt;/IRI>
                &lt;name xml:lang="eng">Jenny Park&lt;/name>
            &lt;/item>
        &lt;/group></emphasis>
        <emphasis role="bold">&lt;item affects-element="work">
            &lt;IRI>http://dbpedia.org/resource/Ring_a_Ring_o%27_Roses&lt;/IRI>
            &lt;name>Ring a Ring o' Roses&lt;/name>
            &lt;name>Ring Around the Rosie&lt;/name>
        &lt;/item></emphasis>
    &lt;/body>
&lt;/TAN-voc></programlisting>
            </para>
            <para>In this example case, updates have been made to <code><link linkend="attribute-id"
                     >@id</link></code> and <code><link linkend="element-name"
                  >&lt;name></link></code>, and a <code><link linkend="element-comment"
                     >&lt;comment></link></code> has been added to <code><link xlink:href="#xml"
                     >&lt;to-do></link></code>. The most significant difference is the <code><link
                     linkend="element-body">&lt;body></link></code>, which has two <code><link
                     linkend="element-item">&lt;item&gt;</link></code>s, one of which is wrapped in
               a <code><link linkend="element-group">&lt;group></link></code>. Each <code><link
                     linkend="attribute-affects-element">@affects-element</link></code> specifies
               one or more names of elements that the enclosed items affect, and the <code><link
                     linkend="element-item">&lt;item&gt;</link></code>s have the standard IRI + name
               pattern. <code><link linkend="element-group">&lt;group></link></code>s may nest as
               you like.</para>
            <para>The <code><link linkend="element-vocabulary-key">&lt;vocabulary-key></link></code>
               has a <code><link linkend="element-person">&lt;person></link></code> whose <link
                  linkend="attribute-which"><code>@which</code></link> points to the body of the
               first <code><link linkend="element-item">&lt;item&gt;</link></code>. That is, a
               TAN-voc file may draw from its own vocabulary.</para>
            <para>Let's return to the <code><link linkend="element-head">&lt;head></link></code>s of
               our two TAN-T files, and let's see how to incorporate our new TAN-voc vocabulary
               file.</para>
            <para>
               <programlisting>&lt;TAN-T xmlns="tag:textalign.net,2015:ns" TAN-version="2020" 
    id="tag:parkj@textalign.net,2015:ring01">
    &lt;head>
        &lt;name>TAN transcription of Ring a Ring o' Roses&lt;/name>
        &lt;master-location 
            href="http://textalign.net/release/TAN-2020/examples/ring-o-roses.eng.1881.xml"/>
<emphasis role="bold">        &lt;license which="by 4.0" licensor="park"/>
        &lt;work which="Ring around the Rosie"/>
</emphasis>        &lt;source>
            &lt;IRI>http://lccn.loc.gov/12032709&lt;/IRI>
            &lt;name>Kate Greenaway, Mother Goose, New York, G. Routledge and sons [1881]&lt;/name>
        &lt;/source>
<emphasis role="bold">        &lt;vocabulary>
           &lt;IRI>tag:parkj@textalign.net,2015:TAN-voc:standard&lt;/IRI>
           &lt;name>Vocabulary for TAN files edited by Jenny Park&lt;/name>
           &lt;location href="TAN-voc/park-projects.TAN-voc.xml" accessed-when="2020-01-10"/>
        &lt;/vocabulary>
</emphasis>        &lt;vocabulary-key><emphasis role="bold">
            &lt;person xml:id="park" which="Jenny Park"/>
            &lt;div-type xml:id="line" which="line (verse)"/>
</emphasis>        &lt;/vocabulary-key>
        &lt;file-resp who="park"/>
        &lt;resp roles="creator" who="park"/>
        &lt;change when="2014-08-13" who="park">Started file&lt;/change>
        &lt;to-do/>
    &lt;/head>
    . . . . . . .
&lt;/TAN-T></programlisting>
            </para>
            <para>
               <programlisting>&lt;TAN-T xmlns="tag:textalign.net,2015:ns" TAN-version="2020" 
    id="tag:parkj@textalign.net,2015:ring02">
    &lt;head>
      &lt;name>TAN transcription of Ring around the Rosie&lt;/name>
      &lt;master-location>ring-o-roses.eng.1987.xml&lt;/master-location>
      &lt;license which="by 4.0" licensor="park"/>
      <emphasis role="bold">&lt;work which="Ring around the Rosie"/></emphasis>
      &lt;source>
         &lt;IRI>http://lccn.loc.gov/87042504&lt;/IRI>
         &lt;name>Mother Goose, from nursery to literature / by Gloria T. Delama, 1987.&lt;/name>
      &lt;/source>
      <emphasis role="bold">&lt;vocabulary>
         &lt;IRI>tag:parkj@textalign.net,2015:TAN-voc:standard&lt;/IRI>
         &lt;name>Vocabulary for TAN files edited by Jenny Park&lt;/name>
         &lt;location href="TAN-voc/park-projects.TAN-voc.xml" accessed-when="2020-01-10"/>
      &lt;/vocabulary></emphasis>
      &lt;adjustments>
         &lt;normalization which="no hyphens"/>
      &lt;/adjustments>
      &lt;vocabulary-key>
         <emphasis role="bold">&lt;div-type xml:id="l" which="line (verse)"/></emphasis>
         <emphasis role="bold">&lt;person xml:id="park" which="Jenny Park"/></emphasis>
      &lt;/vocabulary-key>
      &lt;resp roles="creator" who="park"/>
      &lt;change when="2014-10-24" who="park">Started file&lt;/change>
      &lt;comment when="2014-10-24" who="park">See p. 39 of source.&lt;/comment>
      &lt;to-do/>
   &lt;/head>
   . . . . . .
&lt;/TAN-T></programlisting>
            </para>
            <para>In each TAN-T file, a new <code><link linkend="element-vocabulary"
                     >&lt;vocabulary&gt;</link></code> points to the TAN-voc vocabulary file we have
               just created. Along with the customry IRI + name pattern is a new element,
                     <code><link linkend="element-location">&lt;location></link></code>, which
               specifies where the digital file was accessed and when (through <code><link
                     linkend="attribute-accessed-when">@accessed-when</link></code>). We may include
               as many of these <code><link linkend="element-location">&lt;location></link></code>
               elements as we wish, with the most preferred or reliable location at the top, since
               the validation process will use the first document that is available. The <code><link
                     linkend="attribute-accessed-when">@accessed-when</link></code> value is
               important, because the validator will look for changes in the file, and if there have
               been changes since we last accessed the file, it will return a warning with a summary
               of the changes since we last accessed the file. If such a report is returned, it is
               up to us to determine if the alterations merit any action on our part.</para>
            <para>Once the <code><link linkend="element-vocabulary">&lt;vocabulary&gt;</link></code>
               is in place, we can draw from our predefined vocabulary the same way we can draw from
               standard TAN vocabulary. Hence, these revised versions of the <code><link
                     linkend="element-head">&lt;head></link></code>s are a bit more compact and
               easier to read. The longer the TAN file, the more noticable the improvement. And when
               our library grows into dozens of files, we'll be grateful that changes need to be
               made at only a single point.</para>
            <para>Now that we have created the metadata for our transcriptions, let's turn to the
               alignment files. Those <code><link linkend="element-head">&lt;head></link></code>s
               will look slightly different. We start with the TAN-A
               file:<programlisting>&lt;TAN-A xmlns="tag:textalign.net,2015:ns" TAN-version="2020" 
    id="tag:parkj@textalign.net,2015:<emphasis role="bold">ring-alignment</emphasis>">
    &lt;head>
       &lt;name><emphasis role="bold">div-based alignment of multiple versions of Ring o Roses</emphasis>&lt;/name>
       &lt;master-location href="<emphasis role="bold">http://textalign.net/release/TAN-2020/examples/TAN-A/ringoroses.div.1.xml</emphasis>"/>
       &lt;license which="by_4.0" licensor="park"/>
       <emphasis role="bold">&lt;source xml:id="eng-uk">
          &lt;IRI>tag:parkj@textalign.net,2015:ring01&lt;/IRI>
          &lt;name>Transcription of ring around the roses in English (UK)&lt;/name>
          &lt;location href="../ring-o-roses.eng.1881.xml" accessed-when="2015-03-10"/>
       &lt;/source>
       &lt;source xml:id="eng-us">
          &lt;IRI>tag:parkj@textalign.net,2015:ring02&lt;/IRI>
          &lt;name>Transcription of ring around the roses in English (US)&lt;/name>
          &lt;location href="../ring-o-roses.eng.1987.xml" accessed-when="2014-08-13"/>
       &lt;/source></emphasis>
       &lt;vocabulary-key>
          &lt;person xml:id="park" which="Jenny Park"/>
       &lt;/vocabulary-key>
       &lt;resp who="park" roles="creator"/>
       &lt;change when="2014-08-14" who="park">Started file&lt;/change>
       &lt;to-do>
          &lt;comment when="2018-08-09-04:00" who="park">Finish file.&lt;/comment>
       &lt;/to-do>
    &lt;/head>
    . . . . . .
&lt;/TAN-A></programlisting></para>
            <para>Much of the code above will look similar to the previous two examples. The file's
                     <code><link linkend="element-name">&lt;name></link></code> and <code><link
                     linkend="element-master-location">&lt;master-location></link></code> are
               updated. Just like TAN-T files have <code><link linkend="element-source"
                     >&lt;source></link></code>s, so TAN-A files do as well, except that those
               sources are always TAN-T transcription files, and they take the IRI + name + location
               pattern we found above in <code><link linkend="element-vocabulary"
                     >&lt;vocabulary&gt;</link></code>. Because alignment files take only TAN
               transcription files as sources, each <code><link linkend="element-source"
                     >&lt;source></link></code>'s <code><link linkend="element-IRI"
                  >&lt;IRI></link></code> always takes the <code><link linkend="attribute-id"
                     >@id</link></code> value of the corresponding TAN transcription file.
                     <code><link linkend="element-name">&lt;name></link></code> is arbitrary. It may
               replicate exactly the title found in the transcription file, or it may be modified,
               perhaps to harmonize better with the descriptions of the other source names. Our
               TAN-A file could have any number of <code><link linkend="element-source"
                     >&lt;source></link></code>s, and not necessarily for the same work. The order
               we put the <code><link linkend="element-source">&lt;source></link></code>s does not
               necessarily mean anything. </para>
            <para>This <code><link linkend="element-head">&lt;head></link></code> explains why the
                     <code><link linkend="element-body">&lt;body></link></code> of our TAN-A file is
               allowed to be empty. We have already specified which sources are to be aligned and
               where they are to be found. Any user or processor of a TAN-A file may assume that
               every <code><link linkend="element-div">&lt;div></link></code> in every source should
               be automatically aligned upon the basis of shared values of <code><link
                     linkend="attribute-n">@n</link></code>.</para>
            <para>Meanwhile we turn to our fourth file, TAN-A-tok, whose <code><link
                     linkend="element-head">&lt;head></link></code> might look like
               this:<programlisting>&lt;TAN-A-tok xmlns="tag:textalign.net,2015:ns" id="tag:parkj@textalign.net,2015:TAN-A-tok,ring01+ring02">
    &lt;head>
        &lt;name><emphasis role="bold">token-based alignment of two versions of Ring o Roses</emphasis>&lt;/name>
        &lt;master-location href="<emphasis role="bold">http://textalign.net/release/TAN-2020/examples/TAN-A-tok/ringoroses.01+02.token.1.xml</emphasis>"/>
        &lt;license which="<emphasis role="bold">by-nc-nd_4.0</emphasis>" rights-holder="park"/>
        <emphasis role="bold">&lt;token-definition src="ring1881 ring1987" which="letters"/></emphasis>
        &lt;source xml:id="eng-uk">
            &lt;IRI>tag:parkj@textalign.net,2015:ring01&lt;/IRI>
            &lt;name>Transcription of ring around the roses in English (UK)&lt;/name>
            &lt;location href="../ring-o-roses.eng.1881.xml" accessed-when="2015-03-10"/>
        &lt;/source>
        &lt;source xml:id="eng-us">
            &lt;IRI>tag:parkj@textalign.net,2015:ring02&lt;/IRI>
            &lt;name>Transcription of ring around the roses in English (US)&lt;/name>
            &lt;location href="../ring-o-roses.eng.1987.xml" accessed-when="2014-08-13"/>
        &lt;/source>
        &lt;vocabulary-key>
            <emphasis role="bold">&lt;bitext-relation xml:id="B-descends-from-A" which="a/x+/b"/></emphasis>
            <emphasis role="bold">&lt;token-definition src="ring1881 ring1987" which="letters"/></emphasis>
            &lt;person xml:id="park" which="Jenny Park"/>
        &lt;/vocabulary-key>
        &lt;change when="2015-01-20" who="park">Started file&lt;/change>
    &lt;/head>
    . . . . . .
&lt;/TAN-A-tok></programlisting></para>
            <para>The TAN-A-tok <code><link linkend="element-head">&lt;head></link></code> looks
               similar to the previous examples, except that <code><link
                     linkend="element-vocabulary-key">&lt;vocabulary-key></link></code> has some new
               content.</para>
            <para><code><link linkend="element-bitext-relation">&lt;bitext-relation></link></code>
               states through <link linkend="attribute-which"><code>@which</code></link> or an IRI +
               name pattern the stemmatic relationship we think holds between the two sources.
               (Stemmatics is the study of the chain of transmission—the relationship of an original
               text-bearing object to the ones that survive. It frequently involves the creation of
               genealogical-like trees to illustrate the work's version history.) We have used <link
                  linkend="attribute-which"><code>@which</code></link> and the value
                  <code>a/x+/b</code>, pointing to a standard TAN vocabulary item for <link
                  xlink:href="#vocabularies-bitext-relations">bitext relations</link>:</para>
            <para>
               <programlisting>&lt;TAN-voc xmlns="tag:textalign.net,2015:ns" TAN-version="2020" 
   id="tag:textalign.net,2015:tan-voc:bitext-relation">
. . . . . .
        &lt;item>
            &lt;IRI>tag:textalign.net,2015:bitext-relation:a/x+/b&lt;/IRI>
            &lt;name>a/x+/b&lt;/name>
            &lt;desc>direct descent, B descends from A, one or more mediaries&lt;/desc>
        &lt;/item>
. . . . . .
&lt;/TAN-voc></programlisting>
            </para>
            <para><code><link linkend="element-token-definition">&lt;token-definition></link></code>
               specifies how we have defined our word tokens. <code><link linkend="attribute-src"
                     >@src</link></code> has more than one value, specifying that the same
               tokenization rule should be applied to both sources. <link linkend="attribute-which"
                     ><code>@which</code></link> points to this standard TAN vocabulary item:</para>
            <para>
               <programlisting>&lt;TAN-voc xmlns="tag:textalign.net,2015:ns" TAN-version="2020" 
   id="tag:textalign.net,2015:tan-voc:tokenizations">
. . . . . .
        &lt;item>
            <emphasis role="bold">&lt;token-definition pattern="[\w&amp;#xad;​&amp;#x200d;]+"/></emphasis>
            &lt;name>letters&lt;/name>
            &lt;name>letters only&lt;/name>
            &lt;name>general word characters only&lt;/name>
            &lt;name>general ignore punctuation&lt;/name>
            &lt;name>gwo&lt;/name>
            &lt;desc>General tokenization pattern for any language, words only. Non-letters 
                such as punctuation are ignored.&lt;/desc>
        &lt;/item>
. . . . . .
&lt;/TAN-voc></programlisting>
            </para>
            <para>To this point, all vocabulary items have taken the IRI + name pattern. This one
               does not have an IRI, only a <code><link linkend="element-token-definition"
                     >&lt;token-definition></link></code> with a <code><link
                     linkend="attribute-pattern">@pattern</link></code>. The value of <code><link
                     linkend="attribute-pattern">@pattern</link></code>, which may look strange, is
               a regular expression. This particular pattern says that a token is defined as any
               contiguous string of word characters (<code>\w</code>), soft hyphens
                  (<code>&amp;#xad;</code>), or zero-width joiners (<code>&amp;#x200d;</code>). This
               is the default tokenization pattern, and it will be assumed for any TAN-A-tok file
               that lacks a <code><link linkend="element-token-definition"
                     >&lt;token-definition></link></code>. This is because, whenever in ordinary
               conversation we refer to the nth word in a sentence, we most often skip punctuation
               marks. For more on this regulary expression see <xref
                  xlink:href="#regular_expressions"/>.</para>
            <para>In our <code><link linkend="element-vocabulary-key"
                  >&lt;vocabulary-key></link></code> we could have also included a <code><link
                     linkend="element-reuse-type">&lt;reuse-type></link></code>, be we have
               intentionally omitted it here, because we have this in the <code><link
                     linkend="element-body">&lt;body></link></code>: <code>&lt;body
                  bitext-relation="B-descends-from-A" reuse-type="general_adaptation"></code>. The
               value for <code><link linkend="attribute-reuse-type">@reuse-type</link></code>,
                  <code>general_adaptation</code>, corresponds to a <code><link
                     linkend="element-name">&lt;name></link></code> in a standard TAN vocabulary
               item for reuse types. We don't need to invoke a <code><link
                     linkend="element-reuse-type">&lt;reuse-type></link></code> in the <code><link
                     linkend="element-vocabulary-key">&lt;vocabulary-key></link></code> because we
               don't see the need here to coin an <code><link linkend="attribute-xmlid"
                     >@xml:id</link></code>.</para>
         </section>
         <section>
            <title>Aligning across Projects</title>
            <para>We now have a collection of five TAN files: two TAN-T transcriptions, a TAN-A
               alignment/annotation file, a TAN-A-tok word-for-word alignment file, and a TAN-voc
               file for vocabulary shared across the files. </para>
            <para>Let us imagine what it might be like to connect our TAN collection to another. Let
               us assume that we have found elsewhere, in a German project, a TAN transcription of a
               work that looks quite similar to our
               own:<programlisting>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;?xml-model href="http://textalign.net/release/TAN-2020/schemas/TAN-T.rnc" 
   type="application/relax-ng-compact-syntax"?>
&lt;?xml-model href="http://textalign.net/release/TAN-2020/schemas/TAN-T.sch" 
   type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
&lt;TAN-T xmlns="tag:textalign.net,2015:ns" id="tag:hans@beispiel.com,2014:ringel">
   &lt;head>
      &lt;name>TAN Transkription, Ringelreihen mit Riederfallen&lt;/name>
      &lt;master-location>http://beispiel.com/TAN-T/ringel.xml&lt;/master-location>
      &lt;license>
         &lt;IRI>http://creativecommons.org/licenses/by/4.0/&lt;/IRI>
         &lt;name>Creative Commons Namensnennung 4.0 International Lizenz&lt;/name>
         &lt;desc>Dieses Werk ist lizenziert unter einer Creative Commons Namensnennung 4.0
            International Lizenz.&lt;/desc>
      &lt;/license>
      &lt;licensor who="schmidt"/>
      &lt;work>
         &lt;IRI>tag:beispiel.com,2014:texte:holderbusch&lt;/IRI>
         &lt;name>"Die Kinder auf dem Holderbusch"&lt;/name>
      &lt;/work>
      &lt;version>
         &lt;IRI>urn:uuid:31648039-3dbb-49b9-b66e-9bd2cd11630e&lt;/IRI>
         &lt;name>zweite Version&lt;/name>
      &lt;/version>
      &lt;numerals priority="letters"/>
      &lt;source>
         &lt;IRI>http://www.worldcat.org/oclc/4574384&lt;/IRI>
         &lt;name>Franz Magnus Böhme, Deutsches Kinderlied und Kinderspiel: Volksüberlieferungen 
            aus allen Landen deutscher Zunge, gesammelt, geordnet und mit Angabe der Quellen. 
            Leipzig, 1897.&lt;/name>
      &lt;/source>
      &lt;adjustments>
         &lt;normalization>
            &lt;IRI>tag:kalvesmaki@gmail.com,2014:normalization:hyphens-discretionary-off&lt;/IRI>
            &lt;name>Keine Bindestriche&lt;/name>
         &lt;/normalization>
      &lt;/adjustments>
      &lt;vocabulary-key>
         &lt;div-type xml:id="Zeile">
            &lt;IRI>http://dbpedia.org/resource/Gedichtzeile&lt;/IRI>
            &lt;name>Gedichtzeile&lt;/name>
         &lt;/div-type>
         &lt;div-type which="poem" xml:id="Gedicht"/>
         &lt;person xml:id="schmidt" roles="Produzent">
            &lt;IRI>tag:hans@beispiel.com,2014:selbst&lt;/IRI>
            &lt;name xml:lang="eng">Hans Schmidt&lt;/name>
         &lt;/person>
         &lt;role xml:id="Produzent">
            &lt;IRI>http://schema.org/producer&lt;/IRI>
            &lt;name xml:lang="eng">Produzent&lt;/name>
         &lt;/role>
      &lt;/vocabulary-key>
      &lt;file-resp who="schmidt"/>
      &lt;resp who="schmidt" roles="Produzent"/>
      &lt;change when="2014-08-13" who="schmidt">Anfang&lt;/change>
      &lt;comment when="2014-08-13" who="schmidt">unten auf der Z. 438, recht&lt;/comment>
      &lt;to-do/>
   &lt;/head>
   &lt;body xml:lang="deu">
      &lt;div type="Gedicht" n="1">
         &lt;div type="Zeile" n="a">Ringel, Ringel, Reihe!&lt;/div>
         &lt;div type="Zeile" n="b">Sind der Kinder dreie,&lt;/div>
         &lt;div type="Zeile" n="c">Sitzen auf dem Holderbuch,&lt;/div>
         &lt;div type="Zeile" n="e">Schreien alle: husch, husch, husch!&lt;/div>
      &lt;/div>
   &lt;/body>
&lt;/TAN-T></programlisting></para>
            <para>It seems clear to us that this 19th-century German version is quite similar to our
               two English versions. We have some alignment options open to us. Two more sets of
               word-for-word alignments would be interesting, but remember, just because we find a
               text that nicely aligns with others does not mean that we <emphasis role="italic"
                  >must</emphasis> align them, or that for a given alignment we must align
                  <emphasis>everything</emphasis>. In this case, we choose not to worry about
               word-for word alignments, and we focus here only on the TAN-A alignment, so that, for
               example, we can later read the three versions in parallel to study more closely the
               relationships between them.</para>
            <para>To that end, we first observe some differences between this transcription and our
               other two. First, the value of <code><link linkend="element-work"
                  >&lt;work></link></code> is not the one we have given our two versions. Second, a
                     <code><link linkend="element-numerals">&lt;numerals></link></code> specifies by
               its value for <code><link linkend="attribute-priority">@priority</link></code> that
               any ambiguous numerals should be interepreted as letter numerals, not roman (that's
               important for a <link linkend="element-div"><code>&lt;div></code></link> below with
               an <code><link linkend="attribute-n">@n</link></code> value <code>c</code>, which
               could be interpreted to mean 3 or the Roman numeral 100). Next, the lines are wrapped
               in a <link linkend="element-div"><code>&lt;div></code></link> for the whole poem
                  (<code>Gedicht</code>) and they have been lettered instead of numbered. And last,
               the editor seems to have made a typographical error, making the last line
                  <code>e</code> instead of <code>d</code>). These five differences typify some of
               the inconsistencies that are commonly found in digital texts.<note>
                  <para>There are a few other differences in this third transcription that do not
                     affect our alignment. <code><link linkend="element-version"
                        >&lt;version></link></code> is used to distinguish different versions of the
                     same work found on the same text-bearing object. That is, if we are
                     transcribing a bilingual edition, we can use <code><link
                           linkend="element-version">&lt;version></link></code> to specify which of
                     the two versions we are encoding. Notice that the <code><link
                           linkend="element-IRI">&lt;IRI></link></code> value is a uuid. In this
                     case the editor was not prepared to deploy a formal IRI naming scheme (perhaps
                     using a tag URN) that would be satisfactory for work-versions. Also, the
                           <code><link linkend="element-div-type">&lt;div-type></link></code> is
                     defined as <code>http://dbpedia.org/resource/Gedichtzeile</code> (Gedichtzeile
                     = line of poetry), so it doesn't intersect with our IRI definitions of a line.
                     But <code><link linkend="element-div-type">&lt;div-type></link></code> is not
                     used to align versions. </para>
               </note></para>
            <para>These are points we can easily reconcile in our TAN-A file, which we now expand to
               include the German version. We make the following adjustments
               (emphasized):<programlisting>&lt;TAN-A xmlns="tag:textalign.net,2015:ns" TAN-version="2020" 
    id="tag:parkj@textalign.net,2015:ring-alignment">
    &lt;head>
       &lt;name>div-based alignment of multiple versions of Ring o Roses&lt;/name>
       &lt;master-location href="http://textalign.net/release/TAN-2020/examples/TAN-A/ringoroses.div.1.xml"/>
       &lt;license which="by_4.0" licensor="park"/>
       &lt;source xml:id="eng-uk">
          &lt;IRI>tag:parkj@textalign.net,2015:ring01&lt;/IRI>
          &lt;name>Transcription of ring around the roses in English (UK)&lt;/name>
          &lt;location href="../ring-o-roses.eng.1881.xml" accessed-when="2015-03-10"/>
       &lt;/source>
       &lt;source xml:id="eng-us">
          &lt;IRI>tag:parkj@textalign.net,2015:ring02&lt;/IRI>
          &lt;name>Transcription of ring around the roses in English (US)&lt;/name>
          &lt;location href="../ring-o-roses.eng.1987.xml" accessed-when="2014-08-13"/>
       &lt;/source>
       <emphasis role="bold">&lt;source xml:id="ger">
          &lt;IRI>tag:beispiel.com,2014:ringel&lt;/IRI>
          &lt;name>Transcription of an ancestor of Ring around the roses in German&lt;/name>
          &lt;location accessed-when="2014-08-22">http://beispiel.com/TAN-T/ringel.xml&lt;/location>
          &lt;location accessed-when="2014-08-22">../TAN-T/ring-o-roses.deu.1897.xml&lt;/location>
       &lt;/source>
       &lt;adjustments src="ger">
          &lt;skip div-type="Gedicht"/>
          &lt;rename n="e" by="-1"/>
       &lt;/adjustments></emphasis>
       &lt;vocabulary-key>
          &lt;person xml:id="park" which="Jenny Park"/>
          <emphasis role="bold">&lt;alias id="ring" idrefs="ger eng-us"/></emphasis>
       &lt;/vocabulary-key>
       &lt;resp who="park" roles="creator"/>
       &lt;change when="2014-08-14" who="park">Started file&lt;/change>
       <emphasis role="bold">&lt;change when="2014-08-22" who="park">Added German version.&lt;/change></emphasis>
       &lt;to-do>
          &lt;comment when="2018-08-09-04:00" who="park">Finish file.&lt;/comment>
       &lt;/to-do>
    &lt;/head>
    . . . . . .
&lt;/TAN-A></programlisting></para>
            <para>The first major change is the insertion of a third <code><link
                     linkend="element-source">&lt;source></link></code>, pointing to the new file
               and specifying its name and IRI. Note that two <code><link linkend="element-location"
                     >&lt;location></link></code>s have been provided, one for the original and
               another for a local copy we have saved. Validation will take into account only the
               first document available. If we wanted to work primarily off our local copy, we would
               have put that <code><link linkend="element-location">&lt;location></link></code>
               first. By placing it second, we allow the validation engine to look for updates and
               changes in the master version. If that version is unavailable, validation will be
               made against second, local copy.</para>
            <para>An <code><link linkend="element-adjustments">&lt;adjustments></link></code>
               specifies through its <code><link linkend="attribute-src">@src</link></code> that
               only the German version should be adjusted by the contained instructions. The
               enclosed <code><link linkend="element-skip">&lt;skip&gt;</link></code> says, in
               effect, to ignore the wrapping <link linkend="element-div"
                  ><code>&lt;div></code></link> for purposes of alignment. The <code><link
                     linkend="element-rename">&lt;rename></link></code> takes care of the apparent
               typographical error, and anchors the German version to the US one. Note that the
               German version uses <code>e</code>, but we have used <code>5</code>. But we could
               have used <code>e</code>, or even the Roman numeral <code>v</code>, had we wished to.
               Every TAN file's numeration system is evaluated locally, independent of any external
               files. We need not reconcile the <code>a</code>, <code>b</code>, and <code>c</code>
               <code><link linkend="attribute-n">@n</link></code> values in the German version,
               because these will be automatically treated as equivalent to <code>1</code>,
                  <code>2</code>, and <code>3</code>. The TAN format allows four numeration systems
               other than Arabic numerals: Roman numerals (uppercase or lowercase), alphabetic
               numerals (a, b, c, ..., z, aa, bb, ....), and digit-alphabet combinations (e.g., 1a,
               1e, 4g) or alphabet-digit combinations (e.g., a4, a5, b5). The last two systems are
               interpreted numerically.</para>
            <para>The second major change, to address the German version's different value of
                     <code><link linkend="element-work">&lt;work></link></code>, is the addition of
               an <code><link linkend="element-alias">&lt;alias></link></code>, which allows us to
               provide an id to multiple things. When we make claims in our TAN-A file about a works
               in general, <code>ring</code> can be used to asserting the claim to be true for the
               works defined in the German and the US version. (We do not need to specifically
               mention <code>eng-uk</code> in the <code><link linkend="element-alias"
                     >&lt;alias></link></code>, since it already shares a work IRI with the US
               version.) </para>
            <para>The last major insertion is a new <code><link linkend="element-change"
                     >&lt;change></link></code>, documenting when we made the alterations. The value
               of <code><link linkend="attribute-when">@when</link></code> effectively updates the
               version of our TAN-A file.</para>
            <para>With these additions, the German version is now aligned with the other two. We
               could have made our work simpler just by modifying the German version ourself. But
               such changes would have affected only our local copy, not the master one. What
               happens when the owner of the German file makes changes? At that point we would
               struggle to integrate the changes in our forked copy. And we would have to repeat
               that exercise every time the German file was updated. By keeping our local copy of
               the German file unchanged, and making simple adjustments in our TAN-A file, we can
               keep our local copy synchronized with the master file and yet make the adjustments we
               need to make it coordinate with ours.</para>
            <para>The purpose statement in these guidelines says that TAN was "designed to <emphasis
                  role="bold">maximize</emphasis> the syntactic and semantic interoperable alignment
               and exchange of texts, annotations, and language resources across projects." Here we
               see the importance of the qualifier "maximize." In no world will there ever be, nor
               should there be, a standard, canonical way to divide a given text. The TAN format
               does not change that reality. Rather, it provides an ecosystem in which
               idiosyncrasies in convergent practices can be reconciled, to help editors and authors
               achieve cross-project interoperability, without sacrificing genuine differences of
               opinion.</para>
            <para>Perhaps Hans Schmidt, the producer of the German version, can be contacted (maybe
               through his tag URN). We do so, and we suggest that he modify the version to make it
               align better. Perhaps he has reasons for labeling the lines with letters, and perhaps
               he is reluctant to explicitly identify this poem with <emphasis role="italic">Ring
                  around the Rosie</emphasis>. That is within his rights. But the conversation might
               lead to our pointing out that <code>n="e"</code> should probably be
                  <code>n="d"</code> and that there is an apparent typographic error in the last
               line. Or perhaps we're the ones in error. (The original, printed book has the poem
               twice on page 438, one with the spelling "Holderbuch" at line 3, the other,
               "Holderbusch".) If Schmidt chooses to correct his master file, he can add a new
                     <code><link linkend="element-change">&lt;change></link></code>, and thereby
               tacitly notify anyone else using the file that corrections have been made. Or</para>
            <para>At this point we have a network of five TAN files, four in our corpus and one from
               outside. Although simple, the network could be the basis for some creative and
               complex research questions. Applications based on XSLT stylesheets could be used to
               automatically align the versions for reading and study, or to perform statistical
               analysis. What you've read so far is only the tip of the iceburg. Study the rest of
               these guidelines, as well as example TAN libraries, and you will find numerous ways
               to use TAN files to enhance your research, teaching, and writing.</para>
         </section>
      </chapter>
   </part>
   <part xml:id="detailed_description">
      <title>Detailed Description</title>
      <partintro>
         <para>This part of the guidelines provides a detailed description of the design and
            structure of the formats of the Text Alignment Network. The material follows the
            organization of the schema files, so both can be read in tandem.</para>
         <para><xref linkend="concepts_common"/> outlines, in a non-technical way, the principles
            and technical foundations of the TAN format.</para>
         <para><xref linkend="class_common"/>, <xref linkend="class_1"/>, <xref linkend="class_2"/>,
            and <xref linkend="class_3"/> comprehensively describe all the TAN formats. Each chapter
            starts with theoretical or scholarly background, to provide a contextual explanation for
            the technical points that follow. </para>
         <para>The chapters in this part are meant to provide a narrative companion to the much more
            technical appendixes, <xref linkend="elements-attributes-and-patterns"/> and <xref
               linkend="vocabularies-master-list"/>, which are derived from the master schemas and
            vocabularies.</para>
         <para>The chapters in this part of the guidelines should be read selectively, not
            consecutively. They have been written with the assumption that you have already read the
            previous part (<xref linkend="general_overview"/>) and that you have already started to
            create and edit a TAN collection.</para>
         <para>Because readers will come from different specialties, all acronyms, abbreviations,
            and concepts are defined and explained, albeit tersely. Concepts or technologies are
            discussed only insofar as they affect the use of TAN; suggestions for further reading
            are provided for those who want a more thorough introduction to a topic. </para>
      </partintro>
      <chapter xml:id="concepts_common">
         <title>General Underpinnings</title>
         <para>This chapter retains something of the introductory spirit of the previous one by
            providing an overview of the fundamental principles and technologies behind TAN. The
            goal is to explain the principles behind the design of the format. Although this chapter
            assumes on your part no prior knowledge of any particular technology, it is also not
            meant to be a tutorial. Links to further reading will take you to good introductory
            material.</para>
         <section xml:id="design_principles">
            <title>Design Principles</title>
            <para>The TAN formats have been designed around a few basic design principles:</para>
            <para><emphasis role="bold">Scholarly habits</emphasis>
               <itemizedlist>
                  <listitem>
                     <para>Be patient.</para>
                  </listitem>
                  <listitem>
                     <para>Simplify.</para>
                  </listitem>
                  <listitem>
                     <para>Stay focused.</para>
                  </listitem>
                  <listitem>
                     <para>Avoid redundancy.</para>
                  </listitem>
                  <listitem>
                     <para>Don't state the obvious.</para>
                  </listitem>
                  <listitem>
                     <para>Use familiar conventions.</para>
                  </listitem>
               </itemizedlist></para>
            <para>
               <emphasis role="bold">Scholarly freedom</emphasis>
               <itemizedlist>
                  <listitem>
                     <para>Express doubt.</para>
                  </listitem>
                  <listitem>
                     <para>Offer alternatives.</para>
                  </listitem>
                  <listitem>
                     <para>Exercise independence.</para>
                  </listitem>
                  <listitem>
                     <para>Invite interdependence.</para>
                  </listitem>
               </itemizedlist></para>
            <para>
               <emphasis role="bold">Scholarly responsibility</emphasis>
               <itemizedlist>
                  <listitem>
                     <para>Declare your assumptions.</para>
                  </listitem>
                  <listitem>
                     <para>Make your work citable.</para>
                  </listitem>
                  <listitem>
                     <para>Satisfy scholars' expectations:</para>
                     <itemizedlist>
                        <listitem>
                           <para>Who did what when?</para>
                        </listitem>
                        <listitem>
                           <para>What are your sources?</para>
                        </listitem>
                        <listitem>
                           <para>How do you define your terms?</para>
                        </listitem>
                        <listitem>
                           <para>What alterations have you made to your sources?</para>
                        </listitem>
                        <listitem>
                           <para>What rights do I have to use your material?</para>
                        </listitem>
                     </itemizedlist>
                  </listitem>
               </itemizedlist>
               <emphasis role="bold">General utility</emphasis>
               <itemizedlist>
                  <listitem>
                     <para>Use stable technology.</para>
                  </listitem>
                  <listitem>
                     <para>Keep design predictable, consistent.</para>
                  </listitem>
                  <listitem>
                     <para>Make the data human readable.</para>
                  </listitem>
                  <listitem>
                     <para>Make the data computer actionable.</para>
                  </listitem>
               </itemizedlist>
            </para>
         </section>
         <section>
            <title>Format Organization</title>
            <para>The Text Alignment Network is a modular suite of XML encoding formats, each one
               designed for a specific type of textual data, divided into three classes:
               transcriptions (class 1), annotations and alignments of transcriptions (class 2), and
               everything else (class 3). </para>
            <para><emphasis role="bold">Class 1</emphasis>, representations of textual objects,
               consists solely of transcription files. (See <link
                  xlink:href="#transcription_and_transliteration">note on transcriptions versus
                  transliterations</link>.) Each transcription file contains the text of a single
               work from a single text-bearing object (which we term <emphasis>scriptum</emphasis>;
               see <xref xlink:href="#domain_model"/>), whether physical or digital. There are two
               types of transcription file: a standard generic format and a TEI customization. These
               two types are differentiated by the root element, <code><link linkend="element-TAN-T"
                     >&lt;TAN-T></link></code> and <code>&lt;TEI></code> respectively. </para>
            <para><emphasis role="bold">Class 2</emphasis>, annotations of class 1 files, are used
               to encode claims about texts, and to align them. There are two types of alignment,
               one for broad, general alignments and another for granular, word-for-word aligments.
               The former, with <code><link linkend="element-TAN-A">&lt;TAN-A></link></code> as the
               root element, aligns any number (one or more) of class 1 files, and allows a wide
               variety of claims about those files. The latter, <code><link
                     linkend="element-TAN-A-tok">&lt;TAN-A-tok></link></code>, aligns only pairs of
               class 1 files. Lexico-morphology files, <code><link linkend="element-TAN-A-lm"
                     >&lt;TAN-A-lm></link></code>, are used to encode the lexical and morphological
               (or part-of-speech) forms of individual words in a single class 1 file.</para>
            <para><emphasis role="bold">Class 3</emphasis>, covers everything else. <code><link
                     linkend="element-TAN-mor">&lt;TAN-mor></link></code> is used to define the
               grammatical categories or features of a given language and to specify rules for
               tagging words in a dependent TAN-A-lm file. <code><link linkend="element-TAN-voc"
                     >&lt;TAN-voc></link></code> collects and defines terms frequently used in other
               TAN files. TAN catalog files have the root element <code><link
                     linkend="element-collection">&lt;collection></link></code>, and they index of
               locally available TAN files, and selective parts of their metadata.</para>
            <para>This modular approach follows a model called <emphasis role="italic">stand-off
                  annotation</emphasis> (or <emphasis role="italic">stand-off markup</emphasis>), in
               contrast to <emphasis role="italic">inline annotation</emphasis>, in which a text and
               its annotations are placed in a single file. In inline annotation, one puts
               annotations directly into a transcription, e.g., <code>&lt;p>He said
                  &lt;quote>"Jump!"&lt;/quote>&lt;/p></code>, where the inner element is annotates
               the third word. (Most TEI and HTML files rely upon in-line annotation.) In stand-off
               annotation, <code>&lt;p>He said "Jump!"&lt;/p></code> would be left alone, and some
               othere element or file would signify that the third word is a quotation. If the
               stand-off annotation is in the same file, it is an <emphasis>internal stand-off
                  annotation</emphasis>. If the annotation is in a different file, it is an
                  <emphasis>external stand-off annotation</emphasis>.</para>
            <para>TAN adopts external stand-off annotation, which provides several benefits: <itemizedlist>
                  <listitem>
                     <para>An editor can work on a file with minimal distraction, focusing on a
                        limited set of closely related questions. </para>
                  </listitem>
                  <listitem>
                     <para>Editors can work on separate annotation files that point to the same
                        master transcription file, even if they have very different research
                        interests.</para>
                  </listitem>
                  <listitem>
                     <para>Complementary or competing annotations can be made, even in the same
                        file, and even if those annotations overlap (a major problem for in-line
                        annotation, where according to XML rules no element may interlock or overlap
                        with another).</para>
                  </listitem>
                  <listitem>
                     <para>A corpus of stand-off external annotation files become, collectively, a
                        complex dataset, supporting lines of research that might not have been
                        anticipated by any single project.</para>
                  </listitem>
                  <listitem>
                     <para>Editorial labor can be conducted without central coordination, as
                        individuals work at their own pace, independently, on separate files.</para>
                  </listitem>
                  <listitem>
                     <para>When errors are found, they can be corrected in the master transcription
                        file. In the TAN ecosystem, anyone dependent upon that master file as a
                        source will be notified of changes that have been made and they can deal
                        with them accordingly. For example, the editor of a master transcription
                        file can make typographical corrections, and if she logs the change with a
                        time-date stamp, anyone validating a dependent file will be notified about
                        the change. Similarly, that same editor links to a dependent stand-off
                        annotation file she will be notified of any changes.</para>
                  </listitem>
                  <listitem>
                     <para>Any data file can be updated independent of any other that points to it,
                        or to which it points.</para>
                  </listitem>
                  <listitem>
                     <para>Connected files can be combined and transformed in any number of ways to
                        produce a wide variety of derivative documents (e.g., collated versions,
                        statistical analysis).</para>
                  </listitem>
               </itemizedlist></para>
            <para>Stand-off annotation is not without problems and vulnerabilities. Files might be
               altered or altogether deleted, rendering dependent files meaningless. An editor may
               find that not having the annotated text in the same place as the annotation is an
               inconvenience. These are significant challenges, but TAN validation rules have been
               designed to mitigate such problems. </para>
         </section>
         <section>
            <title>Assumptions in the Creation of TAN Data</title>
            <para>All creators and users of TAN files are expected to share few basic
               assumptions.</para>
            <para>First, all TAN-compliant data is to be understood as largely
                  <emphasis>derivative</emphasis>. That is, data files have no originality or
               creativity independent of their sources (but see below about interpretation).
               TAN-compliant data is to be created with the intent of adhering as closely as
               possible to some model or archetype. For example, a transcription is assumed to
               replicate faithfully some earlier digital edition or text-bearing material object
               (e.g., stone, papyrus, manuscript, printed book for written text; audiovisual media
               for oral or performative texts). Morphological files and alignment files should
               describe as clearly and as reliably as possible their source transcriptions.
                  <emphasis>In creating and publishing a TAN file you claim to have offered a
                  good-faith representation or description of something; in using a TAN file, you
                  hold the creator to that expectation.</emphasis></para>
            <para>Second, all core TAN files are <emphasis>interpretive</emphasis>. That is, they
               are permeated by editorial assumptions and opinions that might not be shared by
               everyone. The only originality or creativity in a TAN file is in that interpretive
               outlook. For example, if you edit a transcription file you must decide how to handle
               unusual letterforms and other visible marks. Your decisions will be informed by how
               you view the original text and its native writing system, and how you interpret and
               use Unicode. If you write an alignment file, you must make decisions about what
               factors caused one text to be transformed into another. Lexicomorphological files
               require you to commit to one or more grammars and dictionaries, and you must discern
               how best to handle cases of vagueness and ambiguity. No TAN file ever stands
               completely outside the interpretive act. <emphasis>In creating and publishing a TAN
                  file you claim to have disclosed as best you can the assumptions behind your
                  interpretive outlook; in using a TAN file, you hold the creator to that
                  expectation.</emphasis></para>
            <para>Third, all core TAN files are <emphasis>useful</emphasis>. That is, the
               interpretive impluse is assumed to be coupled with an equally strong desire to make
               the data as useful to as many users as possible, even those who may not share your
               assumptions or interpretation. A creator of a transcription file, for example, should
               normalize and segment texts with a minimum of idiosyncracies, adopting the most
               widely used reference systems, so as to optimize the alignment process. Morphological
               files should depend whenever possible upon commonly accepted grammars and lexica.
               Alignment files should work with comprehensible categories of text reuse. No TAN file
               will always be useful to everyone, but it should be as useful to as many as possible,
               as often as possible. <emphasis>In creating a TAN file you claim to use common,
                  shared conventions whenever possible, and to note any departures; in using a TAN
                  file, you hold the creator to that expectation.</emphasis></para>
            <para xml:id="accuracy-precision-comprehensiveness">Fourth, TAN data is to be considered
                  <emphasis>accurate, but not necessarily precise or exhaustive</emphasis>. That is,
               the data should be correct, but it might include generalizations. For example, if one
               a TAN file claims that the opening of Plato's <emphasis>Republic</emphasis> book 3
               quotes from Homer's <emphasis>Iliad</emphasis>, the claim is true, but not very
               precise. There are parts of the opening of book 3 that are certainly not quotations,
               and there are parts of the <emphasis>Iliad</emphasis> not quoted in the
                  <emphasis>Republic</emphasis>. Or a claim in a TAN file might not include some
               data. A token-for-token alignment of two texts might be selective, and focus only on
               the points of interest to the editor. Although the TAN formats permit a great deal of
               both precision and comprehensiveness, it is not mandated. <emphasis>In creating a TAN
                  file you claim to make accurate assertions; in using a TAN file, you should hold
                  the creator to that expectation, but you should assess for yourself how precise
                  and comprehensive it is.</emphasis></para>
         </section>
         <section>
            <title>Core Technology</title>
            <para>TAN depends upon a set of relatively stable technologies. Those technologies and
               the underlying terminology are very briefly defined and explained below, with
               attention paid to interpretive decisions that affect validation rules. References to
               further reading will lead you to better and more thorough introductions elsewhere. </para>
            <section xml:id="unicode">
               <title>Unicode</title>
               <section>
                  <title>What is it?</title>
                  <para>Unicode is the worldwide standard for the consistent encoding,
                     representation, and exchange of digital texts. The standard is maintained by a
                     nonprofit consortium whose goal is to represent all the world's writing
                     systems, living and historical. The Unicode standard allows us to share texts
                     in any alphabet and reliably share that data with other people, independent of
                     individual fonts.</para>
                  <para>With more than 128,000 characters, Unicode is almost as complex as human
                     writing itself. The entire sequence of characters is divided into blocks, each
                     one reserved, more or less, for a particular alphabet or group of characters.
                     Within each block, characters may be grouped further. Each character is
                     assigned a single codepoint.</para>
                  <para>Codepoints are numbered according to the hexadecimal system (base 16), which
                     uses the digits 0 through 9 and the letters A through F. (The decimal number 10
                     is hexadecimal A; decimal 11 = hex B; decimal 17 = hex 10; decimal 79 = hex
                     4F.) It is helpful to think of Unicode as a very long table of sixteen columns,
                     a glyph in each square; this is illustrated nicely <link
                        xlink:href="http://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF"
                        >in this article</link>.</para>
                  <para>It is common to refer to Unicode characters by their value or their name.
                     The value customarily starts "U+" and continues with the hexadecimal value,
                     usually at least four digits. When the official Unicode name is given, it is
                     customary to put it in uppercase. Examples:</para>
                  <para>
                     <table frame="all">
                        <title>Unicode characters</title>
                        <tgroup cols="3">
                           <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                           <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                           <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                           <thead>
                              <row>
                                 <entry>Character</entry>
                                 <entry>Unicode value</entry>
                                 <entry>Unicode name</entry>
                              </row>
                           </thead>
                           <tbody>
                              <row>
                                 <entry>" " (space)</entry>
                                 <entry>U+0020</entry>
                                 <entry>SPACE</entry>
                              </row>
                              <row>
                                 <entry>®</entry>
                                 <entry>U+00AE</entry>
                                 <entry>REGISTERED SIGN</entry>
                              </row>
                              <row>
                                 <entry>ю</entry>
                                 <entry>U+044E</entry>
                                 <entry>CYRILLIC SMALL LETTER YU</entry>
                              </row>
                           </tbody>
                        </tgroup>
                     </table>
                  </para>
               </section>
               <section xml:id="normalization">
                  <title>Unicode Normalization</title>
                  <para>TAN validation rules require all data to be normalized according to the
                     Unicode NFC algorithm. Any text in a TAN file that is not NFC normalized will
                     be marked as invalid. </para>
               </section>
               <section xml:id="unicode-characters-with-special-interpretation">
                  <title>Unicode characters with special interpretation</title>
                  <para>The characters U+200D ZERO WIDTH JOINER and U+00AD SOFT HYPHEN placed at the
                     end of a leaf <link linkend="element-div"><code>&lt;div></code></link>, perhaps
                     followed by white space that will be ignored (see below), signal that the text
                     is to be joined with the text in the next leaf <link linkend="element-div"
                           ><code>&lt;div></code></link>. Accordingly, any TAN function that needs
                     to extract text from a <link linkend="element-div"><code>&lt;div></code></link>
                     structure will delete the U+200D or U+00AD character and its trailing space.
                     (By contrast, text from a leaf <link linkend="element-div"
                           ><code>&lt;div></code></link> that does not end this way will be
                     normalized such that it always ends in a single space.) Because these
                     characters are difficult to discern from spaces and hyphens, any output based
                     on the character mapping of the core functions should replace these characters
                     with their XML entities, <code>&amp;#x200d;</code> and
                     <code>&amp;#xad;</code>.</para>
                  <para>Much has been written about the different ways U+00AD SOFT HYPHEN has been
                     or should be interpreted. Debate will no doubt continue. TAN design adopts the
                     position that the soft hyphen marks a place in a word where a break has
                     occurred, or is allowed to occur. In situations where the text needs to be
                     printed or displayed, any soft hyphen that does not mark a word that needs to
                     be broken across lines should be suppressed.</para>
               </section>
               <section xml:id="combining_characters">
                  <title>Combining characters</title>
                  <para>At the core level of conformance, Unicode does not dictate whether combining
                     characters (accents, modifying symbols) should be counted independently or as
                     part of a base character, nor do core XML technologies. In most circumstances,
                     this point is negligible. But it can affect regular expressions and XPath
                     expressions (see below). </para>
                  <para>Two of the class 2 formats allow the counting of characters. Such counting
                     is assumed to be made exclusively of non-combining characters, defined as the
                     regular expression <code>[^\p{M}]</code>. Any numerical reference made in a TAN
                     file to an individual character will be found by counting only non-combining
                     characters. When the nth character is requested, TAN functions will return the
                     nth base character along with any combining characters that immediately follow. </para>
                  <para>TAN rules stipulate that combining characters must have a preceding base
                     character. Any <link linkend="element-div"><code>&lt;div></code></link> that
                     starts with a combining character will be marked as invalid. See also <xref
                        linkend="reg_exp_and_comb_chars"/>.</para>
               </section>
               <section xml:id="deprecated-unicode-points">
                  <title>Deprecated Unicode points</title>
                  <para>Because TAN files are not scriptum-oriented (see <xref
                        xlink:href="#domain_model"/>), the following characters will generate an
                     error if found in a TAN file:</para>
                  <para>
                     <itemizedlist>
                        <listitem>
                           <para>U+00A0 NO-BREAK SPACE</para>
                        </listitem>
                        <listitem>
                           <para>U+2000 EN QUAD</para>
                        </listitem>
                        <listitem>
                           <para>U+2001 EM QUAD</para>
                        </listitem>
                        <listitem>
                           <para>U+2002 EN SPACE</para>
                        </listitem>
                        <listitem>
                           <para>U+2003 EM SPACE</para>
                        </listitem>
                        <listitem>
                           <para>U+2004 THREE-PER-EM SPACE</para>
                        </listitem>
                        <listitem>
                           <para>U+2005 FOUR-PER-EM SPACE</para>
                        </listitem>
                        <listitem>
                           <para>U+2006 SIX-PER-EM SPACE</para>
                        </listitem>
                        <listitem>
                           <para>U+2007 FIGURE SPACE</para>
                        </listitem>
                        <listitem>
                           <para>U+2008 PUNCTUATION SPACE</para>
                        </listitem>
                        <listitem>
                           <para>U+2009 THIN SPACE</para>
                        </listitem>
                        <listitem>
                           <para>U+200A HAIR SPACE</para>
                        </listitem>
                     </itemizedlist>
                  </para>
               </section>
               <section>
                  <title>Further Reading</title>
                  <para>
                     <itemizedlist>
                        <listitem>
                           <para><link xlink:href="http://unicode.org">Unicode
                              Consortium</link></para>
                        </listitem>
                        <listitem>
                           <para><link xlink:href="http://en.wikipedia.org/wiki/Unicode"
                                 >Unicode</link> (Wikipedia)</para>
                        </listitem>
                     </itemizedlist>
                  </para>
               </section>
            </section>
            <section xml:id="xml">
               <title>eXtensible Markup Language (XML)</title>
               <section>
                  <title>What is it?</title>
                  <para>Defined by the W3C, the eXtensible Markup Language (XML) is a markup
                     language that that can be extended to allow anyone to define the structure and
                     rules of a document type. For quick, simple introduction to XML see <xref
                        linkend="gentle_guide"/>.</para>
               </section>
               <section>
                  <title>Schemas and validation</title>
                  <para>Validation files are found here: <code><link
                           xlink:href="http://textalign.net/release/TAN-2020/schemas/"
                           >http://textalign.net/release/TAN-2020/schemas/</link></code>.</para>
                  <para>Each TAN file is validated by two types of schema files, one dealing with
                     major rules concerning structure and data type, written in RELAX-NG, the other
                     with very detailed rules, written in Schematron.</para>
                  <para>The RELAX-NG rules are written initially in compact syntax
                        (<code>.rnc</code>), and then converted to the XML syntax
                     (<code>.rng</code>). For TAN-TEI, the special format One Document Does it all
                        (<code>.odd</code>) is used to alter the rules for TEI All.</para>
                  <para>The Schematron files are generally quite short. The primary work is done by
                     a substantial function library written in XSLT. For more on this process, see
                        <xref linkend="tan-stylesheets-and-function-library"/>.</para>
                  <para>Some validation engines that process a valid TAN-compliant TEI file may
                     return an error something like <code>conflicting ID-types for attribute "who"
                        of element "comment" from namespace "tag:textalign.net,2015:ns"</code>. Such
                     a message alerts you to the fact that by mixing TEI and TAN namespaces, you
                     open yourself up to the possibility of conflicting <code>xml:id</code> values.
                     It is your responsibility to ensure that you have not assigned duplicate
                     identifiers. Very often, it is possible for you to configure an XML editor to
                     ignore this discrepancy. (In oXygen XML editor go to Options > Preferences... >
                     XML > XML Parser > RELAX NG and uncheck the box ID/IDREF.)</para>
               </section>
               <section xml:id="whitespace">
                  <title>Space characters and normalization</title>
                  <para>By default in XML, unless otherwise specified, consecutive space characters
                     (space, tab, newline, and carriage return) are considered equivalent to a
                     single space. This gives editors the freedom they need to format XML documents
                     as they like, for either human readability or compactness. In XML, <emphasis
                        role="bold">space normalization</emphasis> is performed by stripping leading
                     and trailing whitespace and replacing sequences of one or more than one
                     whitespace character with a single space, <code>&amp;#x20;</code>. </para>
                  <para>All TAN formats assume space normalization, with an extra caveat, namely,
                     that some space is assumed to exist at the end of each leaf <code><link
                           linkend="element-div">&lt;div></link></code>s. This behavior is
                     overridden if the leaf <code><link linkend="element-div">&lt;div></link></code>
                     ends in the soft hyphen or the zero width joiner; see <xref
                        linkend="unicode-characters-with-special-interpretation"/>. </para>
                  <para>If retention of multiple spaces or spaces of specific sizes is important for
                     your research, then the TAN formats are not appropriate, since TAN is not
                     intended to replicate the appearance of a scriptum (see <xref
                        xlink:href="#domain_model"/>). Pure TEI (and not TAN-TEI) might be a
                     practical alternative, since it allows for a literal use of space, and supports
                     the creation of scriptum-oriented XML files.</para>
                  <para>For more on white space see <link
                        xlink:href="https://www.w3.org/TR/REC-xml/#sec-white-space">the W3C
                        recommendation</link>.</para>
               </section>
               <section>
                  <title>Non-mixed content</title>
                  <para>Many familiar text formats such as TEI, HTML, and Docbook allow what is
                     called mixed content—some elements permit a mixture of elements and nonspace
                     text as children. The TAN formats, aside from TAN-TEI, are committed to a
                     non-mixed content model. Nonspace text nodes and elements are never siblings.
                     The practical effect of this decision is that indentation may be applied to a
                     TAN file as one wishes, and whitespace text may be placed anywhere, without
                     affecting the meaning. </para>
               </section>
            </section>
            <section xml:id="namespace">
               <title>Namespaces</title>
               <section>
                  <title>What are they?</title>
                  <para>XML allow users to create document types in whatever way they want. One
                     person may wish to use the element <code>&lt;bank></code> to refer to financial
                     institutions; another might use this element to designate sides of rivers.
                     Perhaps someone wishes to mention both rivers and financial institutions in the
                     same document, which would entail mixing two very different types of
                        <code>&lt;bank></code>. XML was designed to allow users to mix vocabularies,
                     even when those vocabularies use synonymous element names. Disambiguation is
                     accomplished by associating a cohesive group of element names with an IRI (see
                        <xref linkend="IRIs_and_linked_data"/> below). The actual full name of an
                     element is the local name plus the IRI that qualifies its meaning, e.g.,
                        <code>bank{http://example1.com/terms/}</code> and
                        <code>bank{http://example2.com/terms/}</code>. </para>
                  <para>The relationship between the element name and the IRI is analogous to that
                     between a person's given name and their family name. The IRI—the family name—is
                     called the <emphasis>namespace</emphasis>. The term is at best vague and at
                     worst confusing, but at this point that cannot be helped. Think of the
                     namespace as the family name for a group of elements. </para>
                  <para>When namespaces are specified, they look a lot like attributes. (They
                     aren't.) They take the form <code>xmlns="http://example1.com/terms/"</code>
                     (defining the <emphasis role="bold">default namespace</emphasis>) or
                        <code>xmlns:[PREFIX]="http://example2.com/terms/"</code> (assigning a
                     namespace to a prefix) placed inside an opening tag. For example,
                        <code>&lt;bank xmlns="http://example1.com/terms/">...&lt;/bank></code>
                     states, in effect, the default namespace for <code>&lt;bank></code> and all
                     descendants, unless explicitly overridden. </para>
                  <para>Different types of <code>&lt;bank></code> can be mixed through
                     namespaces:</para>
                  <programlisting>&lt;bank xmlns="http://example1.com/terms/">
    &lt;bank xmlns="http://example2.com/terms/">
        ...
    &lt;/bank>
&lt;/bank>

&lt;bank xmlns="http://example1.com/terms/" xmlns:e2="http://example2.com/terms/">
    &lt;e2:bank >
        ...
    &lt;/e2:bank>
&lt;/bank>

&lt;e1:bank xmlns:e1="http://example1.com/terms/" xmlns:e2="http://example2.com/terms/">
    &lt;e2:bank >
        ...
    &lt;/e2:bank>
&lt;/e1:bank></programlisting>
               </section>
               <section>
                  <title>TAN namespace and prefix</title>
                  <para>The TAN namespace is <emphasis role="bold"
                           ><code>tag:textalign.net,2015:ns</code></emphasis>. The recommended
                     prefix is <emphasis role="bold"><code>tan</code></emphasis>. The namespace does
                     not change from one version of TAN to another.</para>
                  <para>The TAN-TEI format uses as its default the TEI namespace, <code><link
                           xlink:href="http://www.tei-c.org/ns/1.0"/></code>, normally given the
                     prefix <emphasis role="bold"><code>tei</code></emphasis>.</para>
               </section>
            </section>
            <section xml:id="TEI">
               <title>The Text Encoding Initiative</title>
               <section>
                  <title>What is it?</title>
                  <para>The Text Encoding Initiative (TEI; <link
                        xlink:href="http://www.tei-c.org/index.xml"/>) is a collection of XML rules
                     for the representation of texts in digital form. Developed and maintained by a
                     consortium of scholars and scholarly organizations, TEI includes not only a
                     library of schemas, but guidelines and stylesheets. The TEI Guidelines have
                     been widely used by libraries, museums, publishers, and individual scholars to
                     prepare and publish texts for online research, teaching, and preservation. In
                     addition to the Guidelines themselves, the Consortium provides a variety of
                        <link xlink:href="http://www.tei-c.org/Support/Learn/">resources</link> and
                        <link xlink:href="http://members.tei-c.org/Events">training events</link>
                     for learning TEI, information on <link
                        xlink:href="http://www.tei-c.org/Activities/Projects/">projects using the
                        TEI</link>, a <link
                        xlink:href="http://www.tei-c.org/Activities/SIG/Education/tei_bibliography.xml"
                        >bibliography of TEI-related publications</link>, and <link
                        xlink:href="http://www.tei-c.org/Tools/">software</link>.</para>
                  <para>TEI provided the impetus and continued inspiration for the development of
                     TAN. TEI was designed to be highly customizable, to suit the needs of
                     individuals or communities of practice. One of the TAN formats, TAN-TEI, is
                     such a customization, based as it is on an ODD file that is in the same
                     directory as the rest of the schemas. TAN-TEI schemas are generated on the
                     basis of the official TEI All schema that is available at the time of release. </para>
                  <para>TAN-TEI files and standard, out-of-the-box TEI All files are not
                     automatically interchangeable. TAN-TEI expects all metadata to be human- and
                     computer-readable, whereas TEI metadata is primarily only human-readable.
                     TAN-TEI tightly regulates the structure of the text, whereas TEI allows for a
                     variety of structures. Human intervention is required in any conversion
                     process, and there may be a loss of information in a conversion in either
                     direction.</para>
                  <para>For more about the strictures placed upon the TEI All schema see <xref
                        linkend="tan-tei"/>. See also <xref linkend="class_common"/> and <xref
                        linkend="class_1"/>.</para>
               </section>
               <section>
                  <title>Further reading</title>
                  <para>
                     <itemizedlist>
                        <listitem>
                           <para><link xlink:href="http://www.tei-c.org/">Text Encoding
                                 Initiative</link></para>
                        </listitem>
                     </itemizedlist>
                  </para>
               </section>
            </section>
            <section xml:id="data_types">
               <title>Data types</title>
               <para>Being written purely in XML technologies, TAN uses data types defined in the
                  W3C's <link xlink:href="https://www.w3.org/TR/xmlschema-2/">official
                     specifications</link>, e.g., strings, booleans, integers. The following data
                  types require some special comments.</para>
               <section xml:id="language">
                  <title>Languages</title>
                  <para>TAN adopts for language identification Best Common Practices (BCP) 47, which
                     standardizes identifies for languages and scripts. For most users of TAN, this
                     will be a simple two- or three-letter abbreviation, sometimes supplemented with
                     a hyphen and an abbreviation designating a script or regional subtag. For
                     example, <code>eng</code>, <code>eng-UK</code>, and <code>eng-UK-Cyrl</code>
                     refer, respectively, to English (in general), English from the United Kingdom,
                     and English from the United Kingdom written in the Cyrillic script. As a
                     general rule, values of this type should begin with a three-letter language
                     code, preferably lowercase.</para>
                  <para>ISO codes for human languages appear in <code><link
                           linkend="attribute-xmllang">@xml:lang</link></code> and <code><link
                           linkend="element-for-lang">&lt;for-lang></link></code>. The former states
                     what language the enclosed text is in. The second indicates that some statement
                     or claim is being made about a specific language language. For example,
                           <code><link linkend="element-for-lang">&lt;for-lang></link></code> in the
                     context of a TAN-mor file indicates which languages the file was written
                     for.</para>
                  <para>TAN has several global variables and functions useful for working with
                     language codes. See <xref xlink:href="#vkft-TAN-language"/>.</para>
                  <para>For more information, see one of the following:<itemizedlist>
                        <listitem>
                           <para>BCP 47 <link xlink:href="http://tools.ietf.org/rfc/bcp/bcp47"
                                 >official specifications</link></para>
                        </listitem>
                        <listitem>
                           <para>BPC 47 <link
                                 xlink:href="http://www.w3.org/TR/xmlschema11-2/#language">technical
                                 details</link></para>
                        </listitem>
                     </itemizedlist></para>
               </section>
               <section xml:id="date_and_datetime">
                  <title>Dates and times</title>
                  <para>TAN the ISO form of dates and date-times, as interpreted by XML data types.
                     These begin with years (the largest unit) and ends with days, seconds, or
                     fractions of seconds (the smallest).</para>
                  <para>The simplest date takes this form: <code>YYYY-MM-DD</code>. If a time is
                     included, it is specified by continuing the string, first with a <code>T</code>
                     (for time) then the form <code>hh:mm:ss.sss(Z|[-+]hh:mm)</code>. For example,
                     the following is <code>2016-09-20T20:38:27.141-04:00</code> is an ISO date-time
                     for Tuesday, September 20, 2016 at 8:38 p.m., Eastern Time Zone.</para>
                  <para>More reading:<itemizedlist>
                        <listitem>
                           <para><link xlink:href="https://www.w3.org/TR/xmlschema-2/#dateTime">W3C
                                 specification</link></para>
                        </listitem>
                        <listitem>
                           <para><link xlink:href="https://en.wikipedia.org/wiki/ISO_8601">Wikipedia
                                 entry on ISO 8601</link></para>
                        </listitem>
                     </itemizedlist></para>
               </section>
            </section>
            <section xml:id="IRIs_and_linked_data">
               <title>Identifiers and Their Use (IRIs, URIs, URLs, URNs, UUIDs)</title>
               <para>The acronyms for identifiers, and the meanings of those acronyms, can be
                  mystifying. Here is a synopsis:</para>
               <para>
                  <itemizedlist>
                     <listitem>
                        <para><emphasis>IRI</emphasis>: Internationalized Resource Identifier, a
                           generalization of the URI system, allowing the use of Unicode; <link
                              xlink:href="http://www.ietf.org/rfc/rfc3987.txt">defined by RFC
                              3987</link></para>
                     </listitem>
                     <listitem>
                        <para><emphasis>URI</emphasis>: Uniform Resource Identifier, a string of
                           characters used to identify a name or a resource; <link
                              xlink:href="https://tools.ietf.org/html/rfc3986">defined by RFC
                              3986</link></para>
                     </listitem>
                     <listitem>
                        <para><emphasis>URL</emphasis>: Uniform Resource Locator, a URI that
                           identifies a Web resource and the communication protocol for retrieving
                           the resource.</para>
                     </listitem>
                     <listitem>
                        <para><emphasis>URN</emphasis>: Uniform Resource Name, a term that
                           originally referred to persistent names that used a bare
                              <code>urn:</code> scheme, but is now applied to a variety of systems
                           that have registered with the IANA. URNs are generally best thought of as
                           a subset of URIs.</para>
                     </listitem>
                     <listitem>
                        <para><emphasis>UUID</emphasis>: Universally Unique Identifier, a
                           computer-generated 128-bit number used to assign identifiers to any
                           entity. UUIDs can be built into a URN by prefixing them with
                              <code>urn:</code>.</para>
                     </listitem>
                  </itemizedlist>
               </para>
               <para>The TAN format makes extensive use of all these. See also <xref
                     xlink:href="#tag_urn"/>.</para>
               <section xml:id="rdf_and_lod">
                  <title>Resource Description Framework (RDF) and Linked Open Data</title>
                  <section>
                     <title>What are they?</title>
                     <para>Identifiers are used in many contexts for many purposes. One such purpose
                        is called Linked Open Data (LOD) or the Semantic Web, which relies upon a
                        very simple data model called Resource Description Framework (RDF),
                        recommended by the World Wide Web Consortium (W3C). The term "Resource"—the
                        R in RDF—is a clumsy way to refer to any person, place, concept—anything at
                        all. "Description" is probably overly specific, too, since RDF was designed
                        to support general assertions, descriptive or not. Perhaps it should have
                        been called simply the Assertion Framework, but at this point it is too late
                        to change the name.</para>
                     <para>The RDF data model rests upon the concept of a statement, made of three
                        parts: subject, predicate, and object. Subjects and predicates take
                        identifiers that name things. The object may take an identifier or just
                        data. The idea behind LOD is that as people use the same URLs to identify
                        the same concepts, then independently created RDF datasets can be combined,
                        synthesized, and compared. RDF statements found across the web allow
                        inferences unforseen by anyone on a project level. </para>
                     <para>The Semantic Web recommends the use of URLs as identifiers. That way if a
                        computer encounters a URL naming a concept, it can go to the web resource
                        and find other RDF statements, and repeat the process. So the URL
                        identifiers look like a web page address (e.g., <code>http://...</code>),
                        but they are first and foremost names for things. Ideally, those URLs will
                        still name those things after the domain name expires and the web resource
                        cannot be found. </para>
                     <para>Although RDF statements must be made of only three components, it is
                        possible in a roundabout way to create more complex assertions. In one
                        technique, the assertion is given a URL, and then RDF statements are made
                        about the assertion. Such assertions are in some cases not easily integrated
                        with other RDF statements. In RDF searches, users who query a database for a
                        particular subject may not get a complex RDF statement that declares the
                        subject within the object of an RDF statement, without query preprocessing
                        that anticipates such situations.</para>
                  </section>
                  <section>
                     <title>TAN Claims and RDF</title>
                     <para>Much of TAN can be converted to RDF statements. In fact, TAN may be one
                        of the most human-friendly way to read and write RDF. For example, consider
                        how one might express "Person X's name is 'Dave Smith'." Compare this
                        snippet (taken from <link
                           xlink:href="http://linkeddatabook.com/editions/1.0/"/>), written in
                        Turtle syntax,
                        ...<programlisting>1 @prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#> . 
2 @prefix foaf: &lt;http://xmlns.com/foaf/0.1/> . 
3 
4 &lt;http://biglynx.co.uk/people/dave-smith> 
5 rdf:type foaf:Person ; 
6 foaf:name "Dave Smith" .</programlisting></para>
                     <para>...with the TAN
                        equivalent:<programlisting>&lt;person xml:id="dsmith">
   &lt;IRI>http://biglynx.co.uk/people/dave-smith&lt;/IRI>
   &lt;name>Dave Smith&lt;/name>
&lt;/person></programlisting></para>
                     <para>These TAN and RDF expressions are completely interchangeable. </para>
                     <para>But in more complex claims, it is, at this time, not clear whether all
                        assertions in TAN can be losslessly converted to the RDF model. This happens
                        most often in the context of <code><link linkend="element-claim"
                              >&lt;claim></link></code>, which is designed to allow scholarly
                        assertions and claims that are difficult or impossible to express in RDF.
                        For example, RDF does not allow one to say "Person X is not the author of
                        text Y," but TAN does. </para>
                     <para>TAN claims can also be quite complex. Whereas the default RDF claim
                        consists of three components—subject, predicate, object—most TAN claims have
                        more components, so conversion to RDF would require the building of complex
                        RDF statements (see previous section).</para>
                     <para>It is also not clear whether a TAN subject or object can always be
                        rendered in an acceptable IRI. Some subjects and objects will use the TAN
                        pointer system to refer to specific parts of texts, which rely upon a
                        context of XML files. It is our opinion that specific textual references are
                        too complex to be reduced to a IRI, because such an IRI would need to
                        include a mechanism to resolve the scriptum or source that is being used,
                        the type of reference system being used, the definition of token being used,
                        and other things. Further, many texts have alternative reference systems,
                        and there is always the chance that two competing systems would generate an
                        identical IRI for two different textual passages. This would break a
                        cardinal rule of IRIs. Although an entity may be given multiple IRIs, it is
                           <emphasis>never</emphasis> acceptable that an IRI be used to name
                        multiple entities, i.e., be ambiguous.</para>
                     <para>For more details see <xref linkend="TAN-A"/> and <code><link
                              linkend="element-claim">&lt;claim></link></code>.</para>
                  </section>
                  <section>
                     <title>Further reading</title>
                     <para>
                        <itemizedlist>
                           <listitem>
                              <para><link xlink:href="https://www.w3.org/RDF/">W3C
                                    recommendation</link></para>
                           </listitem>
                           <listitem>
                              <para><link xlink:href="http://linkeddata.org/">Linked
                                 Data</link></para>
                           </listitem>
                           <listitem>
                              <para><link xlink:href="http://lov.okfn.org/dataset/lov/">Linked Open
                                    Vocabularies</link></para>
                           </listitem>
                        </itemizedlist>
                     </para>
                  </section>
               </section>
               <section xml:id="tag_urn">
                  <title>Tag URNs</title>
                  <para>TAN files make extensive use of tag URNs (see <xref
                        xlink:href="#IRIs_and_linked_data"/>). In fact, TAN's namespace is a tag URN
                        (<xref linkend="namespace"/>). A <link xlink:href="http://www.taguri.org"
                        >tag URN</link> has two parts:</para>
                  <para>
                     <orderedlist>
                        <listitem>
                           <para><emphasis role="bold">Namespace.</emphasis>
                              <code>tag:</code> + an e-mail address or domain name owned by the
                              person or organization that has authorized the creation of the TAN
                              file + <code>,</code> + an arbitrary day on which that address or
                              domain name was owned + <code>:</code>. The day is expressed in the
                              form <code>YYYY-MM-DD</code>, <code>YYYY-MM</code>, or
                                 <code>YYYY</code>. A missing <code>MM</code> or <code>DD</code> is
                              implicitly assigned the value of <code>01</code>.</para>
                        </listitem>
                        <listitem>
                           <para><emphasis role="bold">Name of the TAN file.</emphasis> an arbitrary
                              string (unique to the namespace chosen) chosen by the namespace owner
                              as a label for the entire file and related versions. It need not be
                              the same as the filename stored on a local directory. You should pick
                              a name that is at least somewhat intelligible to human readers.</para>
                        </listitem>
                     </orderedlist>
                  </para>
                  <para>Although you may use any tag URN coined by someone else, you may create a
                     tag URN only if you are the owner of that URN's namespace.</para>
                  <para>Great care must be taken in choosing the name, because you are the sole
                     guarantor of its uniqueness. <emphasis role="italic">It is permissible for
                        something to have multiple identifiers, but never acceptable for an
                        identifier to name more than one thing.</emphasis> It is a good practice to
                     keep a master checklist of tag URNs you have created. If you find yourself
                     forgetting, or think you run the risk of creating duplicate tag URns, you
                     should start afresh by creating a new namespace for your tag URNs, easily done
                     just by changing the date in the tag URN namespace.</para>
                  <para>
                     <example>
                        <title>Tag URNs</title>
                        <programlisting>tag:jan@example.com,1999-01-31:TAN-T001
tag:example.com,2001-04:hamlet-tan-t
tag:evagriusponticus.net,2014:tan-a-lm:Evagrius_Praktikos_grc_Guillaumonts
tag:bbrb@example.org,1995-04-01:pos-grc</programlisting>
                        <para>The first example comes from someone who owned the email address
                              <code>jan@example.com</code> on January 31, 1999 (at the stroke of
                           midnight, Universal Coordinated Time). The other examples follow a
                           similar logic. The namespace of the second and third examples are tied to
                           the owners of specific domain names, not those of email addresses. The
                              <code>2014</code> in the third example is shorthand for the first
                           second of January 1, 2014.</para>
                     </example>
                  </para>
                  <para>The TAN encoding format prefers tag URNs over URLs for several
                     reasons:</para>
                  <para>
                     <itemizedlist>
                        <listitem>
                           <para><emphasis role="bold">Permanence.</emphasis> Authors of TAN data
                              are creating files that are meant to be relevant for decades and
                              centuries from now, well after specific domain names have changed
                              ownership or fallen into obsolesence, and well after the creators are
                              dead. URLs are not built for such permanence. </para>
                        </listitem>
                        <listitem>
                           <para><emphasis role="bold">Responsibility.</emphasis> The TAN format
                              requires every piece of data to be attributable to someone (a person,
                              organization, or some other agent). A tag URN connects the identifier
                              with the responsible person or organization. URLs cannot provide such
                              support.</para>
                        </listitem>
                        <listitem>
                           <para><emphasis role="bold">Accessibility.</emphasis> Tag URNs can be
                              made by anyone who has an email address. No one has to register with a
                              central authority. You can begin naming anything you want, any time
                              you want, without seeking anyone's approval, and without paying
                              anything.</para>
                        </listitem>
                        <listitem>
                           <para><emphasis role="bold">Ease</emphasis>. Tag URNs are easy to use.
                              Many potential TAN authors never have owned a domain name, and never
                              will. Further, many of those who do own domain names cannot or do not
                              wish to configure and maintain servers to administer the referral
                              mechanisms upon which the semantic web depends, as recommended by
                              Semantic Web advocates (see <xref xlink:href="#rdf_and_lod"/>).</para>
                        </listitem>
                        <listitem>
                           <para><emphasis role="bold">Scholarly citation norms</emphasis>. In the
                              design behind the Semantic Web, conflation of URL
                                 <emphasis>qua</emphasis> name with URL <emphasis>qua</emphasis>
                              location is considered a virtue because the single string does double
                              duty, both naming the resource and pointing to a location where more
                              can be learned. But this conflation is confusing (URLs are commonly
                              thought to be purely locations for data, not names for things) and
                              goes against an important norm of scholarly citation in bibliographies
                              and footnotes, i.e., that the name of a cited publication should
                              always be distinguished from where it might be found. </para>
                        </listitem>
                     </itemizedlist>
                  </para>
                  <para>Further reading:<itemizedlist>
                        <listitem>
                           <para><link xlink:href="https://tools.ietf.org/html/rfc4151">RFC
                                 4151</link>, the official definition of tag URNs</para>
                        </listitem>
                     </itemizedlist></para>
               </section>
            </section>
            <section xml:id="regular_expressions">
               <title>Regular Expressions</title>
               <para>Regular expressions are patterns for searching text. The term <emphasis
                     role="italic">regular</emphasis> here does not mean ordinary. Rather, it
                  derives from Latin <emphasis role="italic">regula</emphasis>, and points to a
                  rule-based way of finding and replacing text. Regular expressions come in
                  different flavors, and have several layers of complexity. TAN regular expressions
                  adhere closely to the <link
                     xlink:href="http://www.w3.org/TR/xslt-30/#regular-expressions">recommendation
                     of XSLT 3.0</link> (XML Schema Datatypes plus some extensions), and outlined in
                     <link xlink:href="http://www.w3.org/TR/xpath-functions-30/#regex-syntax">XPath
                     Fuctions 3.0</link>. <caution>
                     <para>XML Schema Datatypes define regular expressions differently than do Perl,
                        one of the most common forms of regular expression. For example, the pipe
                        symbol, |, is treated as a word character in XML regular expressions
                           (<code>\w</code>), but the opposite is true for Perl. For convenience,
                        here are the how codepoints U+0020..U+00FF are categorized according to XML
                        (and therefore TAN):</para>
                     <para><emphasis role="bold">Word characters </emphasis>(<code>\w</code>):
                           <code>$ + 0 1 2 3 4 5 6 7 8 9 &lt; = > A B C D E F G H I J K L M N O P Q
                           R S T U V W X Y Z ^ ` a b c d e f g h i j k l m n o p q r s t u v w x y z
                           | ~ ¢ £ ¤ ¥ ¦ ¨ © ª ¬ ® ¯ ° ± ² ³ ´ µ ¸ ¹ º ¼ ½ ¾ À Á Â Ã Ä Å Æ Ç È É Ê Ë
                           Ì Í Î Ï Ð Ñ Ò Ó Ô Õ Ö × Ø Ù Ú Û Ü Ý Þ ß à á â ã ä å æ ç è é ê ë ì í î ï ð
                           ñ ò ó ô õ ö ÷ ø ù ú û ü ý þ ÿ</code>
                     </para>
                     <para><emphasis role="bold">Non-word characters </emphasis>(<code>\W</code>):
                           <code>! " # % &amp; ' ( ) * , - . / : ; ? @ [ \ ] _ { } ¡ § « ­ ¶ · »
                           ¿</code></para>
                     <para>Some of these decisions about what is word-like and what isn't may seem
                        counterintuitive or wrong. But at this point it does not matter. The
                        distinction is a legacy that will endure. Just familiarize yourself with
                        decisions that are seemingly arbitrary.</para>
                  </caution></para>
               <para>A regular expression search pattern is treated just like a conventional search
                  pattern until the computer reaches a special escape character: <code>. [ ] \ | - ^
                     $ ? * + { } ( )</code>. Here is a brief key to how characters behave in regular
                  expressions, provided they are found outside of square brackets (on which see the
                  recommended reading below):</para>
               <para>
                  <table frame="all">
                     <title>Special characters in regular expressions</title>
                     <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1*"/>
                        <colspec colname="c2" colnum="2" colwidth="12.33*"/>
                        <thead>
                           <row>
                              <entry>Symbol</entry>
                              <entry>Meaning</entry>
                           </row>
                        </thead>
                        <tbody>
                           <row>
                              <entry><code>$</code></entry>
                              <entry>end of line</entry>
                           </row>
                           <row>
                              <entry><code>.</code></entry>
                              <entry>any character</entry>
                           </row>
                           <row>
                              <entry><code>|</code></entry>
                              <entry>or (union)</entry>
                           </row>
                           <row>
                              <entry><code>^</code></entry>
                              <entry>start of line</entry>
                           </row>
                           <row>
                              <entry><code>?</code></entry>
                              <entry>zero or one</entry>
                           </row>
                           <row>
                              <entry><code>*</code></entry>
                              <entry>zero or more</entry>
                           </row>
                           <row>
                              <entry><code>+</code></entry>
                              <entry>one or more</entry>
                           </row>
                           <row>
                              <entry><code>[ ]</code></entry>
                              <entry>a class of characters</entry>
                           </row>
                           <row>
                              <entry><code>( )</code></entry>
                              <entry>a group</entry>
                           </row>
                           <row>
                              <entry><code>\w</code></entry>
                              <entry>any word character</entry>
                           </row>
                           <row>
                              <entry><code>\W</code></entry>
                              <entry>any nonword character</entry>
                           </row>
                           <row>
                              <entry><code>\s</code></entry>
                              <entry>any of the four standard spacing characters: space (U+0020),
                                 tab (U+0009), newline (U+000A), carriage return (U+000D)</entry>
                           </row>
                           <row>
                              <entry><code>\S</code></entry>
                              <entry>anything not a spacing character</entry>
                           </row>
                           <row>
                              <entry><code>\d</code></entry>
                              <entry>any digit (0-9)</entry>
                           </row>
                           <row>
                              <entry><code>\D</code></entry>
                              <entry>anything not a digit</entry>
                           </row>
                           <row>
                              <entry><code>\p{IsGujarati}</code></entry>
                              <entry>any character from the Unicode block named Gujarati</entry>
                           </row>
                           <row>
                              <entry><code>^</code></entry>
                              <entry>beginning of a string (doesn't capture any characters)</entry>
                           </row>
                           <row>
                              <entry><code>$</code></entry>
                              <entry>end of a string (doesn't capture any characters)</entry>
                           </row>
                           <row>
                              <entry><code>\\</code></entry>
                              <entry>backslash</entry>
                           </row>
                           <row>
                              <entry><code>\^</code></entry>
                              <entry>a caret sign</entry>
                           </row>
                           <row>
                              <entry><code>\$</code></entry>
                              <entry>dollar sign</entry>
                           </row>
                           <row>
                              <entry><code>\(</code></entry>
                              <entry>opening parenthesis</entry>
                           </row>
                           <row>
                              <entry><code>\[</code></entry>
                              <entry>opening square bracket</entry>
                           </row>
                        </tbody>
                     </tgroup>
                  </table>
               </para>
               <para>Some examples:</para>
               <table frame="all">
                  <title>Examples of Regular Expressions</title>
                  <tgroup cols="3">
                     <colspec colname="newCol1" colnum="1" colwidth="1*"/>
                     <colspec colname="c1" colnum="2" colwidth="1.48*"/>
                     <colspec colname="c2" colnum="3" colwidth="6.59*"/>
                     <thead>
                        <row>
                           <entry>Expression</entry>
                           <entry>Meaning</entry>
                           <entry>What the expression matches when applied to "Wi-fi, good. A_hem*
                              isn't!"</entry>
                        </row>
                     </thead>
                     <tbody>
                        <row>
                           <entry><code>^.+$</code></entry>
                           <entry>one whole line of characters</entry>
                           <entry>"Wi-fi, good. A_hem* isn't!"</entry>
                        </row>
                        <row>
                           <entry><code>[ae]</code></entry>
                           <entry>a or e</entry>
                           <entry>"e"</entry>
                        </row>
                        <row>
                           <entry><code>[a-e]</code></entry>
                           <entry>a, b, c, d, or e</entry>
                           <entry>"d", "e"</entry>
                        </row>
                        <row>
                           <entry><code>[^ae]+</code></entry>
                           <entry>one or more characters that are anything except a or e</entry>
                           <entry>"Wi-fi, good. A_h", "m* isn't!"</entry>
                        </row>
                        <row>
                           <entry><code>.i</code></entry>
                           <entry>any character followed by i.</entry>
                           <entry>"Wi", "fi", " i"</entry>
                        </row>
                        <row>
                           <entry><code>(.i)</code></entry>
                           <entry>when a character followed by an i is found treat it as a capture
                              group (used only in a search pattern)</entry>
                           <entry>"Wi", "fi", " i"</entry>
                        </row>
                        <row>
                           <entry><code>[aeiou]\w*</code></entry>
                           <entry>any lowercase vowel along with every word character that
                              follows</entry>
                           <entry>"i", "i", "ood", "em", "isn"</entry>
                        </row>
                        <row>
                           <entry><code>[t*].</code></entry>
                           <entry>any t or * and the following character</entry>
                           <entry>"* ", "t!" Note that the asterisk, if inside a character class,
                              acts as itself.</entry>
                        </row>
                        <row>
                           <entry><code>\s+</code></entry>
                           <entry>match one or more space characters</entry>
                           <entry>" ", " ", " "</entry>
                        </row>
                        <row>
                           <entry><code>\w+</code></entry>
                           <entry>match one or more word characters</entry>
                           <entry>"Wi", "fi", "good", "A_hem", "isn", "t"</entry>
                        </row>
                        <row>
                           <entry><code>\W+</code></entry>
                           <entry>match one or more nonword characters</entry>
                           <entry>"-", ", ", ". ", "* ", "'", "!"</entry>
                        </row>
                        <row>
                           <entry><code>[^q]+</code></entry>
                           <entry>one or more characters that are not a q</entry>
                           <entry>"Wi-fi, good. A_hem* isn't!"</entry>
                        </row>
                     </tbody>
                  </tgroup>
               </table>
               <para>The examples above provide a taste of how regular expressions are constructed
                  and read.</para>
               <warning xml:id="reg_exp_and_comb_chars">
                  <title>Regular Expressions and Combining Characters</title>
                  <para>Regular expressions come in many different flavors, and each one deals with
                     some of the more complex issues in Unicode in their own manners. This ambiguity
                     will most keenly be felt in the use of combining characters. Suppose we have a
                     string of three characters, áb (i.e., an acute accent over the a,
                        <code>&amp;#x61;&amp;#x301;&amp;#x62;</code>). The regular expression
                        <code>a.</code> will in some search engines include the b and others
                     not.</para>
                  <para>Unicode has differentiated three levels of support for regular expressions
                     (see <link xlink:href="http://www.unicode.org/reports/tr18/">official
                        report</link>). Only level-one conformance in TAN is guaranteed. Combining
                     characters fall in level two. In TAN, character counts depend exclusively upon
                     base characters, not combining ones (see <xref linkend="combining_characters"
                     />).</para>
               </warning>
               <para>TAN includes several functions that usefully extend XML regular expressions.
                  See <xref xlink:href="#vkft-regex-ext-tan"/>.</para>
               <para>Further reading:<itemizedlist>
                     <listitem>
                        <para>Various <link
                              xlink:href="http://www.google.com/search?q=tutorial+regular+expressions"
                              >tutorials on Regular Expressions</link></para>
                     </listitem>
                     <listitem>
                        <para>Wikipedia, <link
                              xlink:href="http://en.wikipedia.org/wiki/Regular_expression">Regular
                              Expressions</link></para>
                     </listitem>
                     <listitem>
                        <para><link xlink:href="http://www.w3.org/TR/xslt-30/#regular-expressions"
                              >Regular Expressions in XSLT 3.0</link></para>
                     </listitem>
                     <listitem>
                        <para><link xlink:href="http://www.unicode.org/reports/tr18/">Unicode and
                              Regular Expressions</link></para>
                     </listitem>
                     <listitem>
                        <para><link xlink:href="http://www.w3.org/TR/xmlschema-2/#regexs">XML Schema
                              Datatypes</link></para>
                     </listitem>
                  </itemizedlist></para>
            </section>
         </section>
      </chapter>
      <chapter xml:id="class_common">
         <title>Patterns and Structures Common to All TAN Encoding Formats</title>
         <para>This chapter provides general background to the elements and attributes that are
            common to all TAN files. For detailed discussion of individual elements and attributes,
            see <xref linkend="elements-attributes-and-patterns"/>.</para>
         <para>This chapter does not discuss TAN catalog files, on which see <xref
               linkend="catalog-files"/>.</para>
         <section xml:id="patterns">
            <title>Common Patterns</title>
            <section xml:id="pattern-iri_and_name">
               <title>IRI + name Pattern</title>
               <para>Both humans and computers need to read and write TAN metadata. Very often what
                  is readable to humans is unreadable to computers, and vice versa. So the TAN
                  format requires that all metadata be provided whenever possible in both forms.
                  Although this rule may appear to introduce redundancy and therefore opportunities
                  for error, the clarity is critical. It is the only way at present to ensure that
                  any person or algorithm that approaches the data can parse and use it. In
                  addition, doubly expressed metadata provides a safeguard much like a checksum:
                  human- and computer-readable descriptions should correspond. A discrepancy signals
                  an apparent error that should be diagnosed and fixed.</para>
               <para>Some metadata, such as that inside <code><link linkend="element-comment"
                        >&lt;comment></link></code> or <code><link linkend="element-change"
                        >&lt;change></link></code>, are neither easily nor profitably translated
                  into a computer-actionable string. In such cases only the human-readable form is
                  required. Other metadata involve regular expressions (e.g., <code><link
                        linkend="attribute-pattern">@pattern</link></code>) or ISO-compliant dates
                  (e.g., <code><link linkend="attribute-when">@when</link></code>), both of which
                  are well formed and are usually human-legible. Such data are not repeated,
                  although they may be explained via <code><link linkend="element-desc"
                        >&lt;desc></link></code> or <code><link linkend="element-comment"
                        >&lt;comment></link></code>.</para>
               <para>Those exceptions aside, all other metadata takes what is called the <emphasis
                     role="italic">IRI + name</emphasis> pattern: one or more <code><link
                        linkend="namespace">&lt;IRI></link></code>s and <code><link
                        linkend="element-name">&lt;name></link></code>s and zero or more <code><link
                        linkend="element-desc">&lt;desc></link></code>s. If the thing being
                  described is a digital file, then the IRI + name pattern is expanded to the <xref
                     linkend="digital_entity_metadata"/>, to facilitate linking, among other
                  things.</para>
            </section>
            <section xml:id="digital_entity_metadata">
               <title>Digital Entity Metadata Pattern</title>
               <para>Some entities identified by the <xref linkend="pattern-iri_and_name"/> will be
                  digital resources. In those cases, the IRI + name Pattern is extended.</para>
               <para>There must be one or more <code><link linkend="element-location"
                        >&lt;location></link></code>s, with <code><link linkend="attribute-href"
                        >@href</link></code> and <code><link linkend="attribute-accessed-when"
                        >@accessed-when</link></code>, which signals where the resource is and when
                  it was last consulted. In validation, only the first document available will be
                  used. In other applications, beyond validation, any <code><link
                        linkend="attribute-href">@href</link></code> might be used.</para>
               <para>There may be an optional <code><link linkend="element-checksum"
                        >&lt;checksum></link></code>, to more accurately specify which version was
                  consulted.</para>
               <para>If the entity is a TAN file, then <code><link linkend="namespace"
                        >&lt;IRI></link></code> (one and only one) must be a valid tag URN that
                  matches the <code><link linkend="attribute-id">@id</link></code> value of the TAN
                  file being referred to. If the entity is not a TAN file, then any IRI may be used,
                  including its resolved URL.</para>
               <para>All these requirements may seem excessive, since in other contexts (HTML, TEI),
                  one needs only to supply a link via <code>@href</code> or <code>@src</code>. TAN
                  files are meant to be valid long after their creation, when they may be separated
                  from their original context, or when a server no longer has the files referred to.
                  An <code><link linkend="namespace">&lt;IRI></link></code> might allow one to find
                  a missing file. And <code><link linkend="attribute-accessed-when"
                        >@accessed-when</link></code> will allow users, in the validation process,
                  to see a list of recent changes to the file.</para>
            </section>
            <section xml:id="edit_stamp">
               <title>Edit Stamp</title>
               <para>Most TAN elements allow for an optional edit stamp, an <code><link
                        linkend="attribute-ed-who">@ed-who</link></code> and an <code><link
                        linkend="attribute-ed-when">@ed-when</link></code>, stating who created or
                  edited the enclosed data and when. Neither attribute is allowed without the other. </para>
               <para><code><link linkend="attribute-ed-when">@ed-when</link></code> is one of the
                  attributes that help determine a file's version. See <xref
                     xlink:href="#versioning-tan-files"/>.</para>
               <para>An edit stamp is much like a <code><link linkend="element-change"
                        >&lt;change></link></code> without a description, marking the element where
                  a change has been made. If a description of the alteration is necessary,
                        <code><link linkend="element-change">&lt;change></link></code> should be
                  used, perhaps in addition to the edit stamp.</para>
            </section>
         </section>
         <section xml:id="structure">
            <title>Overall Structure</title>
            <para>All TAN-compliant files, no matter the type or class, follow a common basic
               structure: (1) a prolog with at least two processing instruction nodes; (2) a root
               element; and (3) a head, a body, and an optional teiHeader and tail.</para>
            <para><emphasis role="italic">Prolog and processing instruction nodes</emphasis>: The
               standard prolog of every XML file should begin: <code>&lt;?xml version="1.0"
                  encoding="UTF-8"?></code> After that come two processing instructions specifying
               the two schema files required for validation<itemizedlist>
                  <listitem>
                     <para><code>&lt;?xml-model href="[PATH]/[ROOT-ELEMENT-NAME].rn[g OR
                           c]"?></code></para>
                  </listitem>
                  <listitem>
                     <para><code>&lt;?xml-model
                        href="[PATH]/[ROOT-ELEMENT-NAME].sch"?></code></para>
                  </listitem>
               </itemizedlist></para>
            <para>The first processing instruction node points to the RELAX-NG schema that declares
               the major, structural rules. The second points to the finely tuned rules, written in
               Schematron. Both processing instructions are required, unless in a system where those
               processing instructions are implied (e.g., an oXygen project or framework).
                  <code>[PATH]</code> represents the pathname to the schema file, whether local or
               on a server and <code>[ROOT-ELEMENT-NAME]</code> stands for the name of the file's
               root element (the element that is the ancestor of all other elements in the document
               and the descendant of none). It is your choice whether you use <code>.rnc</code> or
                  <code>.rng</code> as the extension for the RELAX-NG schema. The former is the
               compact syntax and the latter, the XML format. They are equivalent. The schemas are
               written initially in the compact sequence, then converted to the XML format.</para>
            <para>TAN files admit three different levels of validation: <code>terse</code>,
                  <code>normal</code>, and <code>verbose</code>. A phase may be specified with a
               pseudoattribute <code>phase</code> in the prolog, e.g., <code>&lt;?xml-model
                  href="TAN-A.sch" phase="verbose"?></code>. But it is customary not to specify the
               phase, since many users will want to change the level of validation according to the
               needs of the moment. Verbose takes the longest, and terse the shortest. Verbose
               provides the most feedback, terse the least. But some files will not show any
               difference in results from one phase to the next. For more on validation, see <xref
                  xlink:href="#validating_tan_files"/>.</para>
            <para><emphasis role="italic">Root element</emphasis>: The name of the root element
               identifies the type of TAN file:<table frame="all">
                  <title>Root TAN elements</title>
                  <tgroup cols="3">
                     <colspec colname="c1" colnum="1" colwidth="1.19*"/>
                     <colspec colname="c2" colnum="2" colwidth="1.19*"/>
                     <colspec colname="newCol3" colnum="3" colwidth="1*"/>
                     <thead>
                        <row>
                           <entry>Root element name</entry>
                           <entry>Type of data</entry>
                           <entry>TAN class</entry>
                        </row>
                     </thead>
                     <tbody>
                        <row>
                           <entry><code><link linkend="element-TAN-T"
                              >&lt;TAN-T></link></code></entry>
                           <entry>plain text transcriptions</entry>
                           <entry><link linkend="class_1">1</link></entry>
                        </row>
                        <row>
                           <entry><code>&lt;TEI></code></entry>
                           <entry>TEI transcriptions</entry>
                           <entry><link linkend="class_1">1</link></entry>
                        </row>
                        <row>
                           <entry><code><link linkend="element-TAN-A-tok"
                                 >&lt;TAN-A-tok></link></code></entry>
                           <entry>token-based alignments</entry>
                           <entry><link linkend="class_2">2</link></entry>
                        </row>
                        <row>
                           <entry><code><link linkend="element-TAN-A"
                              >&lt;TAN-A></link></code></entry>
                           <entry>division-based alignments</entry>
                           <entry><link linkend="class_2">2</link></entry>
                        </row>
                        <row>
                           <entry><code><link linkend="element-TAN-A-lm"
                              >&lt;TAN-A-lm></link></code></entry>
                           <entry>lexico-morphological analysis</entry>
                           <entry><link linkend="class_2">2</link></entry>
                        </row>
                        <row>
                           <entry><code><link linkend="element-TAN-mor"
                              >&lt;TAN-mor></link></code></entry>
                           <entry>part of speech / morphology patterns</entry>
                           <entry><link linkend="class_3">3</link></entry>
                        </row>
                        <row>
                           <entry><code><link linkend="element-TAN-voc"
                              >&lt;TAN-voc></link></code></entry>
                           <entry>glossaries</entry>
                           <entry><link linkend="class_3">3</link></entry>
                        </row>
                        <row>
                           <entry><code><link linkend="element-collection"
                                 >&lt;collection></link></code></entry>
                           <entry>catalog of TAN files</entry>
                           <entry><link linkend="class_3">3</link></entry>
                        </row>
                     </tbody>
                  </tgroup>
               </table><note>
                  <para><code><link linkend="element-collection">&lt;collection></link></code> is
                     provided here only to complete the table. None of the material in this chapter
                     applies to this special class 3 format. See <xref linkend="catalog-files"
                     />.</para>
               </note></para>
            <para>Each root element takes a mandatory <code><link linkend="attribute-id"
                  >@id</link></code> and <code><link linkend="attribute-TAN-version"
                     >@TAN-version</link></code>. On <code><link linkend="attribute-id"
                  >@id</link></code>, see below. <code><link linkend="attribute-TAN-version"
                     >@TAN-version</link></code> must be <code>2020</code>, the current version of
               TAN.</para>
            <para>All TAN elements take the namespace <code>tag:textalign.net,2015:ns</code>. In
               most cases, this value is placed in the root element. (The only exception are TAN-TEI
               transcription files, which take as a default namespace
                  <code>http://www.tei-c.org/ns/1.0</code> everywhere but in <code>/TEI/head</code>,
               which takes the TAN namespace.) For more about namespaces, see <xref
                  linkend="namespace"/>.</para>
            <para><emphasis>Root element children:</emphasis> Most root elements take two mandatory
               children: <code><link linkend="element-head">&lt;head></link></code> and <code><link
                     linkend="element-body">&lt;body></link></code>, the latter containing data and
               the former, metadata (data about the data). TAN-TEI files take three children:
                  <code>&lt;teiHeader></code>, <code><link linkend="element-head"
                  >&lt;head></link></code>, and <code>&lt;text></code>. The apparent duplication of
               a head element is because the <code>&lt;teiHeader></code> does not satisfy TAN
               metadata requirements. See <xref linkend="tan-tei"/>. </para>
            <para>All TAN files may take one final optional child, <link linkend="element-tail"
                     ><code>&lt;tail></code></link>, a private use element that allows any
               well-formed XML. It was introduced to facilitate methods in improving the efficiency
               of validation and applications. Nothing in a TAN file should be dependent upon the
                  <link linkend="element-tail"><code>&lt;tail></code></link>. That is, if you are
               editing a TAN file and you add a <link linkend="element-tail"
                  ><code>&lt;tail></code></link>, assume that it will be disregarded by other users.
               Similarly, you may delete any TAN file's <link linkend="element-tail"
                     ><code>&lt;tail></code></link> without consequence.</para>
            <section xml:id="tan-file-id">
               <title>Identifying TAN files: <code><link linkend="attribute-id"
                  >@id</link></code></title>
               <para>Every TAN file requires in its root element an <code><link
                        linkend="attribute-id">@id</link></code>, which must take the form of a tag
                  URN (see <xref linkend="tag_urn"/> for syntax). The file's <code><link
                        linkend="attribute-id">@id</link></code> is the primary way other TAN files
                  will refer to it, and it may be used in RDFa, JSON-LD, and linked open data (see
                     <xref linkend="IRIs_and_linked_data"/>).</para>
               <para>A tag URN begins with a namespace component, and concludes with the identifying
                  string. The namespace of <code><link linkend="attribute-id">@id</link></code> must
                  match at least one other tag URN namespace from the <code><link
                        linkend="element-IRI">&lt;IRI></link></code> of a <code><link
                        linkend="element-person">&lt;person></link></code> identified by <code><link
                        linkend="element-file-resp">&lt;file-resp&gt;</link></code>. This
                  requirement strengthens the declaration of responsibility. <code><link
                        linkend="element-person">&lt;person></link></code>s so identified are called
                  primary agents, and are bound to the global variable <code><link
                        linkend="variable-primary-agents">$primary-agents</link></code>.</para>
               <para>In choosing a value for <code><link linkend="attribute-id">@id</link></code>
                  you might borrow the filename, but you do not have to. Indeed, it is probably not
                  a good idea, since files are frequently renamed, often with good reason. A TAN
                  file's <code><link linkend="attribute-id">@id</link></code> should not be changed,
                  especially after publication, because the name should remain permanent and stable. </para>
               <para>On occasion during editing, it will become clear that revisions are so deep
                  that the file is altogether a different kind of thing. If a previous version has
                  been published, then coining a new <code><link linkend="attribute-id"
                     >@id</link></code>
                  <emphasis>is </emphasis>advised, to dissociate the file with its ancestry. You may
                  always document the connection by supplying <code><link
                        linkend="element-predecessor">&lt;predecessor&gt;</link></code>.</para>
               <para>If you take someone else's data and alter it then you should <emphasis
                     role="italic">not</emphasis> change the <code><link linkend="attribute-id"
                        >@id</link></code>, even the namespace. To avoid suggesting that the owner
                  of that namespace is responsible for any revisions you make to the file (if you
                  are allowed—see <code><link linkend="element-license"
                     >&lt;license&gt;</link></code>), you should add yourself as an <link
                     linkend="element-person"><code>&lt;person></code></link> and then document your
                  alterations through <link linkend="element-change"><code>&lt;change></code></link>
                  or <link linkend="attribute-ed-when"><code>@ed-when</code></link> and <link
                     linkend="attribute-ed-who"><code>@ed-who</code></link>. You should also
                  probably add a <code><link linkend="element-predecessor"
                        >&lt;predecessor&gt;</link></code> element, pointing to a version of the
                  file that predates your intervention.</para>
               <para>The <code><link linkend="attribute-id">@id</link></code> is the only
                  file-specific metadatum positioned outside <code><link linkend="element-head"
                        >&lt;head></link></code>. It is placed as rootward in the document as
                  possible to emphasize that it names the entire document.</para>
            </section>
            <section>
               <title xml:id="versioning-tan-files">Versioning TAN files</title>
               <para>The version of a TAN file is identified by the most recent date in a file's
                        <code><link linkend="attribute-when">@when</link></code>, <code><link
                        linkend="attribute-ed-when">@ed-when</link></code>, and <code><link
                        linkend="attribute-accessed-when">@accessed-when</link></code>. </para>
               <para>It is important, therefore, whenever you change a TAN file that has already
                  been published to provide at least an edit stamp (<xref linkend="edit_stamp"/>) in
                  the part of the file you changed or in a <code><link linkend="element-comment"
                        >&lt;comment></link></code> or <code><link linkend="element-change"
                        >&lt;change></link></code>, so that anyone validating a TAN file dependent
                  upon yours will be warned that changes have been made. The user may then either
                  continue to process the file (the changes may be minor or inconsequential) or
                  investigate the changes before deciding what to do. </para>
            </section>
         </section>
         <section xml:id="inheritable_attributes">
            <title>Attribute inheritability and priority</title>
            <para>Some attributes affect not merely their parent element but all their parent's
               descendents. This phenomenon is called <emphasis>inheritability</emphasis>.
                     <code><link linkend="attribute-xmlid">@xml:id</link></code> is noninheritable.
               But <code><link linkend="attribute-xmllang">@xml:lang</link></code>, <code><link
                     linkend="attribute-affects-element">@affects-element</link></code>, <code><link
                     linkend="attribute-claimant">@claimant</link></code>, and many others are
               inheritable. </para>
            <para>Most times, an inheritable attribute is canceled when that same attribute recurs
               in a descendant, e.g., the attributes just mentioned. But sometimes the inherited
               effect is cumulative, e.g., <code><link linkend="attribute-cert">@cert</link></code>.
               Read individual attribute definitions to understand their behavior.</para>
            <para>In some elements, multiple attributes must be assigned priority for
               interpretation. <code><link linkend="attribute-claimant">@claimant</link></code>, for
               example, has priority over <code><link linkend="attribute-cert">@cert</link></code>.
               That is, the two attributes in the same element are to be interpreted to mean:
                     "<code><link linkend="attribute-claimant">@claimant</link></code> has
                     <code><link linkend="attribute-cert">@cert</link></code> confidence about the
               following claim:...." (It does not mean that one is not certain whether the claimant
               made such-and-such a claim.)</para>
         </section>
         <section xml:id="defining_tokens">
            <title>Defining Words and Tokens</title>
            <para>At the heart of interaction between class 1 and class 2 files is the need to
               identify words. This poses a problem at the outset. The term <emphasis role="italic"
                  >word</emphasis> is notoriously difficult to define, no matter the language. In
               different contexts, for example, "New York" and "didn't" can each be justifiably
               taken to be one or two words. Furthermore, some scholars consider punctuation to be
               words (e.g., commas in modern prose, representing "and"), whereas others ignore them
               as being anachronistic or capricious (e.g., commas put by a medieval scribe or a
               modern scholar into ancient Greek and Latin texts). In the end, the number of
               meanings for "word" reflects the rich variety of scholarly disciplines.</para>
            <para>TAN follows the field of corpus linguistics and avoids <emphasis>word</emphasis>
               in favor of the proximate term <emphasis role="italic">token</emphasis>—a word that
               is defined not according to grammar but according to a regular expression (see <xref
                  linkend="regular_expressions"/>). </para>
            <para>A TAN token is a reference pointer, not a linguistic marker. To define a token in
               TAN does not entail any linguistic commitments. Neither editors nor users of TAN data
               should infer that a <link linkend="element-tok"><code>&lt;tok></code></link> points
               to a morpheme, a lexeme, or any other linguistic entity. There will frequently be a
               fortuitous correlation between the two, but it is not guaranteed. In TAN, a token is
               purely a method of reference.</para>
            <para>TAN was developed with a view to ancient literature, where punctuation is
               generally ignored as being late or not central to the text. Happily, even in
               contemporary use, most people ignore punctuation when they count words. Therefore the
               default <link linkend="element-token-definition"
                  ><code>&lt;token-definition></code></link> defines a token as being any continuous
               string of word characters, the soft hyphen, the zero-width space, or the zero-width
               joiner, formally defined by <xref xlink:href="#variable-token-definition-default"
               />:</para>
            <para>
               <programlisting>&lt;token-definition regex="[\w&amp;#xad;&amp;#x200b;&amp;#x200d;]+"/></programlisting>
            </para>
            <para>This pattern will result in a close resemblance to what is ordinarily thought of
               as words, but perhaps with some surprises (see above, <xref
                  linkend="regular_expressions"/>). If no <link linkend="element-token-definition"
                     ><code>&lt;token-definition></code></link> is explicitly given, the default
               pattern above will be used.</para>
            <para>If you are working with modern texts, where punctuation might be important to name
               and number, try the built-in keyword <code>letters and punctuation</code>:</para>
            <para>
               <programlisting>&lt;token-definition regex="[\w&amp;#xad;​&amp;#x200d;]+|[^\w&amp;#xad;​&amp;#x200d;\s]"/></programlisting>
            </para>
            <para>This expression defines a token as a sequence of word characters or any single
               character that is neither a word nor a space. The string "<code>(I go!)</code>" (the
               text inside the quotation marks) would have five tokens: <code>( I go !
               )</code>.</para>
            <para>For other standard TAN token definitons see <xref
                  xlink:href="#vocabularies-token-definitions"/><link
                  linkend="element-token-definition"><code>&lt;token-definition></code></link>s. You
               may customize your own <link linkend="element-token-definition"
                     ><code>&lt;token-definition></code></link> to suit your needs. But keep in mind
               that TAN files were meant to be shared across fields and disciplines. You are
               encouraged to to define tokens in manner customary to users of the text. Specialized
               definitions make it less likely that your TAN file will be able to mesh well with
               other TAN files. Two class-2 files annotating the same class-1 file cannot be easily
               compared or synthesized if they use different token definitions.</para>
         </section>
         <section xml:id="metadata_head">
            <title>Metadata (<code><link linkend="element-head">&lt;head></link></code>)</title>
            <para>No matter how much one TAN format differs from another, the metadata are quite
               similar. Anyone getting a TAN file, no matter its class or type, is assumed to want
               to know, and therefore find easily and predictably, the following:<orderedlist>
                  <listitem>
                     <para>the stable name of the file;</para>
                  </listitem>
                  <listitem>
                     <para>its version;</para>
                  </listitem>
                  <listitem>
                     <para>its sources;</para>
                  </listitem>
                  <listitem>
                     <para>other files upon which it depends or otherwise have an important
                        relationship;</para>
                  </listitem>
                  <listitem>
                     <para>the most significant parts of the editorial history;</para>
                  </listitem>
                  <listitem>
                     <para>the linguistic or scholarly conventions that have been adopted in
                        creating and editing the data;</para>
                  </listitem>
                  <listitem>
                     <para>the license, i.e., who holds what rights to the data, and what kind of
                        reuse is allowed.</para>
                  </listitem>
                  <listitem>
                     <para>the persons, organizations, or entities that helped create the data, and
                        the roles played by each.</para>
                  </listitem>
               </orderedlist></para>
            <para>To answer these questions completely, consistently, and predictably the
                     <code><link linkend="element-head">&lt;head></link></code>, a mandatory child
               of the root element, takes a common pattern across <emphasis>all</emphasis> TAN
               formats, thus allowing anyone to easily and predictably work across large numbers and
               types of TAN files. The TAN <code><link linkend="element-head"
                  >&lt;head></link></code>, intended to be concise and focused, compels you to
               provide metadata for the data that is governed by <code><link linkend="element-body"
                     >&lt;body></link></code>, but it does not accommodate metadata for the
               metadata. That is, your metadata should focus on the data itself and not other
               things. For example, <code><link linkend="element-head">&lt;head></link></code>
               requires you name the people who helped create or edit the data, but you are not
               expected to tell us about them. Merely give good <code><link linkend="element-IRI"
                     >&lt;IRI></link></code>s to point to authoritative sources that provide
               background information.<note>
                  <para>The principles above explain why the TEI extension of TAN requires two
                     heads, one for TEI and the other for TAN. <code>&lt;teiHeader></code> is
                     impossible to map onto a TAN <code><link linkend="element-head"
                           >&lt;head></link></code>. But that <code>&lt;teiHeader></code> has
                     valuable, sometimes critically important, information, and should be retained,
                     or replaced with a valid but empty skeleton.</para>
               </note></para>
            <para>Detailed descriptions of <code><link linkend="element-head"
                  >&lt;head></link></code> and its components are in <xref
                  linkend="elements-attributes-and-patterns"/>. Here we provide a summary, general
               description of the TAN <code><link linkend="element-head">&lt;head></link></code> and
               its general structure.</para>
            <section>
               <title>Key information</title>
               <para>Key information about the file as a whole is the first section of a <code><link
                        linkend="element-head">&lt;head></link></code>. This includes <code><link
                        linkend="element-name">&lt;name></link></code>, perhaps one or more
                        <code><link linkend="element-desc">&lt;desc></link></code>s, and perhaps one
                  or more <code><link linkend="element-master-location"
                     >&lt;master-location></link></code>s, which points to a location where an
                  authoritative version of the file can be found. <code><link
                        linkend="element-master-location">&lt;master-location></link></code> is
                  optional, but not if <code><link linkend="element-to-do"
                     >&lt;to-do&gt;</link></code> is empty (see below).</para>
            </section>
            <section xml:id="license">
               <title>File declarations</title>
               <para>Each <code><link linkend="element-head">&lt;head></link></code> in a TAN file
                  has a declaration section, pertaining to use of the file: <code><link
                        linkend="element-license">&lt;license></link></code> and <code><link
                        linkend="element-numerals">&lt;numerals&gt;</link></code>.</para>
               <para><code><link linkend="element-license">&lt;license></link></code> stipulates the
                  license(s) under which the persons listed in its <code><link
                        linkend="attribute-licensor">@licensor</link></code> are releasing the data.
                     <emphasis role="bold">The license applies only to the file itself, not to its
                     sources.</emphasis> The distinction is important, and helpful. It is much
                  easier for you to decide and state the rights and license behind your own work
                  than to do so for that of others. Declaring who holds what rights over your
                  source(s) may be not only difficult but risky, and is therefore optional, best
                  handled in a <code><link linkend="element-desc">&lt;desc&gt;</link></code> or
                        <code><link linkend="element-comment">&lt;comment></link></code>.</para>
               <para>When using a TAN file, you should investigate the entire chain of rights. If
                  you find a discrepancy between the license of a TAN file and that of its sources
                  you should respect the more restrictive one. If a TAN file has a very liberal,
                  open license for the data, this does not necessarily mean that the material upon
                  which it depends is equally open. The TAN file's source may be under tight
                  restrictions.</para>
               <para>TAN adopts the Creative Commons licenses as its default license vocabulary. See
                     <xref linkend="vocabularies-licenses"/>.</para>
               <para><code><link linkend="element-numerals">&lt;numerals&gt;</link></code> may be
                  used to declare whether alphabetic numerals or Roman numerals prevail in cases of
                  ambiguity. See the entry for <code><link linkend="element-numerals"
                        >&lt;numerals&gt;</link></code> as well as the <link
                     xlink:href="#numeration-systems">section on numeration systems</link>.</para>
               <para>Many TAN files allow in this section <code><link
                        linkend="element-token-definition">&lt;token-definition></link></code>,
                  which specifies a definition for tokens, perhaps qualified by in a class-2 file by
                        <code><link linkend="attribute-src">@src</link></code>. See <xref
                     xlink:href="#defining_tokens"/> and the definition for <code><link
                        linkend="element-token-definition"
                  >&lt;token-definition></link></code>.</para>
            </section>
            <section xml:id="inclusions-and-vocabularies">
               <title>Networked Files: Vocabularies and Inclusions</title>
               <para>The third major section of <code><link linkend="element-head"
                     >&lt;head></link></code> accommodates networked files. The two most critical
                  elements are <code><link linkend="element-inclusion">&lt;inclusion></link></code>
                  and <code><link linkend="element-vocabulary">&lt;vocabulary></link></code>, which
                  should be considered constituent parts of a TAN file.</para>
               <para>Many if not most TAN files are created alongside or in the context of a
                  project, where certain data patterns are repeated. Explicit repetition from one
                  file to the next makes them prone to error. Changes might be made in one file but
                  not in another, introducing version conflicts. <code><link
                        linkend="element-inclusion">&lt;inclusion></link></code> and <code><link
                        linkend="element-vocabulary">&lt;vocabulary></link></code> provide a
                  specialized method of inclusion that reduces duplication, increases the likelihood
                  of global changes being applied consistently, and leads to cleaner, smaller
                  files.</para>
               <para>In general, you should first try using <code><link linkend="element-vocabulary"
                        >&lt;vocabulary></link></code>. If they are not doing the job you need, then
                  try <code><link linkend="element-inclusion">&lt;inclusion></link></code>.</para>
               <section>
                  <title>Vocabularies</title>
                  <para>Most often, an editor wants a simple, shorthand reference to an entity
                     commonly referred to from one file to the next in a single project, e.g., the
                     person who is the principle editor, roles, and division types. </para>
                  <para>Projects are advised to create their own <code><link
                           linkend="element-TAN-voc">&lt;TAN-voc&gt;</link></code> files populated
                     with commonly used vocabulary. Once set up, the TAN-voc file must be linked to
                     via a <code><link linkend="element-vocabulary">&lt;vocabulary></link></code> in
                     the <code><link linkend="element-head">&lt;head></link></code> of other TAN
                     files. Vocabulary items then are invoked by any value of <code><link
                           linkend="element-name">&lt;name&gt;</link></code>. Variations in
                     capitalization are fine, and hyphens, spaces, and underscores are
                     interchangeable. In the host file, any attribute that takes multiple idrefs,
                     e.g., <code><link linkend="attribute-who">@who</link></code>, <code><link
                           linkend="attribute-type">@type</link></code>, <code><link
                           linkend="attribute-subject">@subject</link></code>, may take a vocabulary
                     item <code><link linkend="element-name">&lt;name&gt;</link></code>, but spaces
                     must be replaced with the underscore, _, because spaces are used to delimit
                     multiple values. A <link linkend="attribute-which"><code>@which</code></link>
                     in the host file, however, can take no more than one value, so spaces are fine.
                     Many times, vocabulary names are used in <code><link
                           linkend="element-vocabulary-key">&lt;vocabulary-key&gt;</link></code>,
                     where the vocabulary items can be assigned a <code><link
                           linkend="attribute-xmlid">@xml:id</link></code> that is valid only
                     locally. (If a file is included, its <code><link linkend="attribute-xmlid"
                           >@xml:id</link></code>s pertain only to the elements that are included,
                     nothing more.) </para>
                  <para>An rule of thumb worth emphasizing in its own paragraph: <emphasis
                        role="bold"><code><link linkend="attribute-id">@id</link></code> and
                              <code><link linkend="attribute-xmlid">@xml:id</link></code> are
                        case-sensitive, and do not allow spaces. <link linkend="attribute-which"
                              ><code>@which</code></link> (and therefore <code><link
                              linkend="element-name">&lt;name&gt;</link></code>) is not
                        case-sensitive, and the space, hyphen, and underscore are
                        equivalent.</emphasis></para>
                  <para>TAN includes a number of standard TAN-voc files for a variety of concepts
                     commonly used in textual scholarship. For example, there are more than one
                     hundred types of textual divisions ready for use (see <xref
                        xlink:href="#vocabularies-div-types"/>). For more, see <xref
                        linkend="vocabularies-master-list"/>. </para>
                  <para>TAN-voc files tend invite frequent change and expansion, so it is
                     recommended that you use only those TAN-voc files designed for your project,
                     and not those from a different project.</para>
                  <para><code><link linkend="element-vocabulary">&lt;vocabulary></link></code> may
                     take <link linkend="attribute-which"><code>@which</code></link>, but it may
                     point only to one of the extra TAN vocabularies listed in <xref
                        xlink:href="#vocabularies-vocabularies"/>. This measure avoids extra
                     complexity in the validation routine. </para>
                  <para>Files pointed to by <code><link linkend="element-vocabulary"
                           >&lt;vocabulary></link></code> are considered an essential part of any
                     TAN file. Failure to find the target file with throw a fatal error during
                     validation.</para>
               </section>
               <section>
                  <title>Inclusions</title>
                  <para>More powerful than TAN-vocs are inclusions. Unlike other forms of inclusion
                     you may be familiar with, TAN inclusion involves only select elements, never an
                     entire file. TAN inclusion is a two-step process. </para>
                  <para>First, a TAN file is made available for inclusion via <code><link
                           linkend="element-inclusion">&lt;inclusion></link></code>s (inside <link
                        linkend="element-head"><code>&lt;head></code></link>). Like <code><link
                           linkend="element-vocabulary">&lt;vocabulary&gt;</link></code>, an
                           <code><link linkend="element-inclusion">&lt;inclusion></link></code> does
                     nothing on its own. It merely points to a file that may be used for inclusions.
                     But no inclusions occur until the next step.</para>
                  <para>Second, an element with only <code><link linkend="attribute-include"
                           >@include</link></code>, which points to the <code><link
                           linkend="attribute-xmlid">@xml:id</link></code> reference of the
                           <code><link linkend="element-inclusion">&lt;inclusion></link></code>, is
                     placed somewhere in the host file. In the validation process, those elements
                     will be replaced with every element of that name found in the inclusion file,
                     resolved recursively, and ignoring duplicated elements.</para>
                  <para>For example, a TAN-T file might have a <code>&lt;div
                     include="poem1"></code>, which in effect brings in the <code><link
                           linkend="element-div">&lt;div></link></code> content of the included
                     file. Because inclusion method, one can create nested TAN-T files. See the
                        <code>examples</code> folder for a case of the Gospels including the Sermon
                     on the Mount including the Lord's Prayer. The inclusion technique is especially
                     helpful for TAN-voc files, since it allows a project to use a single master
                     TAN-voc file that includes other TAN-voc files specific to particular
                     topics.</para>
                  <para>In any recursive system, circularity is fatal. That is true for TAN
                     inclusion as well, but only within a given element name. It is perfectly legal
                     for two files to include each other, as long as they do not try to include the
                     same elements. </para>
                  <para>TAN inclusion removes elements from their original context, which means that
                     values that must be interpreted locally are converted before the elements are
                     included. For example, <link linkend="attribute-which"
                        ><code>@which</code></link> and other attribute values are interpreted in
                     light of the included document's vocabulary, not those of the including
                     document. Similarly, different numeration systems, e.g., Roman numerals, are
                     interpreted locally and converted before inclusion (see <xref
                        linkend="reference_system"/>).</para>
                  <para>Files pointed to by <code><link linkend="element-inclusion"
                           >&lt;inclusion></link></code> are considered an essential part of any TAN
                     file. Failure to find the target file with throw a fatal error during
                     validation.</para>
               </section>
               <section>
                  <title>Other networked files</title>
                  <para>Other networked files can be specified. <code><link
                           linkend="element-predecessor">&lt;predecessor&gt;</link></code> and
                           <code><link linkend="element-successor">&lt;successor&gt;</link></code>
                     point to versions of the file that precede and postdate the current file. </para>
                  <para>In class-2 files <code><link linkend="element-source"
                        >&lt;source&gt;</link></code> always points to a networked file. In class-1
                     and class-3 files, <code><link linkend="element-source"
                        >&lt;source&gt;</link></code> may point either to a file or to a scriptum
                     (see <xref xlink:href="#domain_model"/>).</para>
                  <para><code><link linkend="element-see-also">&lt;see-also></link></code> can be
                     used to point to any file that has some relationship to a TAN file. The
                     required <code><link linkend="attribute-relationship"
                        >@relationship</link></code> points to one or more vocabulary items that
                     specify a kind of file-to-file relationship. There is no standard TAN
                     vocabulary for <code><link linkend="attribute-relationship"
                           >@relationship</link></code>. Normally, when a relationship is seen as
                     key, it makes its way directly as a full-fledged element.</para>
                  <para>Some TAN formats allow special types of networked files. For example,
                     class-1 files may have a <code><link linkend="element-model"
                           >&lt;model&gt;</link></code> or one or more <code><link
                           linkend="element-redivision">&lt;redivision&gt;</link></code>s,
                           <code><link linkend="element-annotation"
                     >&lt;annotation&gt;</link></code>s (pointing to class-2 files that use the
                     class-1 file as a <code><link linkend="element-source"
                        >&lt;source&gt;</link></code>), or <code><link
                           linkend="element-companion-version"
                        >&lt;companion-version&gt;</link></code>s (different version of the same
                     work in the same scriptum).</para>
               </section>
            </section>
            <section>
               <title>Adjustments</title>
               <para>The fourth major section of <code><link linkend="element-head"
                     >&lt;head></link></code>, which is optional, consists of <code><link
                        linkend="element-adjustments">&lt;adjustments></link></code>, which
                  specifies changes to the sources. In class-1 files, these consist of <code><link
                        linkend="element-normalization">&lt;normalization></link></code>s and
                        <code><link linkend="element-replace">&lt;replace&gt;</link></code>s; see
                     <xref xlink:href="#normalizing_transcriptions"/>. Class-2 files allow
                        <code><link linkend="element-skip">&lt;skip&gt;</link></code>, <code><link
                        linkend="element-rename">&lt;rename&gt;</link></code>, <code><link
                        linkend="element-equate">&lt;equate&gt;</link></code>, and <code><link
                        linkend="element-reassign">&lt;reassign&gt;</link></code> as adjustments;
                  see <xref xlink:href="#class_2_metadata"/>.</para>
            </section>
            <section>
               <title>Local vocabulary items and ID assignments: <code><link
                        linkend="element-vocabulary-key">&lt;vocabulary-key></link></code></title>
               <para>In the fifth major part of <code><link linkend="element-head"
                     >&lt;head></link></code>, <code><link linkend="element-vocabulary-key"
                        >&lt;vocabulary-key></link></code> provides the means to declare vocabulary
                  items relevant for the file. It also allows one to take vocabulary items existing
                  in other TAN-voc files (whether defined in <code><link
                        linkend="element-vocabulary">&lt;vocabulary&gt;</link></code> or standard
                  TAN vocabulary), and assign them <code><link linkend="attribute-xmlid"
                        >@xml:id</link></code> that are valid only in the current file. </para>
               <para>These ID assignments can be enhanced by <code><link linkend="element-alias"
                        >&lt;alias&gt;</link></code>es, which are used to group a set of IDs under a
                  single id. This practice should be familiar to those who have worked with critical
                  editions. Editors assign each relevant manuscript a siglum, say a single lowercase
                  Greek or Latin letter, and they give each family or group of manuscripts another
                  siglum, say an uppercase letter. That way, in the apparatus criticus in the bottom
                  of the page, a mix of family and manuscript sigla can be used to communicate
                  manuscript variants more concisely and clearly. An <code><link
                        linkend="element-alias">&lt;alias&gt;</link></code> works much the same way,
                  and can be applied to any vocabulary items. For example, in a class-1 file, if a
                  number of <code><link linkend="element-div">&lt;div></link></code>s are both
                  rubrics and headings, the two types can be bound to a single ID reference, e.g.,
                     <code>&lt;alias xml:id="rubhead" idrefs="rubr hd"&gt;</code>, where
                     <code>rubr</code> and <code>hd</code> are each values of <code><link
                        linkend="attribute-xmlid">@xml:id</link></code> elsewhere in the <code><link
                        linkend="element-vocabulary-key">&lt;vocabulary-key></link></code>. </para>
               <para>Unlike most other attributes like it, <code><link linkend="attribute-idrefs"
                        >@idrefs</link></code> cannot point to the <code><link
                        linkend="element-name">&lt;name&gt;</link></code> value of vocabulary items.
                  This reduces confusion, and allows some optimization during the process of
                  resolving a TAN file.</para>
               <para><code><link linkend="element-alias">&lt;alias&gt;</link></code>ing may nest.
                  That is, <code><link linkend="attribute-idrefs">@idrefs</link></code> in an
                        <code><link linkend="element-alias">&lt;alias&gt;</link></code> may refer to
                  vocabulary items or to other <code><link linkend="element-alias"
                        >&lt;alias&gt;</link></code>es. When you use <code><link
                        linkend="element-alias">&lt;alias&gt;</link></code>, be sure that the items
                  grouped are of the same type. In a few situations mixed groups do not pose a
                  problem, for example mixing <code><link linkend="element-person"
                        >&lt;person&gt;</link></code>s, <code><link linkend="element-algorithm"
                        >&lt;algorithm&gt;</link></code>s, and <code><link
                        linkend="element-organization">&lt;organization&gt;</link></code>s; in most
                  other situations an error will occur during Schematron validation when a
                  particular vocabulary item is not the type allowed in a particular
                  attribute.</para>
               <para>Because <code><link linkend="attribute-xmlid">@xml:id</link></code> restricts
                  the kinds of characters that can be supplied, and because <code><link
                        linkend="element-alias">&lt;alias&gt;</link></code> must be able to coin
                  unusual ids (especially for grammatical features), <code><link
                        linkend="attribute-id">@id</link></code> may be used to bind <code><link
                        linkend="attribute-idrefs">@idrefs</link></code> to special
                  characters.</para>
            </section>
            <section>
               <title>Responsibility</title>
               <para>The sixth section of a <code><link linkend="element-head"
                     >&lt;head></link></code> declares who is responsible for the file. It consists
                  of a <code><link linkend="element-file-resp">&lt;file-resp&gt;</link></code> and
                  one or more <code><link linkend="element-resp">&lt;resp></link></code>s. The
                  persons, organizations, or algorithms pointed to in <code><link
                        linkend="element-file-resp">&lt;file-resp&gt;</link></code> must include at
                  least one who has a tag URN in an <code><link linkend="element-IRI"
                        >&lt;IRI></link></code> whose first half (the tag URN namespace) matches the
                  first half the tag URN in the root element's <code><link linkend="attribute-id"
                        >@id</link></code>.</para>
            </section>
            <section>
               <title>Change log</title>
               <para>A change log consists of <code><link linkend="element-change"
                        >&lt;change></link></code>s. The entries do not constitute the entire
                  history of the file, which is calculated according to all attributes that have a
                  date or timeDate value. To get a full history of a file, the function <xref
                     xlink:href="#function-get-doc-history"/> or the global variable <xref
                     xlink:href="#variable-doc-history"/> can be used.</para>
               <para>The change log is an effective way to communicate to those who might use your
                  files. Anyone depending upon a copy will be warned, during Schematron validation,
                  of each <code><link linkend="element-change">&lt;change></link></code> that
                  postdates the value of <code><link linkend="attribute-accessed-when"
                        >@accessed-when</link></code>. If you have introduced an important or
                  disruptive change, you can mark your <code><link linkend="element-change"
                        >&lt;change></link></code> with <code><link linkend="attribute-flags"
                        >@flags</link></code>, that allows the following values:
                     <code>warning</code>, <code>error</code>, <code>info</code>,
                  <code>fatal</code>. If <code><link linkend="attribute-flags">@flags</link></code>
                  is missing, a <code><link linkend="element-change">&lt;change></link></code> sent
                  to another user during Schematron validation will be treated as a warning. By
                  marking a change as <code>info</code>, you lower the level of a change's
                  importantce; <code>error</code> raises it. The value <code>fatal</code> will halt
                  the validation process altogether.</para>
               <para>If you receive these messages during validation, and you want to stop them,
                  merely update the value of <code><link linkend="attribute-accessed-when"
                        >@accessed-when</link></code>.</para>
            </section>
            <section>
               <title>Pending work</title>
               <para>The last section of a <code><link linkend="element-head"
                     >&lt;head></link></code> lists all pending tasks that yet need to be applied to
                  a file. These are itemized as a list of <code><link linkend="element-comment"
                        >&lt;comment></link></code>s in <code><link linkend="element-to-do"
                        >&lt;to-do&gt;</link></code>. A file with an empty <code><link
                        linkend="element-to-do">&lt;to-do&gt;</link></code> is assumed to be
                  finished, and no longer in progress, and there must be a <code><link
                        linkend="element-master-location">&lt;master-location></link></code>
                  provided.</para>
               <para>The <code><link linkend="element-to-do">&lt;to-do&gt;</link></code> is an
                  effective way to communicate to those who might use your files. Anyone depending
                  upon a copy will be warned, during Schematron validation, of each item in the
                  list. The report is not dependent upon when the file was last consulted
                        (<code><link linkend="attribute-accessed-when"
                  >@accessed-when</link></code>), because these are standing, unresolved issues. </para>
               <para>Another benefit of <code><link linkend="element-to-do"
                     >&lt;to-do&gt;</link></code> is that you might be more inclined to release
                  imperfect, incomplete material ahead of time, knowing that you are giving other
                  users fair warning.</para>
            </section>
         </section>
      </chapter>
      <chapter xml:id="class_1">
         <title>Class-1 TAN Files, Representations of Textual Objects (Scripta)</title>
         <para>This chapter provides general background to class 1 TAN files. For detailed
            discussion of specific elements or attributes see <xref
               linkend="elements-attributes-and-patterns"/>.</para>
         <para>Class 1 TAN files preserve segmented transcriptions of books, manuscripts, papyri,
            stones, or any other objects with writing on them—collectively termed here
               <emphasis>scripta</emphasis> (sg. <emphasis>scriptum</emphasis>). Files of this class
            are the foundation of any project. No class 2 files (e.g., alignment, morphology) can be
            created without class 1 files. </para>
         <para>There are two types of class 1 formats, identified by the root element. <code><link
                  linkend="element-TAN-T">&lt;TAN-T></link></code> is a simple, generic format, as
            close as one can get to plain text. <code>&lt;TEI></code> (also referred to in this
            manual as TAN-TEI), on the other hand, can be complex and highly expressive. Because the
            two types function almost identically, the generic TAN-T format is described first,
            followed by supplemental comments on TAN-TEI.</para>
         <section xml:id="transcription_principles">
            <title>Principles and Assumptions</title>
            <section>
               <title>General</title>
               <para>(For more general principles and assumptions applying to all TAN files, not
                  just class 1, see <xref linkend="design_principles"/>.)</para>
               <para>Class 1 formats are designed for faithful but judiciously normalized digital
                  transcriptions. Each TAN-T(EI) file is devoted exclusively to a single version of
                  a single work found in a single scriptum (text-bearing object), segmented and
                  uniquely labeled with a common reference system. Editors of TAN-T(EI) files should
                  be able to read, write, and proofread texts in the languages of the
                  transcriptions. They should understand the texts well enough to segment them and
                  label them according to the conventions used for those works. They should be able
                  to distinguish the text of a primary source from its editorial apparatus. They
                  should be familiar with normalizing conventions for texts from the period,
                  language, and culture. They should know how the transcription might be used in
                  other contexts, especially translation studies or a study of quotations.</para>
               <para>Editors need not understand everything about their texts, and they need not
                  have any specialized skill in grammar or lexicography. They need not know the
                  morphology of individual words, or how individual parts of the text have been
                  translated. Those skills can be more profitably spent in other TAN formats. </para>
               <para>TAN-T(EI) editors stand at the beginning of the Text Alignment Network. It is
                  critical that work not be published hastily, and only after careful proofreading.
                  Many transcriptions, especially those of long texts, have typographical errors.
                  Eliminating as many as possible before publication will maximize the utility of a
                  TAN-T(EI) file. On the other hand, TAN has been designed with the assumption that
                  all our files likely have typographical errors that can and should be corrected as
                  they are found. If you are aware that a text needs another round of proofreading,
                  but you want to make it available, simply leave a <code><link
                        linkend="element-comment">&lt;comment></link></code> in the <code><link
                        linkend="element-to-do">&lt;to-do&gt;</link></code> part of the <link
                     linkend="element-head"><code>&lt;head></code></link>.</para>
               <para>If you are creating a TAN-T(EI) file, you are doing so primarily to facilitate
                  alignment and annotation, which depends critically upon a stable, familiar
                  reference system. Transcription files should be segmented and labeled according to
                  a reference system that is familiar and can be easily applied to other versions of
                  the same text in other languages. If possible, semantic mileposts (clauses,
                  sentences, paragraphs, chapters) should be prioritized over visual (lines,
                  columns, pages, volumes). See below on <link linkend="reference_system">reference
                     systems</link>.</para>
            </section>
            <section xml:id="domain_model">
               <title>Domain model</title>
               <para>Contributors and users of TAN files should strongly distinguish between a
                  scriptum (text-bearing object) and a conceptual work, e.g., a specific printed
                  copy of the <emphasis>Iliad</emphasis> versus the <emphasis>Iliad</emphasis>
                  concieved generally. The former has materiality (digital files are treated here as
                  being material) and the latter does not. Even though both are constitutively
                  necessary for any transcription, the two are sharply differentiated in the TAN
                  format: <code><link linkend="element-source">&lt;source&gt;</link></code> and
                        <code><link linkend="attribute-src">@src</link></code> point to physical
                  exemplars; <code><link linkend="element-work">&lt;work&gt;</link></code>,
                        <code><link linkend="attribute-work">@work</link></code>, and <code><link
                        linkend="element-version">&lt;version></link></code> to the conceptual.
                  Awareness of the distinction is quite important.</para>
               <para>Readers may be reminded at this point of the domain model defined by the
                  Functional Requirements for Bibliographical Records (FRBR), which identifies in
                  its Group 1 (Products of intellectual &amp; artistic endeavor) four types of
                  entities: <emphasis>Work</emphasis>, <emphasis>Expression</emphasis>,
                     <emphasis>Manifestation</emphasis>, and <emphasis>Item</emphasis>, the first
                  pair being conceptual, non-material entities and the latter pair material ones. </para>
               <para>TAN has been designed with a slightly different domain model. Concerning
                  conceptual entities, TAN has been designed with the assumption that most users
                  will find the distinction between Works and Expressions to be unhelpful or
                  misleading. What one person calls a FRBR Expression another may legitimately call
                  a Work. TAN assumes that any abstract creative act that changes a Work (or Works)
                  is itself a Work, which is really shorthand for <emphasis role="italic"
                     >work-version</emphasis>.<note>
                     <para>Keep in mind the important distinction between the abstract changing of a
                        work versus its material manifestation. Seneca rewrote the play
                           <emphasis>Medea</emphasis>. Seneca's version of
                           <emphasis>Medea</emphasis> (an abstract, non-material concept) should not
                        be conflated with the manuscript he wrote the version on, or subsequent
                        copies or editions.</para>
                  </note>  Thus, in this manual the term <emphasis>version</emphasis> specifies a
                  work that is known to derive from one or more work-versions. </para>
               <para>TAN avoids altogether the term <emphasis>Expression</emphasis>. Aside from the
                  issues mentioned above, the term implies a medium (without which nothing can be
                  expressed) and therefore materiality. </para>
               <para>As for the material entities, the FRBR Item is equivalent to what in TAN is
                  called a <emphasis>scriptum</emphasis>. Multiple scripta that for all intents and
                  purposes are indistinguishable (i.e., items reproduced mechanically) are
                  equivalent to FRBR Manifestations, but in TAN this does not entail a separate
                  entity in the model. A TAN scriptum is either one FRBR Item (e.g., manuscript X)
                  or one FRBR Manifestation, treated as a set of FRBR Items (e.g., all printed
                  copies of book Y). </para>
            </section>
            <section>
               <title>One version, one work, one object, one reference system</title>
               <para><emphasis>Every TAN-T(EI) file must be restricted to a transcription of a
                     single version of a single conceptual work found on a single scriptum,
                     segmented and labeled according to a single reference system</emphasis>. </para>
               <para>This restrictive principle is critical to the the success of the network. It
                  reduces the risk of confusion and simplifies the files.</para>
               <section xml:id="textual_objects">
                  <title>One scriptum</title>
                  <para>Each TAN-T(EI) file transcribes one and only one text-bearing object or
                     scriptum. It may be a digital file, a book, a manuscript, a stone, a sign, or a
                     bottlecap. If the object you've chosen has been made mechanically and is
                     virtually indistinguishable from other objects created by the same process
                     (e.g., copies of a printed book or copies of a digital file), then the entire
                     set of copies (what some librarians call a <emphasis>manifestation</emphasis>)
                     is to be treated as corresponding to the scriptum. </para>
                  <para>The definition of some scripta require an editor's discernment and judgment.
                     For example, some manuscripts have been split up, their parts now residing in
                     multiple libraries around the world; others may be a composite of older
                     manuscripts. In such cases, you may need to define your scriptum in a way that
                     might not match the way others define it. But the decision is your prerogative,
                     not theirs. You have both the right and responsibility to define your object in
                     the way that you think will most benefit users of your files.</para>
                  <para>It is a good idea to name your scriptum in <code><link
                           linkend="element-source">&lt;source></link></code> with an <code><link
                           linkend="element-IRI">&lt;IRI></link></code> value in the form of an
                        <code>http</code> URL that points to a detailed entry in a library
                     catalogue. This way you provide a way for others to retrieve extensive,
                     structured bibliographical information. You also save yourself the hassle of
                     writing a detailed bibliographical description that your users would probably
                     not be able to import into their reference management software. If a URL cannot
                     be found for <code><link linkend="element-IRI">&lt;IRI></link></code>, you may
                     simply coin a tag URN or a UUID. Alternatively, if you find another TAN file
                     that uses the same source, it would be a good idea to adopt its
                     nomenclature.</para>
               </section>
               <section xml:id="conceptual_works">
                  <title>One work</title>
                  <para>The transcription must be restricted to a single creative work, identified
                     by <code><link linkend="element-work">&lt;work></link></code> (part of the
                     declarations section of <code><link linkend="element-head"
                        >&lt;head></link></code>). </para>
                  <para>Many scripta have more than one work. Identifying and defining the creative
                     work you transcribe is, once again, your prerogative. Suppose the scriptum you
                     have is a Bible. You define the work. Perhaps you wish to encode the entire
                     Bible and treat it as a single work. Or maybe you wish to treat only the New
                     Testament as the work, or the Tetraevengelion, or the Gospel of Matthew, or a
                     specific episode in that gospel, or simply the Beatitudes. Any definition of a
                     work is permitted, but a TAN-T(EI) file should contain nothing but the work you
                     have defined. It should be a complete representation of what is found on the
                     object, even if only partially preserved, and respect as far as is practical
                     the order of the text in the scriptum.</para>
                  <para>Well-known works may have a suitable IRI already assigned to them, say by
                     means of a <link xlink:href="http://wiki.dbpedia.org/About">DBPedia</link>
                     entry. Most works have not been assigned IRIs or are named in IRI vocabularies
                     that are not well known. You may assign any work your own URN, through a UUID
                     or a tag URN. </para>
               </section>
               <section xml:id="work-versions">
                  <title>One version</title>
                  <para>The transcription must be restricted to a single version of the creative
                     work, identified by <code><link linkend="element-version"
                        >&lt;version></link></code> (optional, part of the declarations section of
                           <code><link linkend="element-head">&lt;head></link></code>). In most
                     cases, <code><link linkend="element-version">&lt;version></link></code> is
                     unnecessary, because <code><link linkend="element-work">&lt;work></link></code>
                     in conjunction with <code><link linkend="element-source"
                        >&lt;source></link></code> are sufficient to identify a particular
                     work-version. But if the source carries multiple versions (e.g., a bilingual
                     edition of a text), then <code><link linkend="element-version"
                           >&lt;version></link></code> should be included.</para>
                  <para>If you wish to have transcriptions of multiple versions from a scriptum,
                     each one should have its own separate TAN-T(EI) file. </para>
                  <para>Notes should be included only if they are an integral part of the primary
                     work (i.e., by the same author, not by a later editor). If you think the notes
                     to a work are important, consider putting them in their own TAN-T(EI) file, or
                     converting them to claims in a TAN-A file.</para>
                  <para>If you need to specify exactly where on a scriptum a version appears (i.e.,
                     page range), <code><link linkend="element-desc">&lt;desc></link></code> or
                           <code><link linkend="element-comment">&lt;comment></link></code> should
                     be used.</para>
                  <para>Very few work-versions have their own URN names. It is advisable to assign a
                     tag URN or a UUID. If the IRI you have used for <code><link
                           linkend="element-work">&lt;work></link></code> is in a namespace that you
                     own or control, then you are entitled to modify it, and you may wish merely to
                     add a suffix to the work IRI to name the version. For example, you might have
                        <code>tag:urn:example.com,2001:work:a</code> defined for the work; the
                     German version might be specified as
                        <code>tag:urn:example.com,2001:work:a:ver:deu</code>.</para>
               </section>
               <section xml:id="reference_system">
                  <title>One reference system</title>
                  <para>Every TAN transcription must be segmented into a hierarchy of uniquely
                     labeled divisions, defined in the <code><link linkend="element-body"
                           >&lt;body></link></code> through <code><link linkend="element-div"
                           >&lt;div></link></code>s and their <code><link linkend="attribute-n"
                           >@n</link></code> values. </para>
                  <para>Those divisions, whenever possible, should align with the reference system
                     that prevails for the work across versions or translations, what is sometimes
                     called a canonical reference system. Because even the most familiar reference
                     system admits degrees and dispute, the term <emphasis>canonical</emphasis> is
                     problematic. It is avoided in these guidelines, and in its place <emphasis
                        role="italic">reference system</emphasis> is used. </para>
                  <para>If you have your choice, preference should be given to reference systems
                     that follow the semantic contours of the work, not the physical features of a
                     particular object. Chapter, paragraph, and sentence numbers are preferable to
                     volume, page, and line numbers, because other derivative versions of a work
                     (e.g., translations, paraphrases) will only roughly, if at all, follow an
                     scriptum-oriented reference system. </para>
                  <para>Sometimes a scriptum-based reference system is inescapable, or is the most
                     common reference system for a work (e.g., Porphyry's commentary on the
                        <emphasis>Categories</emphasis>). It is perfectly acceptable to adopt that
                     scheme, but it may eventually entail more labor for the alignment process. </para>
                  <para>If a given work has multiple systems (e.g., the works of Plato and
                     Aristotle, which have two reference systems—logical and scriptum-oriented—both
                     of which are standard and important), then the recommended practice is to
                     encode the same text twice, placing in each file a <code><link
                           linkend="element-redivision">&lt;redivision&gt;</link></code> pointing to
                     each other. Under verbose validation, you will be notified if there are
                     discrepancies between the transcriptions, and Schematron Quick Fixes will allow
                     for relatively simple corrections of entire texts. </para>
                  <para>Having two or more alternatively divided editions can be quite useful. They
                     could serve as the basis for reference cross-indexes, or to help convert
                     another versions of the work from one reference system to the other.</para>
                  <para>If there is a good reference system, but the divisions are overly lengthy,
                     you may introduce subdivisions. But there is no guarantee that the provisional
                     subdivisions you introduce will be adopted by other editors who create or edit
                     TAN versions of the same work, and in the end editors working independently
                     upon the same text may produce discordant schemes. The TAN-A format was
                     designed to reconcile such differences.</para>
                  <para>If there is no reference system, or if you think that the ones that exist
                     are inadequate or misguided, create one of your own. If you develop your own
                     reference system, be sure to design it so that it can be adequately applied to
                     any version of the work, including those that might be discovered in the
                     future. </para>
                  <para xml:id="numeration-systems">Reference systems have as a central component
                     numbering systems. TAN supports five major numeration systems:<orderedlist>
                        <listitem>
                           <para><emphasis role="bold">Arabic numerals</emphasis>. 1, 2, 3,
                              etc.</para>
                        </listitem>
                        <listitem>
                           <para><emphasis role="bold">Roman numerals</emphasis>. Values up to 5000,
                              utilizing i, v, x, l, c, d, and m, uppercase or lowercase, with
                              liberal syntactic rules (within a roman numeral, any digit preceding
                              one of a higher value is assumed to be a subtraction from the total
                              value; all others are positive values).</para>
                        </listitem>
                        <listitem>
                           <para><emphasis role="bold">Alphabetic sequences</emphasis>. The
                              26-letter Roman alphabet, with numbers higher than 26 (or any multiple
                              of 26) beginning with the letter a incrementally repeated, e.g., y
                              (25), z, (26), aa (27), bb (28), … aaa (53). Uppercase or lowercase
                              allowed.</para>
                        </listitem>
                        <listitem>
                           <para><emphasis role="bold">Arabic numerals + alphabetic
                                 sequences</emphasis>. Arabic numerals followed immediately by an
                              alphabetic sequence. The second item is to be calculated as a
                              subsequence of the first item, with the lack of a second item taking
                              highest priority. E.g., 4, 4a, 4b, 4c....</para>
                        </listitem>
                        <listitem>
                           <para><emphasis role="bold">Alphabetic sequences + Arabic
                                 numerals</emphasis>: As above, but with alphabetic sequence
                              preceding Arabic numerals.</para>
                        </listitem>
                     </orderedlist></para>
                  <para>TAN file processors will attempt to convert all values of <code><link
                           linkend="attribute-n">@n</link></code> to Arabic numerals. Some values
                     are ambiguously Roman numerals or alphabetic sequences, e.g., <code>c</code>
                     could mean 3 (alphabetic sequence) or 100 (Roman numeral). Such numerals are
                     assumed to be roman, unless you supply a <code><link linkend="element-numerals"
                           >&lt;numerals&gt;</link></code> and define it as <code>roman</code> or
                        <code>letters</code>.</para>
                  <para>If you are using <code><link linkend="attribute-n">@n</link></code> to label
                     books of the Bible or Surahs of the Qur'an, you will run into the issue of
                     different conventions for @n from one person to another. You may want to use an
                     aspect of TAN that has very interesting potential for growth and development in
                     the future. If you include in the head <code>&lt;vocabulary which="bible
                        eng"/></code>, then non-numeric values of <code><link linkend="attribute-n"
                           >@n</link></code> will be checked against the corresponding TAN-voc file
                     listed in <code>/vocabularies/vocabularies.TAN-voc.xml</code> (i.e., to
                        <code>/vocabularies/extra/n.bible.eng.tan-voc.xml</code>. This, in turn,
                     will mark a specific <code><link linkend="element-div">&lt;div></link></code>
                     as being a particular work, and will allow other files to refer to the
                           <code><link linkend="element-div">&lt;div></link></code> by an equivalent
                     name. For example, if a class-1 file has <code>&lt;vocabulary which="bible
                        eng"/></code> and there is a <code>&lt;div type="book"
                        n="matt">...&lt;/div></code>, this section will be regarded as the work the
                     Gospel Matthew, and will have an associated IRI. Any class-2 file that refers
                     to that class-1 file as a source may use any synonym listed in the extra
                     vocabulary file <code>n.bible.eng.tan-voc.xml</code>, e.g., <code>Mt</code>,
                        <code>Mat</code>, <code>Matt</code>, or <code>Matthew</code> (or their
                     lowercase equivalents). </para>
                  <para>If you try the method above, it is recommended you include in the
                     declarations section of your <code><link linkend="element-head"
                           >&lt;head></link></code> an <code><link linkend="element-n-alias"
                           >&lt;n-alias&gt;</link></code>. This element, along with its <code><link
                           linkend="attribute-div-type">@div-type</link></code>, specifies exactly
                     which types of <code><link linkend="element-div">&lt;div></link></code>s are
                     eligible for aliasing on <code><link linkend="attribute-n">@n</link></code>.
                     This element considerably expedites validation.</para>
                  <para>The goal behind the extra vocabularies is to eliminate the need to worry
                     about what abbreviations are used to name special <code><link
                           linkend="element-div">&lt;div></link></code>s. It is hoped that in future
                     releases of TAN these extra vocabularies will grow in number and
                     quality.</para>
                  <para>There are also functions for other numeration systems, but they stand
                     outside the validation process. See <code><link
                           linkend="function-letter-to-number">tan:letter-to-number()</link></code>
                     and dependencies.</para>
               </section>
            </section>
            <section xml:id="normalizing_transcriptions">
               <title>Normalizing transcriptions</title>
               <para>You should declare how you have normalized the transcription via <code><link
                        linkend="element-adjustments">&lt;adjustments></link></code> and its
                  children, e.g., <code><link linkend="element-normalization"
                        >&lt;normalization></link></code>. (For suggestions on values of <code><link
                        linkend="element-IRI">&lt;IRI></link></code> for <code><link
                        linkend="element-normalization">&lt;normalization></link></code> see <xref
                     linkend="vocabularies-normalizations"/>.)</para>
               <para>Generally speaking, normalization entails the suppression of things extraneous
                  to or separable from the work you have chosen. You are encouraged to omit
                  parenthetical editorial insertions (especially quotation references), stray
                  handwritten remarks, discretionary word-breaking hyphens, editorial comments,
                  inserted cross-references, and reference numerals (page numbers, section numbers,
                  etc.). If chapter 4 begins "4." or "IV" then leave out the labeling numeral—you've
                  already indicated it in <code><link linkend="attribute-n">@n</link></code>, so
                  there's no need to clutter the text with it. Remember, scholars who use your file
                  will be concerned with things like word-for-word alignments and
                  lexico-morphological analysis, and putting in a modern editor's "4" will obstruct
                  those tasks. For the same reason, you should resolve ligatures and correct
                  unintended typographical errors.  </para>
               <para>The goal is a transcription whose text is free of the interpretive voice of
                  later editors. You should remove from the text anything that is not part of the
                  work proper and would interfere with detailed word-for-word alignment, or would
                  require extra preprocessing or postprocessing work for later users. If you are
                  segmenting a source into line breaks, and you are required to break a word between
                  divisions, do so with either the soft hyphen (<code>&amp;#xad;</code>) or the
                  zero-width joiner (<code>&amp;#x200d;</code>). TAN processors that handle the text
                  within a leaf <code><link linkend="element-div">&lt;div></link></code> will
                  automatically normalize its space. If either of those two characters are found at
                  the end then it will be deleted and the text from the next leaf <code><link
                        linkend="element-div">&lt;div></link></code> (if there is one) will
                  immediately follow without intervening space; if the two characters do not occur
                  at the end, then a simple white space, <code>&amp;#x20;</code>, will be added. For
                  more details, see <xref linkend="whitespace"/>.</para>
               <para>In a digital source, variable lengths of spacing marks (e.g., General
                  Punctuation U+2000..U+200B) should be converted to ordinary spaces (see <xref
                     xlink:href="#deprecated-unicode-points"/>), and superscript combining Roman
                  letters (U+0363..U+036F) should probably be converted to their non-combining
                  counterparts. All Unicode must be normalized to NFC forms (see <xref
                     linkend="normalization"/>). </para>
               <para>This principle holds true for variants in the scriptum. For example, a
                  manuscript may have correctors' marks. Or a set of footnotes (or apparatus
                  criticus) might comment on how and why the main text differs from previous
                  readings. In those cases, each set of corrections might be wholly incorporated
                  into the <code><link linkend="element-claim">&lt;claim></link></code>s of a TAN-A
                  file, perhaps also with a separate TAN-T file.</para>
               <para>Overall, normalization is a difficult topic, and it is not well studied. Not
                  all decisions will be clear-cut. You may justly hesitate before normalizing
                  orthography, punctuation, accentuation, or capitalization. Some aspects of Unicode
                  that lend themselves to varying conventions may need special consideration. You
                  may need to consider whether an unusual or rarely used Unicode character might be
                  misinterpreted or hinder other users. Document any decisions in the <code><link
                        linkend="element-adjustments">&lt;adjustments></link></code>. </para>
               <para>If you find it very difficult to bring yourself to normalize to the depth
                  advised above, try first making a (non-TAN) TEI file, and make it adhere as close
                  as possible to the scriptum you're studying. Once you have that out of your
                  system, try a second transcription in the TAN-T format. Users of TAN files are
                  most interested in how the text compares to other versions in other languages, not
                  in how it looks on the page.</para>
               <para>In some ambiguous areas, you can use TAN-TEI to your advantage. Suppose, for
                  example, a manuscript has reference numerals that are sui generis. That is, these
                  reference numbers do not correspond to the "canonical" reference scheme. On the
                  one hand, they are metadata, and should arguably be deleted; on the other, they
                  are part of the text, and witness to how a text was read and changed over time. A
                  middle-ground approach would move these references to TAN-TEI's
                     <code>&lt;milestone rend=""></code>. In that way, the numerals are removed from
                  the main text; on the other hand, the information is retained. Generally speaking
                  TEI's <code>@rend</code> is an excellent way to remove something from the main
                  text, without removing it from the file altogether.</para>
               <section>
                  <title xml:id="normalizing-annotations">Normalizing Annotations</title>
                  <para>If you are preparing a transcription where the original has footnotes or
                     endnotes, distinguish between those intrinsic to the work you're transcribing
                     from those that aren't. Those that aren't can be removed, or they can be put
                     into a separate TAN-T(EI) file, perhaps linking the two through <code><link
                           linkend="element-see-also">&lt;see-also></link></code>, and hopefully
                     structuring both files with the same reference system, to facilitate alignment.
                     Another way to approach the task is to convert some or all of the notes you're
                     removing into <code><link linkend="element-TAN-A">&lt;TAN-A></link></code>
                     <code><link linkend="element-claim">&lt;claim></link></code>s.</para>
                  <para>Similarly, you might legitimately consider the annotations to be a work in
                     their own right (and conversely, the work without the notes to be a work in its
                     own right). In that case, you can do steps recommended in the previous
                     paragraph. </para>
                  <para>Perhaps you still have footnotes, endnotes, glosses, or marginalia that are
                     intrinsic to the work. Such annotations present special challenges for encoding
                     in general and normalization in particular. </para>
                  <para>First is the issue of connecting an annotation to the text annotated. When
                     we encounter a footnote signal in a printed book, we understand that the
                     companion footnote is a kind of annotation on text we have just read. But what
                     text? Is it only the preceding word? Is it a word or phrase that occurs earlier
                     in the sentence? Does the annotation apply to earlier sentences, the entire
                     paragraph, or even prior paragraphs? For some notes, interpreting the intent of
                     the author is necessarily left as a decision for the reader to make.</para>
                  <para>In a digital file, connecting an annotation to its text requires a decision
                     and a commitment. Here are three possible ways to approach a transcription that
                     requires inclusion of annotations:</para>
                  <para><orderedlist>
                        <listitem>
                           <para>Use the <code>&lt;note></code> feature of TAN-TEI (see related
                                 <link
                                 xlink:href="http://www.tei-c.org/release/doc/tei-p5-doc/en/html/ref-note.html"
                                 >TEI documentation</link>). This will allow you to connect the
                              annotation to merely an anchor in the text, i.e., to no text
                              whatsover. </para>
                        </listitem>
                        <listitem>
                           <para>Move each annotation into a <code><link linkend="element-div"
                                    >&lt;div></link></code> with a <code><link
                                    linkend="attribute-type">@type</link></code> that implies that
                              it is an annotation (e.g., <code>scholium</code>) and place it
                              immediately after the <code><link linkend="element-div"
                                    >&lt;div></link></code> it annotates.</para>
                        </listitem>
                        <listitem>
                           <para>As #2, but also write a <code><link linkend="element-TAN-A"
                                    >&lt;TAN-A></link></code> file that more precisely connects each
                              annotation to the text it annotates.</para>
                        </listitem>
                     </orderedlist>The first option is expeditious, and will allow you to be as
                     precise or imprecise as you like. Validation is not affected, but you should be
                     aware that some applications may treat the <code>&lt;note></code> as a
                     constituent part of the <code><link linkend="element-div"
                        >&lt;div></link></code>. The second option is also relatively easy, but it
                     requires stepping away from precision. The third option allows immense
                     precision, and it will allow you to express alternatives, but the task could be
                     time-consuming. You will need to take stock of how precise and comprehensive
                     you choose to make your TAN data. (See <xref
                        xlink:href="#accuracy-precision-comprehensiveness"/>.)</para>
                  <para>Remember that the note signals in the main text and in the footnote area are
                     metadata meant to help readers link corresponding passages of texts, and should
                     be deleted. In a TAN-TEI file you can replace a note signal with <code>&lt;ref
                        rend="[NOTE SIGNAL TEXT]"/></code>. </para>
               </section>
            </section>
         </section>
         <section xml:id="tan-t_data">
            <title>Transcriptions and <code><link linkend="element-div">&lt;div></link></code>
               References</title>
            <para>The sole purpose of the <code><link linkend="element-body">&lt;body></link></code>
               of a class 1 file is to contain an ordered, segmented transcription of a single
               version of a single work from a scriptum. <code><link linkend="element-body"
                     >&lt;body></link></code> must take <code><link linkend="attribute-xmllang"
                     >@xml:lang</link></code>, specifying the language that predominates in the
               text. If a change in language occurs in a descendant <code><link
                     linkend="element-div">&lt;div></link></code>, ensure that its <code><link
                     linkend="attribute-xmllang">@xml:lang</link></code> also changes.</para>
            <para><code><link linkend="element-body">&lt;body></link></code> takes one or more
                     <code><link linkend="element-div">&lt;div></link></code> elements, each of
               which govern either other <code><link linkend="element-div">&lt;div></link></code>
               elements, or text (or TEI elements).</para>
            <para>The term <emphasis>leaf div</emphasis> refers to those <code><link
                     linkend="element-div">&lt;div></link></code>s that contain only text, and not
               other <code><link linkend="element-div">&lt;div></link></code>s. (The two are
               mutually exclusive in the TAN model.)</para>
            <para>Within this treelike structure of <code><link linkend="element-div"
                     >&lt;div></link></code>s, the concatenation of <code><link
                     linkend="attribute-n">@n</link></code> values, starting from the most ancestral
                     <code><link linkend="element-div">&lt;div></link></code>, provides the
               reference system used by class 2 files to refer to parts of TAN-T(EI) files. </para>
            <para>In previous versions of TAN, there was a requirement that each leaf <code><link
                     linkend="element-div">&lt;div></link></code> should be unique. That requirement
               has been downgraded from an error to a warning in light of common examples that
               required non-unique leaf div.<note>
                  <para>Some scripta are encoded such that leaf divs are broken up (see Bodëús's
                     edition of Aristotle's <emphasis>Categories</emphasis>, at 2a35, 2b5, and
                     2b6b). And some translations must be encoded so that leaf divs interleave.
                     Further, one TAN-T's leaf divs might easily become another TAN-T's non-leaf
                     divs, and vice versa.</para>
               </note>For any two <code><link linkend="element-div">&lt;div></link></code>s that
               share the same reference, it is not allowed that one be a leaf <code><link
                     linkend="element-div">&lt;div></link></code> and the other not. It is also
               further assumed that all <code><link linkend="element-div">&lt;div></link></code>s
               that share the same reference are consecutive, constituent parts of the same
                     <code><link linkend="element-div">&lt;div></link></code>.</para>
         </section>
         <section xml:id="tan-tei">
            <title>Transcriptions Using the Text Encoding Initiative (<code>&lt;TEI></code>)</title>
            <para>
               <note>
                  <para>This section is to be read in conjunction with <xref linkend="class_1"/> and
                        <xref linkend="TEI"/>, which address related technical issues.</para>
               </note>
            </para>
            <para>Some creators and editors of transcriptions will find the rather stripped-down
               TAN-T format inadequate. Some may wish to mark up the text further. Some may already
               have a library of transcriptions whose annotations are desirable to keep, even if
               uninteresting to most users. In these cases, you should use TAN-TEI, an extension to
               the Text Encoding Intiative (TEI) format, which is well known for its expressiveness,
               its stability, its flexibility, and its widespread use in scholarship.</para>
            <para>TEI was designed to be maximally expressive and flexible, to serve the detailed
               needs of scholars in the humanities. In serving this mission, TEI has come to define
               more than five hundred different element names, and more than two hundred attributes
               (roughly six times more than are defined in TAN). Of course, any given TEI file uses
               only a small subset of those elements and attributes, and TEI itself comes in
               different flavors, from TEI Lite, which uses only 75 attributes and 140 elements, to
               TEI All, which opens up almost the entire library. </para>
            <para>Although TEI XML is oftentimes seen as a standard, it lacks some of the
               charactistics one normally expects in a standard. It is very flexible, admits flavors
               and interpretation, and has been designed to encourage customization. Individuals and
               projects may define their own subset of TEI elements, to constrict or expand the
               allowable rules as they see fit. TAN-TEI is one of those customizations. The major
               difference is that TAN-TEI attempts to impose extra strictures not defined in TEI, to
               ensure that transcriptions are maximally likely to be interchangeable with other
               TAN-TEI files.</para>
            <para>All TEI files are validated against a <link
                  xlink:href="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/ST.html#STIN"
                  >TEI-conformant schema</link> normally as an XML DTD, RELAX NG, or W3C Schema. The
               TAN-TEI has such a TEI-conformant schema, derived from the TAN-TEI.odd file in the
               schemas directory. This schema defines the structural rules of the file. TAN-TEI
               files have an additional layer of validation in a related Schematron process, which
               performs detailed validation not possible in a TEI-conformant schema. Hence, in the
               discussion below, it is important to distinguish between structural validation and
               Schematron validation.</para>
            <para>TAN's customization of the TEI can be summarized as follows (the default namespace
               in this section is the TEI namespace,
               <code>http://www.tei-c.org/ns/1.0</code>):</para>
            <para>
               <table frame="all">
                  <title>Synopsis of TAN-TEI customization</title>
                  <tgroup cols="2">
                     <colspec colname="c1" colnum="1" colwidth="1*"/>
                     <colspec colname="c3" colnum="2" colwidth="3.21*"/>
                     <thead>
                        <row>
                           <entry>TEI element</entry>
                           <entry>Strictures</entry>
                        </row>
                     </thead>
                     <tbody>
                        <row>
                           <entry><code>&lt;TEI></code></entry>
                           <entry>
                              <itemizedlist>
                                 <listitem>
                                    <para>must have <code><link linkend="attribute-id"
                                          >@id</link></code> with tag URN</para>
                                 </listitem>
                                 <listitem>
                                    <para>must have <code><link linkend="attribute-TAN-version"
                                             >@TAN-version</link></code></para>
                                 </listitem>
                                 <listitem>
                                    <para>takes a new child element, <code><link
                                             linkend="element-head">&lt;head></link></code>, placed
                                       between <code>&lt;teiHeader></code> and
                                          <code>&lt;text></code>, and given a default namespace
                                       declaration
                                          <code>xmlns:tan="tag:textalign.net,2015:ns"</code>
                                    </para>
                                 </listitem>
                              </itemizedlist>
                           </entry>
                        </row>
                        <row>
                           <entry><code>&lt;text></code></entry>
                           <entry>
                              <itemizedlist>
                                 <listitem>
                                    <para>There are no extra strictures, but during Schematron
                                       validation (not RELAX-NG), this element and any children
                                          <code>&lt;front></code> and <code>&lt;back></code> will be
                                       ignored. Only the child <code><link linkend="element-body"
                                             >&lt;body></link></code> will be Schematron validated.
                                    </para>
                                 </listitem>
                              </itemizedlist>
                           </entry>
                        </row>
                        <row>
                           <entry><code><link linkend="element-body">&lt;body></link></code></entry>
                           <entry>
                              <itemizedlist>
                                 <listitem>
                                    <para>must take <code><link linkend="attribute-xmllang"
                                             >@xml:lang</link></code></para>
                                 </listitem>
                                 <listitem>
                                    <para>any non-<code><link linkend="element-div"
                                          >&lt;div></link></code> children will be ignored during
                                       Schematron validation; most often only <code><link
                                             linkend="element-div">&lt;div></link></code> should be
                                       children</para>
                                 </listitem>
                                 <listitem>
                                    <para>contents must be restricted to a single version of a
                                       single work</para>
                                 </listitem>
                                 <listitem>
                                    <para>any and all text nodes will be treated as part of the
                                       transcription</para>
                                 </listitem>
                              </itemizedlist>
                           </entry>
                        </row>
                        <row>
                           <entry><code><link linkend="element-div">&lt;div></link></code></entry>
                           <entry>
                              <itemizedlist>
                                 <listitem>
                                    <para>may take text, but if it does, it may not take any child
                                       elements (non-mixed model)</para>
                                 </listitem>
                                 <listitem>
                                    <para>any non-<code><link linkend="element-div"
                                          >&lt;div></link></code> children will be ignored during
                                       Schematron validation; most often only <code><link
                                             linkend="element-div">&lt;div></link></code> should be
                                       children</para>
                                 </listitem>
                                 <listitem>
                                    <para>must take <code><link linkend="attribute-type"
                                             >@type</link></code> and <code><link
                                             linkend="attribute-n">@n</link></code> (or only <link
                                          linkend="attribute-include"
                                       ><code>@include</code></link>)</para>
                                 </listitem>
                                 <listitem>
                                    <para><code><link linkend="attribute-type">@type</link></code>
                                       may take multiple values, space delimited, pointing via idref
                                       to a vocabulary item</para>
                                 </listitem>
                                 <listitem>
                                    <para><code><link linkend="attribute-n">@n</link></code> must
                                       consist of word characters or the underscore, conforming to
                                       the following regular expression: <code>[\w\._]+([\-
                                          ,]+[\w\._]+)*</code>. If <code><link linkend="attribute-n"
                                             >@n</link></code> is to be given more than one value,
                                       those items must be separated by a space or a comma. A
                                       hyphen-minus, - (U+002D, the most common form of hyphen),
                                       always has special meaning, specifying a range. This feature
                                       is useful for cases where a <code><link linkend="element-div"
                                             >&lt;div></link></code> straddles more than one
                                       standard reference number (e.g., a translation of Aristotle
                                       that cannot be easily tied to Bekker numbers). If you need to
                                       use a hyphen-like character in an <code><link
                                             linkend="attribute-n">@n</link></code> that does not
                                       specify a range, consider ‐ (U+2010 HYPHEN), ‑ (U+2011
                                       NON-BREAKING HYPHEN), ‒ (U+2012 FIGURE DASH), – (U+2013 EN
                                       DASH), or − (U+2212 MINUS SIGN).</para>
                                 </listitem>
                              </itemizedlist>
                           </entry>
                        </row>
                     </tbody>
                  </tgroup>
               </table>
            </para>
            <para>TAN-TEI files have two heads, which may strike you as odd. The TEI head and the
               TAN head were designed for different purposes. Whereas the TAN <link
                  linkend="element-head"><code>&lt;head></code></link> is meant to be brief and
               keyed to both IRIs and human-readable data, the <code>&lt;teiHeader></code> permits
               quite an expansive range of metadata, and about matters that might bear only
               indirectly on the transcription (e.g., manuscript descriptions). Further,
                  <code>&lt;teiHeader></code> was designed to be read principally by humans. </para>
            <para>The TAN Schematron validation process ignores the contents of
                  <code>&lt;teiHeader></code>, since the contents are unpredictable. If your
                  <code>&lt;teiHeader></code> has any kind of metadata relevant to TAN users, you
               will need first to create a standard TAN <link linkend="element-head"
                     ><code>&lt;head></code></link> (see <xref linkend="metadata_head"/> and <xref
                  linkend="transcription_principles"/>). This conversion needs to be performed
               manually, since the two headers are incommensurate, and writing each one requires a
               different kind of mentality.</para>
            <para>In a TAN-TEI file, the TAN <code><link linkend="element-head"
                  >&lt;head></link></code> must take the TAN namespace, i.e., <code>&lt;head
                  xmlns="tag:textalign.net,2015:ns"></code> or <code>&lt;tan:head
                  xmlns:tan="tag:textalign.net,2015:ns"></code>, but the latter would require all
               descendant elements to be prefixed <code>tan:</code>.</para>
            <para>Within any leaf <code><link linkend="element-div">&lt;div></link></code>, you may
               use whatever TEI markup you wish, to whatever level of depth or complexity. All users
               of your TAN-TEI file will be interested in the text; only a subset will care about
               any markup within leaf <code><link linkend="element-div">&lt;div></link></code>s. </para>
            <para>TEI files are flexible, permitting different kinds of orientation. A TAN-TEI file
               should not be scriptum-oriented, i.e., it should not try to represent the physical
               appearance of the text on the object. </para>
            <para>You may have a TEI file that you wish to convert to TAN-TEI. As a matter of
               practicality, it is helpful to envision the conversion process as falling in three
               steps:</para>
            <para>
               <orderedlist>
                  <listitem>
                     <para>Structure: insert new processing instructions (pointing to files to
                        perform TAN-TEI structural and Schematron validation); adjust root element
                        by supplying a tag URN for <code><link linkend="attribute-id"
                           >@id</link></code> and <code><link linkend="attribute-TAN-version"
                              >@TAN-version</link></code>.</para>
                  </listitem>
                  <listitem>
                     <para>Metadata: create new <code><link linkend="element-head">&lt;head
                              xmlns="tag:textalign.net,2015:ns"></link></code> and populate
                        it</para>
                  </listitem>
                  <listitem>
                     <para>Data: edit <code><link linkend="element-body">&lt;body></link></code> to
                        make sure all text nodes are restricted the content of a single version of a
                        single work; restructure <code><link linkend="element-body"
                           >&lt;body></link></code> content into nesting <code><link
                              linkend="element-div">&lt;div></link></code>s with correct <code><link
                              linkend="attribute-type">@type</link></code> and <code><link
                              linkend="attribute-n">@n</link></code> values.</para>
                  </listitem>
               </orderedlist>
            </para>
            <para>It has been the experience of those who have made TEI to TAN-TEI conversions that
               step 2 is the most time-consuming, particularly in finding the IRIs required. But
               step 3 should not be underestimated, either. Many people write TEI files with a focus
               on the original textual object, and they do not normalize to the level expected in a
               TAN file. Some TEI files have been written with little attention paid to space and
               space normalization. Some TEI files are so laden with annotations that the text is
               impossible to read. In general, the more simple the TEI file the better.</para>
         </section>
      </chapter>
      <chapter xml:id="class_2">
         <title>Class-2 TAN Files, Annotations of Texts</title>
         <para>This chapter provides general background to class 2 TAN files. For detailed
            discussion of individual elements and attributes see <xref
               linkend="elements-attributes-and-patterns"/>.</para>
         <para>There are three types of class 2 files:<orderedlist>
               <listitem>
                  <para><emphasis role="bold">TAN-A</emphasis> files provide broad, macroscopic
                     alignment of multiple versions of any number of works. It also provides a place
                     for annotating the texts through general claims.</para>
               </listitem>
               <listitem>
                  <para><emphasis role="bold">TAN-A-tok</emphasis> files provide narrow, microscopic
                     alignment of any two class 1 files, identifying word-for-word or
                     character-for-character correspondence.</para>
               </listitem>
               <listitem>
                  <para><emphasis role="bold">TAN-A-lm</emphasis> files support lexico-morphology
                     (part-of-speech) for either a single class 1 file or a language.</para>
               </listitem>
            </orderedlist></para>
         <para>In translation studies, it is common to use the term <emphasis>source</emphasis> (or
               <emphasis>sources</emphasis>) to refer to a translated text and the term
               <emphasis>target</emphasis> to refer to the translation. TAN, however, has been
            designed for situations where it may not be clear which text is the target and which is
            the source. Further, there is a more generic use of <emphasis>source</emphasis> and
               <emphasis>target</emphasis> that prevails in many contexts. In these guidelines,
            therefore, we avoid the term <emphasis role="italic">target</emphasis> altogether, and
            when we use the word <emphasis role="italic">source</emphasis>, we are referring only to
            one of the class 1 files upon which a class 2 alignment depends.</para>
         <section xml:id="class_2_common">
            <title>Common Elements</title>
            <section xml:id="class_2_metadata">
               <title>Class 2 Metadata (<code><link linkend="element-head"
                  >&lt;head></link></code>)</title>
               <para>Class 2 files share a few common features in their metadata, mostly to
                  facilitate the human-friendly reference system outlined above.</para>
               <para>All class 2 files have as their sources nothing other than class 1 files.
                  Therefore each <code><link linkend="element-source">&lt;source></link></code> must
                  take the <xref xlink:href="#digital_entity_metadata"/>. </para>
               <para>Editors of class 2 files must be able to name or number word-tokens in a
                  transcription, via an optional <code><link linkend="element-token-definition"
                        >&lt;token-definition></link></code>. See <xref linkend="defining_tokens"
                  />.</para>
               <para>The declaration <code><link linkend="element-numerals"
                     >&lt;numerals&gt;</link></code> at present does not allow you to customize a
                  numeration system for sources. A future release of TAN may support such a
                  distinction.</para>
               <para>Inevitably, some class 1 sources will have differences. Perhaps works or div
                  types were not defined with the same IRIs, or perhaps one version follows an
                  idiosyncratic reference system. If sources need to be reconciled, alterations are
                  specified in <code><link linkend="element-adjustments"
                     >&lt;adjustments&gt;</link></code>, which stipulates a set of actions that
                  should be applied to the sources that have been named. Alteration actions
                  include:</para>
               <orderedlist>
                  <listitem>
                     <para><code><link linkend="element-skip">&lt;skip&gt;</link></code> allows you
                        to ignore specific <code><link linkend="element-div"
                           >&lt;div&gt;</link></code>s, deeply or shallowly.</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="element-rename">&lt;rename&gt;</link></code> allows
                        you to rename specific <code><link linkend="element-div"
                           >&lt;div&gt;</link></code>s.</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="element-equate">&lt;equate&gt;</link></code> allows
                        you to provide synonyms for <code><link linkend="attribute-n"
                           >@n</link></code> values.</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="element-reassign">&lt;reassign&gt;</link></code>
                        allows you to move parts of leaf <code><link linkend="element-div"
                              >&lt;div&gt;</link></code>s elsewhere. </para>
                  </listitem>
               </orderedlist>
               <para>These actions allow you to adjust sources that are at odds, without changing
                  them directly. Actions are applied in the sequence stated above, from root to
                  leaf. That is, in Schematron validation, a source will be adjusted first by
                  applying skips, then renames, then equates. The hierarchy is then re-evaluated
                  before processing reassigns. Each type of action will be processed on according to
                  position in the hierarchy, not the placement of the action command in the class-2
                        <code><link linkend="element-adjustments">&lt;adjustments&gt;</link></code>
                  elements. Because of this, some actions might not be performed. For example, if
                  you deeply skip a <code><link linkend="element-div">&lt;div></link></code>, no
                  renaming adjustments will be made to its children. If you have renamed a div, then
                  want to reassign it, you must do so based on the new name, not the original. </para>
               <para>Each action adds time to the validation routines. On lengthy texts these can
                  become quite time-consuming. You are advised to keep <code><link
                        linkend="element-adjustments">&lt;adjustments&gt;</link></code>s to a
                  minimum. </para>
               <para>Further, these actions are meant to provide minor adjustments to sources, not
                  wholesale alterations. If a source must be changed in numerous ways to reconcile
                  it with other sources, you should create a new version, and perhaps in the class-1
                  files take advantage of <code><link linkend="element-redivision"
                        >&lt;redivision&gt;</link></code>, <code><link linkend="element-predecessor"
                        >&lt;predecessor&gt;</link></code>, <code><link linkend="element-successor"
                        >&lt;successor&gt;</link></code>, or <code><link linkend="element-see-also"
                        >&lt;see-also></link></code> to link the two versions.</para>
            </section>
            <section>
               <title>Class 2 Data (<code><link linkend="element-body"
                  >&lt;body></link></code>)</title>
               <para>Data differs greatly between the class 2 formats. However, they all share one
                  thing in common: the &lt;body> consists of a series of claims, and responsibility
                  for those claims should be attested. Therefore, each &lt;body> may take
                        <code><link linkend="attribute-claimant">@claimant</link></code> and perhaps
                        <code><link linkend="attribute-claim-when">@claim-when</link></code>,
                  specifying by ID ref who should be credited or blamed with the material. If either
                  attribute are missing, it is assumed that the claims are the responsibility of the
                  persons listed in <code><link linkend="element-file-resp"
                     >&lt;file-resp&gt;</link></code> at the time of the latest date or date-time.
                  These values are inheritable, and therefore they are overwritten by any
                        <code><link linkend="attribute-claimant">@claimant</link></code> or
                        <code><link linkend="attribute-claim-when">@claim-when</link></code> in the
                  descendants of <code><link linkend="element-body">&lt;body></link></code>.</para>
            </section>
            <section xml:id="pointer-syntax">
               <title>Class 2 Pointer Syntax: Referencing Texts</title>
               <para>The class 2 formats have been designed to be human readable, particularly
                  reference to sections of class 1 files. In ordinary conversation, when refering to
                  specific parts of a work, we like to cite pages, paragraphs, sentences, lines,
                  words, letters, and so forth. We use relational words (e.g., "first"), and the
                  very text itself. We might say, for example, "See page 4, second paragraph, the
                  last four words." Or, "See page 4, second paragraph, first sentence, second
                  occurence of 'pull'." </para>
               <para>Those familiar conventions are the basis for the TAN pointer syntax, which
                  differs from other pointer systems (e.g., URLs, XPath, and XPointer). TAN pointers
                  draw from normal vocabulary applied to a four-level hierarchy: works, divisions,
                  word tokens, and characters. <emphasis>Works</emphasis>, defined above (see <xref
                     linkend="conceptual_works"/>), are declared by the <emphasis>source</emphasis>
                  (which may not have more than one work). <emphasis>Divisions</emphasis> are
                  defined by the <code><link linkend="element-div">&lt;div></link></code> structure
                  of each source. <emphasis>Tokens</emphasis> are words of the text in those
                  divisions, defined according to one or more tokenization rules, declared in the
                  class 2 file. And <emphasis>characters</emphasis> are defined individual letters
                  in a word token, along with any following modifier characters (e.g.,
                  accents).</para>
               <para>This approach not only makes the syntax human readable, it also mitigates
                  disruptions from corrections to the sources. For example, if a <code><link
                        linkend="element-div">&lt;div></link></code> is deleted, moved, or changed,
                  the alteration affects only a specific part of the document; the rest of the
                  reference system remains intact.</para>
               <para>Specific parts of this reference system are explained immediately following,
                  but you should consult other parts of the guidelines, or TAN examples, to see how
                  they work together.</para>
               <section>
                  <title>Referencing Works: <code><link linkend="attribute-work"
                     >@work</link></code></title>
                  <para>Class 2 files refer to works via meaningful ID refs that point to the
                     sources that define the work, e.g., <code><link linkend="attribute-work"
                           >@work</link>="hamlet"</code>. The reference is understood to apply not
                     merely to that particular source, but to any TAN-T file that claims to
                     transcribe that work. Thus, a source ID becomes a kind of proxy or alias for
                     the work.</para>
               </section>
               <section xml:id="referencing-divisions">
                  <title>Referencing Divisions: <code><link linkend="attribute-ref"
                        >@ref</link></code></title>
                  <para>Portions of text, i.e., <code><link linkend="element-div"
                        >&lt;div></link></code>s, are referred to by <code><link
                           linkend="attribute-ref">@ref</link></code>, which points to one or more
                           <code><link linkend="element-div">&lt;div></link></code>s through their
                     reference, perhaps substituted with their new values if <code><link
                           linkend="element-adjustments">&lt;adjustments&gt;</link></code>s have
                     been invoked (see <xref linkend="metadata_head"/>. The <code><link
                           linkend="attribute-ref">@ref</link></code> is constructed by joining the
                     values of <code><link linkend="attribute-n">@n</link></code> in the <code><link
                           linkend="element-div">&lt;div></link></code> in question along with its
                     ancestor <code><link linkend="element-div">&lt;div></link></code>s. For
                     example, e.g., <code><link linkend="attribute-ref">@ref</link>="I.1.1"</code>
                     might point to the following:</para>
                  <para>
                     <programlisting>&lt;div type="act" n="1">
   &lt;div type="scene" n="1">
      <emphasis role="bold">&lt;div type="line" n="1">
         . . . . . .
      &lt;/div></emphasis>
      . . . . . .
   &lt;/div>
   . . . . . .
&lt;/div></programlisting>
                  </para>
                  <para>A <code><link linkend="attribute-ref">@ref</link></code> allows for ranges
                     and series of <code><link linkend="element-div">&lt;div></link></code>s. In the
                     example <code><link linkend="attribute-ref">ref</link>="1.2-4, 1.5"</code>, the
                     hyphen and comma, which are reserved to signify ranges and series, are
                     reserved. But the period is an arbitrary punctuation device to separate levels
                     of hierarchy, and can be replaced with any non-word character you like (except
                     the hyphen and comma). The numeral system is also arbitrary. You may also use
                     one of the other supported numeral systems (see <link
                        xlink:href="#numeration-systems">section on numeration systems</link>). The
                     example above is equivalent to <code><link linkend="attribute-ref"
                        >ref</link>="A ii-iv, A v"</code> and <code><link linkend="attribute-ref"
                           >ref</link>="I:b-d, I.e"</code>. Just remember that if you use either the
                     Roman numeral system or alphabetic sequences to include a <code><link
                           linkend="element-numerals">&lt;numerals&gt;</link></code> to specify
                     which system should prevail in case of ambiguities.</para>
               </section>
               <section xml:id="attr_pos_and_val">
                  <title>Referencing Tokens: <code><link linkend="attribute-pos">@pos</link></code>
                     and <code><link linkend="attribute-val">@val</link></code></title>
                  <para>To point to a token, one of three methods may be used.</para>
                  <para>
                     <orderedlist>
                        <listitem>
                           <para><emphasis role="italic"><code><link linkend="attribute-pos"
                                       >@pos</link></code> alone</emphasis>. Under this method, one
                              or more digits, or the phrase <code>last</code> or <code>last-</code>
                              plus a digit, joined by hyphens or commas indicate one or more token
                              numbers. For example, <code>2, 4-6, last-2 - last</code> refers to the
                              second, fourth, fifth, sixth, antepenult, penult, and final tokens in
                              a passage. The numerical value to which the keyword <code>last</code>
                              resolves depends upon the length of each <code><link
                                    linkend="element-div">&lt;div></link></code>.</para>
                        </listitem>
                        <listitem>
                           <para><emphasis role="italic"><code><link linkend="attribute-val"
                                       >@val</link></code> alone</emphasis>. Under this method, a
                              single token is picked by means of a string value equivalent to the
                              token. For example, <code><link linkend="attribute-val">@val</link> =
                                 "bird"</code>, points to the first occurence of the token
                                 <code>bird</code>.</para>
                        </listitem>
                        <listitem>
                           <para><emphasis role="italic"><code><link linkend="attribute-pos"
                                       >@pos</link></code> and <emphasis role="italic"><code><link
                                          linkend="attribute-val">@val</link></code></emphasis>
                                 together.</emphasis> Under this method, specific occurences of a
                              token are picked. For example, <code><link linkend="attribute-val"
                                    >@val</link>="bird" <link linkend="attribute-pos"
                                 >@pos</link>="2, 4"</code> picks the second and fourth occurences
                              of the token <code>bird</code>.</para>
                        </listitem>
                     </orderedlist>
                  </para>
                  <para>During Schematron validation, if <code><link linkend="attribute-pos"
                           >@pos</link></code> or <code><link linkend="attribute-val"
                        >@val</link></code> are missing, they are supplied with their default
                     values, <code>1</code> and <code>.+</code> respectively. That is, <code><link
                           linkend="attribute-pos">@pos</link></code> by default points to the first
                     instance and <code><link linkend="attribute-val">@val</link></code> by default
                     points to any string.</para>
                  <para><code><link linkend="attribute-pos">@pos</link></code> and <code><link
                           linkend="attribute-val">@val</link></code> must be used carefully. For
                     example, the attribute combination <code>val="bird" pos="last-5"</code> will
                     produce an error if the word token <code>bird</code> does not occur at least
                     six times.</para>
                  <para>It is advisable to use <code><link linkend="attribute-val"
                        >@val</link></code>, and not merely <code><link linkend="attribute-pos"
                           >@pos</link></code>. If your source's text changes, references are less
                     like to be reconstructable if there is no <code><link linkend="attribute-val"
                           >@val</link></code>. </para>
               </section>
               <section>
                  <title>Referencing Characters: <code><link linkend="attribute-chars"
                        >@chars</link></code></title>
                  <para>Characters are always specified by <code><link linkend="attribute-chars"
                           >@chars</link></code>, which points to a specific position, e.g.,
                           <code><link linkend="attribute-chars">chars</link>="2, 7, last"</code>.
                     Remember, combining characters are not included in these counts; see <xref
                        xlink:href="#combining_characters"/>.</para>
               </section>
            </section>
         </section>
         <section xml:id="TAN-A">
            <title>Division-Based Annotations and Alignments (<code><link linkend="element-TAN-A"
                     >&lt;TAN-A></link></code>)</title>
            <para>TAN-A is the format for macroscopic, division-based alignment and annotations. It
               is dedicated to aligning any number of versions of any number of works on the basis
               of <code><link linkend="element-div">&lt;div></link></code>s in its sources. The A
               also stands for annotations, because a TAN-A file allows you to make general
               assertions, normally about texts. TAN-A is essentially an advanced RDF for textual
               scholarship (see <xref xlink:href="#rdf_and_lod"/>).</para>
            <section>
               <title>Root Element and Header</title>
               <para>The root element of a TAN division-based alignment file is <code><link
                        linkend="element-TAN-A">&lt;TAN-A></link></code>.</para>
               <para>TAN-A's <code><link linkend="element-head">&lt;head></link></code> has one or
                  more <code><link linkend="element-source">&lt;source></link></code>s.</para>
               <para>Any concepts that will be mentioned in the <code><link linkend="element-claim"
                        >&lt;claim&gt;</link></code>s (the only children of <code><link
                        linkend="element-body">&lt;body></link></code>) need to be supplied in
                        <code><link linkend="element-vocabulary-key"
                     >&lt;vocabulary-key></link></code>.</para>
            </section>
            <section>
               <title>Data (<code><link linkend="element-body">&lt;body></link></code>)</title>
               <para>The <code><link linkend="element-body">&lt;body></link></code> of a TAN-A file
                  takes, in addition to the customary optional attributes (see <xref
                     linkend="edit_stamp"/>), <code><link linkend="attribute-claimant"
                        >@claimant</link></code>, <code><link linkend="attribute-object"
                        >@object</link></code>, <code><link linkend="attribute-subject"
                        >@subject</link></code>, or <code><link linkend="attribute-verb"
                        >@verb</link></code>, stipulating the default values for any claims to
                  come.</para>
               <para>The rest of the body consists of zero or more <code><link
                        linkend="element-claim">&lt;claim&gt;</link></code>s, each of which
                  represents one or more claims, which can be applied for a variety of purposes,
                  e.g.,:</para>
               <para>
                  <itemizedlist>
                     <listitem>
                        <para>to list quotations and allusions;</para>
                     </listitem>
                     <listitem>
                        <para>to indicate which passages deal with what general subjects and
                           topics;</para>
                     </listitem>
                     <listitem>
                        <para>to connect commentary or notes from one source with another;</para>
                     </listitem>
                     <listitem>
                        <para>to indicate where other scripta have different readings (apparatus
                           criticus).</para>
                     </listitem>
                  </itemizedlist>
               </para>
               <para><code><link linkend="element-claim">&lt;claim&gt;</link></code> is based on a
                  model inspired by the Resource Description Framework (RDF; see <xref
                     linkend="rdf_and_lod"/>). RDF depends upon a simple data model, where each
                  datum consists of three items termed a subject, a predicate, and an object. The
                  first and third are thought of as nodes, and the second as a connector between the nodes.<note>
                     <para><emphasis>Connector</emphasis> is our preferred term, because it
                        accurately describes its function, namely, to create a relationship between
                        two things. The more common term is <emphasis>edge</emphasis>, but that term
                        is misleading. An edge does not necessarily connect things (e.g., the two
                        edges on a cylinder). An edge, like a boundary, makes one think not of its
                        end points (if they exist) but of the two spatial regions it
                        separates.</para>
                  </note></para>
               <para>RDF is adequate for but a limited range of scholarly assertions. An RDF
                  statement lacks context or qualifiers. It is unclear who made it, or when, or if
                  it was uttered with any doubt or nuance. Sometimes we wish to claim a bare
                  negation, e.g., "Aristotle was not the author of <emphasis>De
                  mundo</emphasis>"—which cannot be expressed in RDF.</para>
               <para>TAN's <code><link linkend="element-claim">&lt;claim&gt;</link></code> extends
                  RDF in the following manner:<orderedlist>
                     <listitem>
                        <para>Every claim must have at least one <emphasis role="bold"
                              >claimant</emphasis>, some person, organization, or algorithm to be
                           credited/blamed for the assertion.</para>
                     </listitem>
                     <listitem>
                        <para>Every claim must have at least one <emphasis role="bold"
                              >subject</emphasis>, the topic of the claim.</para>
                     </listitem>
                     <listitem>
                        <para>Every claim must have at least one <emphasis role="bold"
                              >verb</emphasis> (in RDF called <emphasis>predicate</emphasis>),
                           specifying something about the subject.</para>
                     </listitem>
                     <listitem>
                        <para>Every claim may have at least one <emphasis role="bold"
                              >adverb</emphasis>, qualifying the verb.</para>
                     </listitem>
                     <listitem>
                        <para>Every claim may assert a level or range of <emphasis role="bold"
                              >certainty</emphasis>, between zero and one, reflecting how certain
                           the claimant is of the claim.</para>
                     </listitem>
                     <listitem>
                        <para>Every claim may have at least one <emphasis role="bold"
                              >object</emphasis>, an entity or value expected by the verb.</para>
                     </listitem>
                     <listitem>
                        <para>Every claim may have at least one <emphasis role="bold">temporal
                              qualifier</emphasis>, restricting the claim to a specific time.</para>
                     </listitem>
                     <listitem>
                        <para>Every claim may have at least one <emphasis role="bold">locative
                              qualifier</emphasis>, restricting the claim to a specific geographical
                           region.</para>
                     </listitem>
                     <listitem>
                        <para>Every claim may have other components, if so defined by the verb.
                           Currently, this entails a language qualifier (<code><link
                                 linkend="attribute-in-lang">@in-lang</link></code>, <code><link
                                 linkend="element-in-lang">&lt;in-lang&gt;</link></code>) and a
                           reference qualifier (<code><link linkend="element-at-ref"
                                 >&lt;at-ref&gt;</link></code>).</para>
                     </listitem>
                  </orderedlist>Above is the default construction of a claim. But ##4-9 may be
                  restricted or relaxed by a <code><link linkend="element-verb"
                     >&lt;verb&gt;</link></code>'s definition. For example, <code><link
                        linkend="element-verb">&lt;verb&gt;</link></code> representing an idea that
                  in normal discourse is intransitive (e.g., sleep) can be defined such that
                        <code><link linkend="element-object">&lt;object></link></code> is not
                  allowed. Or a <code><link linkend="element-verb">&lt;verb&gt;</link></code> may be
                  defined to allow only certain numbers or types of objects or subjects. For
                  example, the verb <code>lacks_text_at</code> is defined to allow only scripta as a
                  subject. An object is not allowed. The claim expects one or more <code><link
                        linkend="element-at-ref">&lt;at-ref&gt;</link></code>s, which restricts the
                  claim to a particular passage in a TAN-T file. A <code><link
                        linkend="element-verb">&lt;verb&gt;</link></code> can specify that an object
                  must be data, and it can also define the type of data allowed and its permitted
                  lexical form. </para>
               <para>Claims may refer to other claims. This can be done through nested recursion of
                        <code><link linkend="element-claim">&lt;claim></link></code> (e.g., X claims
                  that Y claims that Z claims that...). Or a <code><link linkend="element-claim"
                        >&lt;claim></link></code> may take an <code><link linkend="attribute-xmlid"
                        >@xml:id</link></code>, whose value can then be cited as the object or
                  subject of any other <code><link linkend="element-claim"
                  >&lt;claim></link></code>.</para>
               <para>If a <code><link linkend="element-claim">&lt;claim></link></code> is about a
                  work or source in general, it may take merely ID refs in <code><link
                        linkend="attribute-subject">@subject</link></code> or <code><link
                        linkend="attribute-object">@object</link></code>. But if the textual
                  reference needs to be more specific, these attributes are replaced by their
                  corresponding element forms, <code><link linkend="element-subject"
                        >&lt;subject></link></code> or <code><link linkend="element-object"
                        >&lt;object></link></code>, which take <code><link linkend="attribute-work"
                        >@work</link></code> or <code><link linkend="attribute-src"
                     >@src</link></code>, which have as values ID refs to one or more <code><link
                        linkend="element-source">&lt;source&gt;</link></code>s. If <code><link
                        linkend="attribute-work">@work</link></code>, the claim applies to all
                  sources that have the same work as the target source; if <code><link
                        linkend="attribute-src">@src</link></code>, then the claim is restricted
                  only to the specific sources.</para>
               <para>A <code><link linkend="element-subject">&lt;subject></link></code> or
                        <code><link linkend="element-object">&lt;object></link></code> that points
                  to a work or source may be further restricted with <code><link
                        linkend="attribute-ref">@ref</link></code>, <code><link
                        linkend="element-tok">&lt;tok></link></code>, <code><link
                        linkend="attribute-val">@val</link></code>, <code><link
                        linkend="attribute-pos">@pos</link></code>, and <code><link
                        linkend="attribute-chars">@chars</link></code>, following the conventions
                  used in pointing to parts of texts (see <xref xlink:href="#pointer-syntax"
                  />).</para>
               <para>If a <code><link linkend="element-subject">&lt;subject></link></code> or
                        <code><link linkend="element-object">&lt;object></link></code> points to a
                  scriptum, the claim can be restricted. However, if the scriptum is not defined by
                  a TAN-T source, then its location must be restricted through descendant
                        <code><link linkend="element-div">&lt;div></link></code>s that specify
                  through <code><link linkend="attribute-n">@n</link></code> and <code><link
                        linkend="attribute-type">@type</link></code> a specific place on the
                  scriptum. These scriptum filters, unlike TAN-T <code><link linkend="element-div"
                        >&lt;div></link></code>s, are always empty; their sole purpose is to provide
                  specificity.</para>
               <para>Multiple values in any component of a <code><link linkend="element-claim"
                        >&lt;claim></link></code> are distributed, which means that a <code><link
                        linkend="element-claim">&lt;claim></link></code> might carry within it
                  multiple assertions. For example, <code>&lt;claim subject="A B" verb="taught
                     promoted" object="X Y Z"/></code> has within it twelve claims (the combinatory
                  permutations of the three attributes). The exception to this general rule is
                        <code><link linkend="attribute-adverb">@adverb</link></code>, whose multiple
                  values are taken as ampliative and restrictive. For example, <code>&lt;claim
                     subject="A" adverb="probably not" verb="taught" object="X"/></code> is a single
                  claim, not two.</para>
               <para>A limited set of verbs have been defined in standard TAN vocabulary; see <xref
                     xlink:href="#vocabularies-verbs"/>. The strictures defined in these verbs will
                  be checked during Schematron validation.</para>
            </section>
         </section>
         <section xml:id="tan-a-tok">
            <title>Token-Based Annotations and Alignments (<code><link linkend="element-TAN-A-tok"
                     >&lt;TAN-A-tok></link></code>)</title>
            <para>TAN-A-tok files provide a microscopic view of how two sources relate to each
               other. The format is intended to allow you to specify exactly where, how, and why two
               transcriptions align, and to do so on the most granular level possible. TAN-A-tok
               files also allow you to express levels of confidence or alternative opinions.</para>
            <para>Creators and editors of TAN-A-tok files should be able to read the languages of
               their sources and to explain as precisely as possible the relationship between the
               two sources. They should be prepared to think about and specify types of textual
               reuse. TAN-A-tok files tend to be more demanding to create and edit than TAN-A files
               are because of the level of detail involved. The work is more time-consuming than
               simple <emphasis>en masse</emphasis> source alignment.</para>
            <para>Because of the detailed nature of the inquiry, token alignment is restricted to
               two texts, referred to jointly as a <emphasis role="italic">bitext</emphasis>. Each
               half of the bitext must be a TAN-T(EI) file. It is assumed that those two sources
               share some special relationship, direct or indirect, and relate through one or more
               types of textual reuse: translation, paraphrase, commentary, and so forth. Some of
               these bitexts, such as literal translations, may line up quite nicely word for word.
               Others, such as paraphrases, may line up sporadically, vaguely, ambiguously, or, in
               places, not at all. So annotating a bitext is oftentimes not easy, and requires you
               to think hard about assumptions you have made in two key areas: the relationship that
               holds between two scripta and the types of reuse that was involved in turning one
               version into the other (or a common ancestor into both).</para>
            <para><emphasis role="bold">Relationship of sources' scripta</emphasis>. What is the the
               physical relationship or history that connects the two sources' scripta? Is one a
               direct descendant (copy) of the other? If not, what common ancestor do they share?
               Here you consider the material aspect of the bitext, because you are trying to answer
               how object A's text relates to object B's. See <xref
                  xlink:href="#vocabularies-bitext-relations"/>.</para>
            <para><emphasis role="bold">Types of reuse</emphasis>. What categories of text reuse do
               you consider operative? Such a declaration tells users of your data what paradigm you
               bring to your analysis. You may wish to keep your categories nondescript and somewhat
               vague, using loosely defined concepts such as <emphasis>translation</emphasis>,
                  <emphasis>paraphrase</emphasis>, <emphasis>quotation</emphasis>, and so forth
               without much specificity. On the other hand, you may subscribe to a detailed view of
               text reuse. Perhaps you have adopted field-specific categories such as
                  <emphasis>obligatory explicitation</emphasis>, <emphasis>optional
                  explicitation</emphasis>, <emphasis>pragmatic explicitation</emphasis>, or
                  <emphasis>translation-inherent explicitation</emphasis>. You may also wish to
               declare secondary types of reuse, such as <emphasis role="italic">scribal
                  omission</emphasis> or <emphasis role="italic">dittography</emphasis>, to declare
               secondary types of reuse that may have intervened. You must declare at least one type
               of reuse. Or you may use those that are built into the TAN format. See <xref
                  xlink:href="#vocabularies-reuse-types"/>.</para>
            <section>
               <title>Root Element and Header</title>
               <para>The root element of a token-based alignment file is <code><link
                        linkend="element-TAN-A-tok">&lt;TAN-A-tok></link></code>.</para>
               <para>The TAN-A-tok header builds upon the core and class 2 headers (see <xref
                     linkend="metadata_head"/> and <xref linkend="class_2_metadata"/>).</para>
               <para>TAN-A-tok files take exactly two <code><link linkend="element-source"
                        >&lt;source></link></code>s. The sequence is arbitrary. Each <code><link
                        linkend="element-source">&lt;source></link></code> must take an <code><link
                        linkend="attribute-xmlid">@xml:id</link></code>.</para>
               <para><code><link linkend="element-vocabulary-key">&lt;vocabulary-key></link></code>
                  takes, in addition to all the elements allowed in class 2 files (see <xref
                     linkend="class_2_metadata"/>), two elements unique to TAN-A-tok: <code><link
                        linkend="element-bitext-relation">&lt;bitext-relation></link></code> and
                        <code><link linkend="element-reuse-type">&lt;reuse-type></link></code>. The
                  former describes the genealogical relationship between each source's scripta. The
                  second attends to the qualitative aspect of the bitext relationship.</para>
            </section>
            <section>
               <title>Data (<code><link linkend="element-body">&lt;body></link></code>)</title>
               <para>The <code><link linkend="element-body">&lt;body></link></code> of a TAN-A-tok
                  file takes, in addition to the customary optional attributes (see <xref
                     linkend="edit_stamp"/>), required <code><link
                        linkend="attribute-bitext-relation">@bitext-relation</link></code> and
                        <code><link linkend="attribute-reuse-type">@reuse-type</link></code>, which
                  take one or more id references from <code><link linkend="element-bitext-relation"
                        >&lt;bitext-relation></link></code> and <code><link
                        linkend="element-reuse-type">&lt;reuse-type></link></code>, indicating the
                  default values that govern the alignment. </para>
               <para><code><link linkend="element-body">&lt;body></link></code> has only one type of
                  child: one or more <code><link linkend="element-align">&lt;align></link></code>s,
                  each of which collects sets of <code><link linkend="element-tok"
                     >&lt;tok></link></code>s from one or both sources, known collectively as a
                     <emphasis role="italic">token cluster</emphasis>. Clusters may overlap, to
                  handle translations in which words fall in one-to-one, one-to-many, many-to-one,
                  and many-to-many relationships. The independence of token clusters allows you to
                  register differences of opinion about the same set of tokens. An <code><link
                        linkend="element-align">&lt;align></link></code> may take an <code><link
                        linkend="attribute-xmlid">@xml:id</link></code>, in case you or someone else
                  wishes to refer to a particular <code><link linkend="element-align"
                        >&lt;align></link></code>.</para>
               <para>Nothing should be inferred from silence in a TAN-A-tok file. Unmentioned tokens
                  in either source do not represent gaps in a translation. All that can be inferred
                  is that the creators and editors of the TAN-A-tok file have said nothing about the
                  tokens. </para>
               <para>If you wish to declare that one or more words in one source were left out of a
                  translation or inserted into one—that is, words in one source have no match in the
                  other—you must do so through a <emphasis role="italic">half-null
                     alignment</emphasis>, i.e., a token cluster that has tokens from only one
                  source. A half-null alignment implies insertions or omissions.</para>
               <para>A fully aligned bitext may result in a TAN-A-tok file with a very long
                        <code><link linkend="element-body">&lt;body></link></code>. That does not
                  mean, however, that everything in a source <emphasis>must </emphasis>be encoded or
                  described. In writing and editing a TAN-A-tok file you do not commit yourself to
                  saying everything possible about the bitext. You might choose to encode only a few
                  token clusters.</para>
               <para>If there are multiple IDs in <code><link linkend="attribute-reuse-type"
                        >@reuse-type</link></code> or <code><link
                        linkend="attribute-bitext-relation">@bitext-relation</link></code>, the
                  intersection, not the union, of those values is to be understood. For example,
                     <code>reuse-type="trans para"</code> would indicate that the token cluster
                  results from an activity that can be described as both translation and paraphrase.
               </para>
            </section>
         </section>
         <section xml:id="tan-a-lm">
            <title>Lexico-Morphology</title>
            <para>TAN-A-lm files are used to associate words or word fragments with lexemes and
               morphological categories. </para>
            <para>These files have two kinds of dependencies: a class 1 source (optional) and the
               grammatical rules defined in one or more TAN-mor files. This section therefore should
               be read in close conjunction with its companion: <xref linkend="TAN-mor"/>).</para>
            <section>
               <title>Principles and Assumptions</title>
               <para>Editors of TAN-A-lm files should understand the vocabulary and grammar of the
                  languages of their sources. They should have a good sense of the rules established
                  by the lexical and grammatical authorities adopted. They should be familiar with
                  the conventions and assumptions of the TAN-mor files being used.</para>
               <para>Although you must assume the point of view of a particular grammar and lexicon,
                  you need not hold to a single one. In addition, you may bring to lexical analysis
                  your own expertise and supply lexical headwords unattested in published
                  authorities.</para>
               <para>Although TAN-A-lm files are simple, they can be laborious to write and edit,
                  more than any other type of TAN files. They can also be hard to read if the
                  underlying TAN-mor files use cryptic codes. It is customary for an editor of a
                  TAN-A-lm file to use tools to create and edit the data.</para>
            </section>
            <section>
               <title>Root Element and Header</title>
               <para>The root element of a lexico-morphological file is TAN-A-lm.</para>
               <para>TAN-A-lm files are either source-specific or language-specific. In the case of
                  the former, <code><link linkend="element-source">&lt;source></link></code> points
                  to the one and only TAN-T(EI) file that is the object of analysis. In the case of
                  the latter, <code><link linkend="element-for-lang">&lt;for-lang></link></code> is
                  used in the declarations section of the <code><link linkend="element-head"
                        >&lt;head></link></code> to indicate the languages that are covered. For
                  language-specific TAN-A-lm files, this part of the <code><link
                        linkend="element-head">&lt;head></link></code> may also include <code><link
                        linkend="element-tok-starts-with">&lt;tok-starts-with&gt;</link></code> and
                        <code><link linkend="element-tok-is">&lt;tok-is&gt;</link></code>, which
                  improve performance of large files.</para>
               <para><code><link linkend="element-vocabulary-key">&lt;vocabulary-key></link></code>
                  takes the elements common to class 2 files (see <xref linkend="class_2_metadata"
                  />. It takes two other elements unique to TAN-A-lm: <code><link
                        linkend="element-lexicon">&lt;lexicon></link></code> (optional) and
                        <code><link linkend="element-morphology">&lt;morphology></link></code>
                  (mandatory). Any number of lexica and morphologies may be declared; the order is
                  inconsequential. </para>
               <para>There is, at present, no TAN format for lexica and dictionaries, although this
                  may change in the future. So even if a digital form of a dictionary is identified
                  through the <xref linkend="digital_entity_metadata"/>, the Schematron validation
                  routine does not attempt to check the TAN-A-lm data against the authorities cited. </para>
               <para>Because you or other TAN-A-lm editors are likely to be authorities in your own
                  right, <code><link linkend="element-person">&lt;person&gt;</link></code> can be
                  treated as if a <code><link linkend="element-lexicon">&lt;lexicon></link></code>,
                  and be referred to by <code><link linkend="attribute-lexicon"
                     >@lexicon</link></code> in the <code><link linkend="element-body"
                        >&lt;body&gt;</link></code> .</para>
            </section>
            <section>
               <title>Data (<code><link linkend="element-body">&lt;body></link></code>)</title>
               <para>The <code><link linkend="element-body">&lt;body></link></code> of a TAN-A-lm
                  file takes, in addition to the customary optional attributes found in other TAN
                  files (see <xref linkend="edit_stamp"/>), <code><link linkend="attribute-lexicon"
                        >@lexicon</link></code> and <code><link linkend="attribute-morphology"
                        >@morphology</link></code>, to specify the default lexicon and
                  grammar.</para>
               <para><code><link linkend="element-body">&lt;body></link></code> has only one type of
                  child: one or more <code><link linkend="element-ana">&lt;ana></link></code>s
                  (short for analysis), each of which matches one or more tokens (<code><link
                        linkend="element-tok">&lt;tok&gt;</link></code>) to one or more lexemes or
                  morphological assertions (<code><link linkend="element-lm"
                     >&lt;lm&gt;</link></code>, which takes <code><link linkend="element-l"
                        >&lt;l&gt;</link></code>s and <code><link linkend="element-m"
                        >&lt;m&gt;</link></code>s). </para>
               <para>An <code><link linkend="element-ana">&lt;ana></link></code> may take a
                        <code><link linkend="attribute-tok-pop">@tok-pop</link></code>, to specify
                  the number of tokens upon which the assertion is based. This is particularly
                  helpful for language-specific datasets, where the underlying data for the
                  assertion might not be retrievable.</para>
               <para>If due to tokenization a linguistic token must occupy more than one <code><link
                        linkend="element-tok">&lt;tok></link></code>, you may use <code><link
                        linkend="element-group">&lt;group></link></code> to group <code><link
                        linkend="element-tok">&lt;tok></link></code>s together. </para>
               <para>Claims within an <code><link linkend="element-ana">&lt;ana&gt;</link></code>
                  are distributed. That is, every combination of <code><link linkend="element-l"
                        >&lt;l&gt;</link></code> and <code><link linkend="element-m"
                        >&lt;m&gt;</link></code> (governed by <code><link linkend="element-lm"
                        >&lt;lm&gt;</link></code>) is asserted to be true for every <code><link
                        linkend="element-tok">&lt;tok></link></code>. </para>
               <para>Many TAN-A-lm files will be populated by a stylesheet or other algorithm that
                  automatically lists all possible morphological values of each token. It is advised
                  that such automatically calculated results always include <code><link
                        linkend="attribute-cert">@cert</link></code>, with weighted values. That is,
                  if an algorithm identifies a word as being one of two possibilities, but one
                  occurs nine times more than the other, then it is advised that this be reflected
                  in the two resultant elements, e.g.: <code>&lt;lm cert="0.9">...&lt;/lm></code>
                  and <code>&lt;lm cert="0.1">...&lt;/lm></code>. If an algorithm is written with a
                  more sophisticated way to weight possibilities, that is fine. Be certain that the
                        <code><link linkend="element-algorithm">&lt;algorithm&gt;</link></code> is
                  identified in the <code><link linkend="element-vocabulary-key"
                        >&lt;vocabulary-key></link></code>.</para>
            </section>
         </section>
      </chapter>
      <chapter xml:id="class_3">
         <title>Class-3 TAN Files, Varia</title>
         <para>This chapter provides general background to class 3 TAN files, which are devoted to
            formats that do not fit the other two classes. For detailed discussion of specific
            elements and attributes, see <xref linkend="elements-attributes-and-patterns"/>.</para>
         <section xml:id="TAN-voc">
            <title>Vocabulary (<code>TAN-voc</code>)</title>
            <para>All too often, a project has a set of vocabulary it draws from time and again. To
               repeat the <xref xlink:href="#pattern-iri_and_name"/> can be both tedious and
               treacherous. If a project with hundreds of TAN files decides to change or augment its
               vocabulary it could take a long time to find and make all the changes if the
               vocabulary is spelled out everywhere.</para>
            <para>The TAN-voc format addresses that problem. It is intended to allow a project to
               define, edit, and develop the IRI + name patterns for recurrent vocabulary. TAN has a
               number of TAN-voc files built into the system, identifying concepts commonly used for
                     <code><link linkend="element-token-definition"
                  >&lt;token-definition></link></code>, <link linkend="element-div-type"
                     ><code>&lt;div-type></code></link>s, and many more. For a complete list of
               predefined TAN keywords, see <xref linkend="vocabularies-master-list"/></para>
            <para>It is quite common for a person or team to build vocabulary items in the course of
               work, which means that TAN-voc files tend to be subject change during the life of the
               project. You can organize your vocabulary in whatever manner makes sense. You might
               create one large TAN-voc file for all vocabulary or one file per type of vocabulary,
               each independent of the other. Each of these has drawbacks, particularly the latter,
               which requires one <code><link linkend="element-vocabulary"
                  >&lt;vocabulary&gt;</link></code> per invoked TAN-voc file. The best approach we
               have found is to have one relatively small master TAN-voc file, say for persons, and
               then populate that with one &lt;inclusion> per extra TAN-voc file, then put in the
                     <code><link linkend="element-body">&lt;body></link></code> a <code>&lt;group
                  include="[IDREFS]"/></code> or <code>&lt;item include="[IDREFS]"/></code>.</para>
            <para>For more details on how this format relates to other TAN formats, see <xref
                  linkend="inclusions-and-vocabularies"/>.</para>
            <section>
               <title>Root Element and Head</title>
               <para>A TAN-voc file has <code><link linkend="element-TAN-voc"
                     >&lt;TAN-voc&gt;</link></code> as the root element.</para>
               <para>The <code><link linkend="element-vocabulary-key"
                     >&lt;vocabulary-key></link></code> of a TAN-voc file will be empty, or have
                        <code><link linkend="element-group-type">&lt;group-type&gt;</link></code>s.
                  A TAN-voc file may draw from the vocabulary defined in its body.</para>
            </section>
            <section>
               <title>Data (<code><link linkend="element-body">&lt;body></link></code>)</title>
               <para>The <code><link linkend="element-body">&lt;body></link></code> of a TAN-voc
                  file consists simply of <code><link linkend="element-item"
                     >&lt;item&gt;</link></code>s or <code><link linkend="element-verb"
                        >&lt;verb&gt;</link></code>s, perhaps gathered into groups via <code><link
                        linkend="element-group">&lt;group&gt;</link></code> or <code><link
                        linkend="attribute-group">@group</link></code>. These groups have, at
                  present, no effect upon other TAN files that import them. They have been useful,
                  however, in more advanced uses of the format, particularly in the case of the
                  standard TAN-voc file for <code><link linkend="element-div-type"
                        >&lt;div-type&gt;</link></code> (<link
                     xlink:href="../TAN-voc/div-types.TAN-voc.xml"/>), where common types of
                  divisions have been given a rudimentary typology suitable for transformations into
                  other formats.</para>
               <para>The <code><link linkend="attribute-affects-attribute"
                     >@affects-attribute</link></code> or <code><link
                        linkend="attribute-affects-element">@affects-element</link></code>, an
                  inheritable attribute, defines the scope of the vocabulary items, i.e., what
                  elements or attributes can the items be legitimately used for. That way you can
                  have vocabulary items for non-overlapping element with duplicate <code><link
                        linkend="element-name">&lt;name&gt;</link></code>s.</para>
               <para>Most frequently, a TAN-voc file will contain items that have the IRI + name
                  pattern. The only exception is when it contains <code><link
                        linkend="element-token-definition">&lt;token-definition&gt;</link></code>s.
                        <code><link linkend="element-verb">&lt;verb&gt;</link></code> includes, in
                  addition to the IRI + name pattern, the option to have <code><link
                        linkend="element-constraints">&lt;constraints&gt;</link></code> added. Those
                  constraints define what components are permitted in any <code><link
                        linkend="element-claim">&lt;claim&gt;</link></code> that uses the
                        <code><link linkend="element-verb">&lt;verb&gt;</link></code>.</para>
            </section>
         </section>
         <section xml:id="TAN-mor">
            <title>Morphological Concepts and Patterns (<code>TAN-mor</code>)</title>
            <para>TAN-mor files are used to describe the grammatical morphological characteristics
               or features of a given language, to assign codes to those features, and to define
               rules governing the application of those codes. The format allows specificity,
               flexibility, and responsiveness. Assertions in the format may be doubted, rules may
               be expressed as contingent upon other conditions, and warnings and error messages may
               be sent to users who have used a pattern incorrectly, or not in accordance with best
               practices.</para>
            <para>The TAN-mor format is a kind of Schematron for the grammar of human languages. You
               specify the categories and codes for a given language, then you may create tests to
               define invalid uses of those codes. Those tests are attached to reports and
               assertions allowing editors of TAN-A-lm files to see not only if the rules have been
               violated, but why, and exactly where.</para>
            <para>This chapter should be read in close conjunction with <xref linkend="tan-a-lm"
               />.</para>
            <section>
               <title>Principles and Assumptions</title>
               <para>Certain assumptions and recommendations are made regarding morphology files,
                  complementing the more general ones; see <xref linkend="design_principles"
                  />.</para>
               <para>TAN-mor files are restricted exclusively to describing the categories and rules
                  for the grammar of a natural language. Editors of these files should be well
                  versed with the grammar of the languages they are describing.</para>
               <para>The TAN-mor format has been designed with the assumption that patterns of word
                  inflection and formation can be categorized, classified, named, and described. It
                  has also been assumed that scholars may reasonably differ, perhaps radically, on
                  how categories should be defined and applied. TAN-mor allows scholars to declare
                  clearly their operative assumptions and views. It is up to other users to decide
                  whether or not to adopt them.</para>
               <para>The TAN-mor format has also been designed to cater to two different approaches
                  to morphological codes: categorized or uncategorized. </para>
               <para>A categorized codes is one where a particular code component might get
                  repeated, and understanding the meaning depends upon the position of the code
                  component. For example, the categorized codes adopted by Perseus for morphological
                  analysis of Greek, Latin, and other highly inflected languages stipulate ten
                  categories, with the first two being the major and minor parts of speech, and the
                  subsequent categories devoted to person, number, tense, and so forth. Each word
                  that is analyzed must have a value, even if null, and the position of the code is
                  important. A <code>d</code> in one spot means something different from a
                     <code>d</code> in another.</para>
               <para>Uncategorized codes simply give each each grammatical feature a unique code, to
                  be applied in any permitted sequence and combination. This approach is viable for
                  any language (including highly inflected ones such as Greek or Latin), but it is
                  most often found in tagging sets for languages that are not highly inflected,
                  e.g., the Brown and Penn sets for English.</para>
               <para>Morphological codes are case insensitive. <code>NOUN</code> and
                     <code>noun</code> will be treated as being identical.</para>
            </section>
            <section>
               <title>Root Element and Header</title>
               <para>The root element of a morphological rule file is <code><link
                        linkend="element-TAN-mor">&lt;TAN-mor></link></code>.</para>
               <para>Zero or more <code><link linkend="element-source">&lt;source></link></code>
                  elements describe the grammars or related works that account for the morphological
                  rules. If they are not based upon any published work, then <code><link
                        linkend="element-source">&lt;source></link></code> may be omitted. Any
                  TAN-mor file without a source will assume to be based upon the personal knowledge
                  of the persons or organizations identified in <code><link
                        linkend="element-file-resp">&lt;file-resp&gt;</link></code>.</para>
               <para><code><link linkend="element-vocabulary-key">&lt;vocabulary-key></link></code>
                  is populated with the grammatical <link linkend="element-feature"
                        ><code>&lt;feature></code></link>s that are considered operative. If a
                  particular discipline customarily uses codes that are not allowed in <code><link
                        linkend="attribute-xmlid">@xml:id</link></code>, you may wish to create an
                        <code><link linkend="element-alias">&lt;alias&gt;</link></code>. </para>
            </section>
            <section>
               <title>Data (<code><link linkend="element-body">&lt;body></link></code>)</title>
               <para>The <code><link linkend="element-body">&lt;body></link></code> of a TAN-mor
                  file takes the customary optional attributes found in other TAN files (see <xref
                     linkend="edit_stamp"/>). </para>
               <para>The children of <code><link linkend="element-body">&lt;body></link></code>
                  begin with one or more <code><link linkend="element-for-lang"
                     >&lt;for-lang></link></code>s, followed by any number of <code><link
                        linkend="element-where">&lt;where&gt;</link></code>s (containing <code><link
                        linkend="element-assert">&lt;assert></link></code>s or <code><link
                        linkend="element-report">&lt;report></link></code>s) or <code><link
                        linkend="element-category">&lt;category></link></code>s (if relying upon
                  structured codes). </para>
               <para><code><link linkend="element-category">&lt;category></link></code>, used for
                  structured codes, sorts <link linkend="element-feature"
                     ><code>&lt;feature></code></link>s into groups, assigning them <code><link
                        linkend="attribute-code">@code</link></code> values that are unique within
                  the <code><link linkend="element-category">&lt;category></link></code>.</para>
               <para><code><link linkend="element-assert">&lt;assert></link></code>s and <code><link
                        linkend="element-report">&lt;report></link></code>s are used to declare
                  rules that must be followed, or must never be followed, by any dependent TAN-A-lm
                  file. </para>
               <para>An <code><link linkend="element-assert">&lt;assert></link></code> and
                        <code><link linkend="element-report">&lt;report></link></code> will be
                  checked only if the conditions in the enclosing <code><link
                        linkend="element-where">&lt;where&gt;</link></code> are met in the context
                  of a given <code><link linkend="element-m">&lt;m></link></code> in a dependent
                  TAN-A-lm file:</para>
               <para>
                  <itemizedlist>
                     <listitem>
                        <para><code><link linkend="attribute-m-matches">@m-matches</link></code>:
                                 <code><link linkend="element-m">&lt;m></link></code> matches the
                           pattern (regular expression). </para>
                     </listitem>
                     <listitem>
                        <para><code><link linkend="attribute-tok-matches"
                           >@tok-matches</link></code>: one of the values of <code><link
                                 linkend="element-tok">&lt;tok></link></code> in the given
                                 <code><link linkend="element-ana">&lt;ana&gt;</link></code> matches
                           the pattern (regular expression).</para>
                     </listitem>
                     <listitem>
                        <para><code><link linkend="attribute-m-has-features"
                              >@m-has-features</link></code>: <code><link linkend="element-m"
                                 >&lt;m></link></code> has the specified features.</para>
                     </listitem>
                     <listitem>
                        <para><code><link linkend="attribute-m-has-how-many-features"
                                 >@m-has-how-many-features</link></code>: <code><link
                                 linkend="element-m">&lt;m></link></code> has the given number of
                           features.</para>
                     </listitem>
                  </itemizedlist>
               </para>
               <para>An <code><link linkend="element-assert">&lt;assert></link></code> also has one
                  or more of the truth conditions above. If the test proves false in a given
                        <code><link linkend="element-m">&lt;m></link></code> then the <code><link
                        linkend="element-m">&lt;m></link></code> will be marked as erroneous and the
                  message included by the <code><link linkend="element-assert"
                     >&lt;assert></link></code> should be returned.</para>
               <para><code><link linkend="element-report">&lt;report></link></code> has the same
                  effect, but the role of the test is the opposite: the error and message will be
                  returned only if the test proves true.</para>
            </section>
         </section>
         <section xml:id="catalog-files">
            <title>TAN Catalog Files (<code>collection</code>)</title>
            <para>TAN catalog files are intended to facilitate the discovery of relevant TAN files
               and to support the XSLT function <code>collection()</code>. They catalog or index any
               or all TAN files within a local directory and perhaps its subdirectories. </para>
            <para>These catalog files must always be named <code>catalog.tan.xml</code>. They depart
               from all other TAN files in their structure. They have no namespace. They have
               neither body nor head. Rather, they are patterned off the catalog.xml description
               provided by Saxonica (<link
                  xlink:href="https://www.saxonica.com/documentation9.5/sourcedocs/collections.html"
               />).</para>
            <para>Any XML file passed to the stylesheet <code>/applications/populate/populate TAN
                  catalog file.xsl</code> will automatically generate one of these files.</para>
            <para>The root element of a catalog file is <code><link linkend="element-collection"
                     >&lt;collection></link></code>, with children <code><link linkend="element-doc"
                     >&lt;doc></link></code>s that hold simple metadata about the TAN files that are
               in a directory and its subdirectories. Only TAN files may be registered in a
                     <code><link linkend="element-doc">&lt;doc></link></code>. A <code><link
                     linkend="element-doc">&lt;doc></link></code> may include other material such as
               each file's resolved <code><link linkend="element-head">&lt;head></link></code>, but
               this is not mandated.</para>
         </section>
      </chapter>
   </part>
   <part xml:id="working_with_tan">
      <title>Working with the Text Alignment Network</title>
      <chapter>
         <title>Best Practices in Working with TAN Files</title>
         <para>In this chapter we discuss ways to manage, create, edit, and share TAN files. The
            material discussed here is non-normative. That is, these are suggestions based upon the
            experience of TAN users. </para>
         <para>Descriptions in this chapter are both general and terse. To understand better the
            underlying framework, study the files in the subdirectory <code>/functions</code>, which
            have been reformatted in the chapter <xref
               xlink:href="#variables-keys-functions-and-templates"/>. </para>
         <section xml:id="local_setup">
            <title>Local Setup</title>
            <para>TAN files may be set up in any kind of structure one wishes, but because those
               files are meant to be shared and interlinked, it is beneficial to use consistent
               conventions. In the previous version of TAN, advice was given on directory structures
               and file organization. Experience has shown that even sound suggestions in this area
               are hard to come by. It is common to set up a TAN library in a subdirectory that is a
               sibling to the master TAN files, but this arrangement should not dictate how you
               arrange your digital resources.</para>
            <para>If you use an advanced XML editor such as oXygen, you can set up a project so that
               TAN validation files can be easily located. A sample oXygen project file is included
               to get you started. You may wish to create a copy of that project file for yourself
               before developing it.</para>
            <para>TAN also include select oXygen frameworks files, which provides editing tools for
               oXygen's Author mode.</para>
            <para>Both the project file and the frameworks files are in their early infancy. They
               have tremendous potential for development, slated for future versions of TAN.</para>
            <para>When you name class 1 files (the filename, not the <code><link
                     linkend="attribute-id">@id</link></code>; see <xref xlink:href="#tan-file-id"
               />), it is a good idea to start with an acronym or abbreviation for the work,
               followed by the language code, the last name of the editor/author of the scriptum,
               the date when the scriptum was created or published. If a work lends itself to
               multiple reference schemes, you may need to include that in the filename. Some examples:<itemizedlist>
                  <listitem>
                     <para><code>ar.cat.grc.1949.minio-paluello.ref-logical.xml</code> (Aristotle's
                        Categories, in Greek, 1949, edition by Minio Paluello, following a reference
                        system based on semantic units [paragraphs, sentences, independent
                        clauses]).</para>
                  </listitem>
                  <listitem>
                     <para><code>apocr.eng.kjv.1760.xml</code> (apocrypha, English, King James
                        Version, 1760 edition)</para>
                  </listitem>
                  <listitem>
                     <para><code>tlg0059.tlg031.perseus-grc1-Pl.Ti.xml</code> (Plato's
                           <emphasis>Timaeus</emphasis> in Greek)</para>
                  </listitem>
               </itemizedlist></para>
            <para>Class 2 files are tougher. Because they bring two or more files or concepts
               together, filenames could become very long or unpredictably structured. At this time,
               the best recommendation is to make sure that each class 2 file is put into a
               subdirectory, separate from class 1 files, given a brief but meaningful name that
               points to the research question that motivated its creation. Some examples:<itemizedlist>
                  <listitem>
                     <para><code>ar.cat.grc.1949.minio-paluello-sem-TAN-LM-sample.xml</code> (a
                        sample of lexico-morphological data for Aristotle's
                           <emphasis>Categories</emphasis>, in Greek)</para>
                  </listitem>
                  <listitem>
                     <para><code>nt.grc-syr.selections.TAN-A-tok.xml</code> (word-for-word
                        correspondences between the Syriac and Greek New Testaments)</para>
                  </listitem>
                  <listitem>
                     <para><code>plato.TAN-A.xml</code> (a general alignment and annotation file on
                        Plato's works)</para>
                  </listitem>
               </itemizedlist></para>
            <para>Class 3 filenames are a bit easier. It is recommended that TAN-mor files begin
               with the language code then an acronym for the person or group responsible for
               creating the features. TAN-voc files are written generally to serve a specific
               project or collection, so the collection name and the TAN type should suffice. Examples:<itemizedlist>
                  <listitem>
                     <para><code>ar.cat.TAN-voc.xml</code></para>
                  </listitem>
                  <listitem>
                     <para><code>eng.kalvesmaki.com,2014.1.xml</code> (tagging scheme #1 for
                        English)</para>
                  </listitem>
               </itemizedlist></para>
            <para>If you have a local copy of someone else's TAN collection, and you wish to create
               TAN files that depend on them, you are in all likelihood going to use relative URLs
               to copies of the files stored on your local drive. It is recommended that you also
               point to the master versions hrough absolute URLs in post-initial <code><link
                     linkend="element-location">&lt;location></link></code>s. The validation routine
               checks only the first document available. From time to time, you might comment out
               the first <code><link linkend="element-location">&lt;location></link></code> and run
               the validation process again. This will tell you if there have been any updates since
               you last accessed the file. </para>
            <para>In a given project, you are likely to repeat basic information, particularly
                     <code><link linkend="element-person">&lt;person></link></code>, <code><link
                     linkend="element-role">&lt;role></link></code>, and <code><link
                     linkend="element-work">&lt;work&gt;</link></code>. such as elements with the
                  <xref linkend="pattern-iri_and_name"/>, consider moving those to a TAN-voc file.
               It is almost always preferable to develop TAN-vocs before resorting to <code><link
                     linkend="element-inclusion">&lt;inclusion></link></code>s. Sorting out lines of
               inclusion can be confusing.</para>
         </section>
         <section>
            <title>Creating and populating TAN files</title>
            <para>TAN is a representational format. Every TAN file models some source.</para>
            <para>If those sources are non-digital, it is a relatively straightforward task to
               create and populate a TAN file. You just start editing everything by hand. In some
               cases, you might get a head start through a rough computer algorithm. For example,
               optical character recognition (OCR) on an edition might give you a dirty but useful
               start for a TAN-T file. Or OCR on an index might get you the outlines of a TAN-A file
               that indexes all quotations. Despite the computer's assistance, the majority of the
               task is converting non-digital claims into digital ones, and manual effort is
               central.</para>
            <para>In many other cases, you are trying to take something that already exists
               digitally and convert it into a TAN format. In these cases, it is advised to think of
               the problem computationally, and try to build a system that gets the computer to
               bring the material into the TAN format. Such a pipeline will allow a workflow where
               any subsequent changes to a pre-TAN version can be piped into your TAN
               library.</para>
            <para>Suppose you find a Word file, a web page, or plain text that can serve as the
               basis for a TAN file. A common first impulse is to copy the desired content, paste it
               into the body of your TAN file, and then begin to manually correct and change things.
               You may find that you made a major mistake that cannot, at that point be undone.
               Perhaps you have accidentally deleted all punctuation when you didn't mean to. Or you
               eliminated line breaks that you didn't realize at the time were useful signals about
               where <code><link linkend="element-div">&lt;div></link></code>s should be separated.
               Even if all goes well, after all that hard work you might be find out that the
               pre-TAN data source has been updated, with errors corrected. If any significant time
               has elapsed, you may have forgotten what procedure you followed to convert the data.
               And even if you remember, you will have to repeat the steps again, and dread the day
               when the pre-TAN source is yet again updated. </para>
            <para>For all these reason, it is recommended that you set up an XSLT-based workflow to
               convert the data to TAN. When you find mistakes such as those described above, no
               harm is done. You can adjust your algorithm and re-run the process as often as you
               need, each time getting better and better results. This approach requires extra
               initial work. That is, you will need to get to know XSLT (or an alternative) well.
               Establishing a good transformation process can be time consuming. But the investment
               pays off in the long run. The routines you write for one set of files might be useful
               for the next.</para>
            <para>Under this method, you should begin the process by creating a template TAN file
               that resembles, even if skeletally, your desired output. You then write XSLT-based
               rules that (1) make alterations to the input, (2) infuse the altered input into the
               template, then (3) save the new file. This method has been used successfully to
               handle several different kinds of conversion, including ones where the source files
               are updated very frequently. In such cases, the traditional cut-paste-and-edit method
               is not only unproductive; it is foolish.</para>
            <para>Writing transformations may seem laborious at first. Finding the best way to
               handle and manipulate a pre-TAN file is an intellectual challenge with multiple
               solutions. But there is a good chance that the labor you have in mind has already
               been done for you in the built-in TAN functions (see <xref
                  xlink:href="#variables-keys-functions-and-templates"/>) or applications (see the
               subdirectory <code>/applications</code>).</para>
         </section>
         <section xml:id="validating_tan_files">
            <title>Validating TAN files</title>
            <para>TAN files are validated via TAN schemas. Validation can be set up either by
               pointing explicitly to the schemas within a TAN file, or by setting up an oXygen
               project or framework to automatically apply the schemas to TAN files. See <xref
                  xlink:href="#local_setup"/>. There are two types of TAN validation.</para>
            <para>Structural validation is conducted through RELAX-NG files that define the
               attributes, elements, and patterns that are required in a given TAN format. These
               files are kept in the <code>/schemas</code> project subdirectory. The RELAX-NG files
               are written principally in the compact syntax, then converted to XML syntax. The
               TAN-TEI format is an exception. The schema begins with the TAN-TEI.odd file that is
               in the schemas subdirectory. This file, linked as it is with the other RELAX-NG
               files, is processed by TEI stylesheets to generate the master TAN-TEI.rnc and
               TAN-TEI.rng files that are used pointed to by TAN-TEI files. This process is
               conducted against the most current version of TEI All, the largest set of TEI
               elements.</para>
            <para>The second type of validation uses Schematron to check rules that cannot be
               enforced on the RELAX-NG level, e.g., no <code><link linkend="attribute-when"
                     >@when</link></code> should have a date in the future. More than one hundred
               types of errors are prepared to be checked during Schematron validation. For a
               comprehensive list see <xref xlink:href="#errors"/>. Testing some of these errors can
               be quite taxing and time-consuming. For example, if a class-1 file has a <code><link
                     linkend="element-redivision">&lt;redivision&gt;</link></code>, the text should
               be identical. On short texts, the error can be checked in seconds; on longer texts
               the test might take minutes. Therefore Schematron validation allows three different
               levels: terse, normal, and verbose. The phase names reflect not only how fast each
               operation takes but how much feedback is provided.</para>
            <para>The Schematron file behind this routine is rather small. The majority of the work
               is done by a large library of XSLT code that marks errors and passes the results to
               the Schematron file. The background process is as critical component of many
               downstream applications of TAN files, so should be explained. Any TAN file that is
               processed goes through two major transformations.</para>
            <para>The first transformation <emphasis>resolves</emphasis> the file. The goal is to
               get the file into a state where it can be evaluated without having to consult any
                     <code><link linkend="element-vocabulary">&lt;vocabulary&gt;</link></code> or
                     <code><link linkend="element-inclusion">&lt;inclusion></link></code>
               dependencies. (See <xref xlink:href="#inclusions-and-vocabularies"/> for background
               on TAN's approach to inclusion.) This process also does some basic normalization
               specific to the file, including the following steps: <orderedlist>
                  <listitem>
                     <para>Prepare the file. This includes evaluating <code><link
                              linkend="element-alias">&lt;alias&gt;</link></code>, stamping the root
                        element with a base uri, and every element with a <code>@q</code> (an
                        arbitrary name), which contains a unique identifier. This identifier is used
                        by the Schematron file to find error messages.</para>
                  </listitem>
                  <listitem>
                     <para>Identify those nodes that need to be changed by <code><link
                              linkend="element-vocabulary">&lt;vocabulary&gt;</link></code> or
                              <code><link linkend="element-inclusion">&lt;inclusion></link></code>
                        dependencies.</para>
                  </listitem>
                  <listitem>
                     <para>Retrieve from the <code><link linkend="element-vocabulary"
                              >&lt;vocabulary&gt;</link></code>s or <code><link
                              linkend="element-inclusion">&lt;inclusion></link></code>s those
                        components that need to be inserted.<orderedlist numeration="loweralpha">
                           <listitem>
                              <para>All external vocabulary items are inserted into the <code><link
                                       linkend="element-head">&lt;head&gt;</link></code>, either as
                                 descendants of the appropriate <code><link
                                       linkend="element-vocabulary">&lt;vocabulary&gt;</link></code>
                                 or if derived from TAN standard vocabulary as new
                                    <code>&lt;tan-vocabulary></code> elements immediately following
                                 the <code><link linkend="element-vocabulary-key"
                                       >&lt;vocabulary-key></link></code>. All vocabulary items are
                                 imprinted with an <code>&lt;id></code>, to facilitate rapid
                                 retrieval of vocabulary. Any vocabulary <code><link
                                       linkend="element-name">&lt;name&gt;</link></code> that is not
                                 normalized is appended with a copy that is (signaled by
                                    <code>@norm</code>).</para>
                           </listitem>
                           <listitem>
                              <para>Any element with <code><link linkend="attribute-include"
                                       >@include</link></code> is replaced by the elements of the
                                 same name found in the target inclusion document. In addition,
                                       <code><link linkend="element-inclusion"
                                    >&lt;inclusion></link></code> is populated with any vocabulary
                                 items required to resolve the newly included material (with
                                 nesting, if that inclusion requires other inclusions). This last
                                 point is important, because the local conventions of a should first
                                 be interpreted locally. If a file makes <code>abc</code> the id of
                                 a <code><link linkend="element-person"
                                 >&lt;person&gt;</link></code>, but an included file makes it the id
                                 of a <code><link linkend="element-verb">&lt;verb&gt;</link></code>,
                                 you would get into a lot of problems if there were no
                                 differentiation.</para>
                           </listitem>
                        </orderedlist></para>
                  </listitem>
                  <listitem>
                     <para>Insert the new components.</para>
                  </listitem>
                  <listitem>
                     <para>Normalize all numeral systems into Arabic numerals.</para>
                  </listitem>
               </orderedlist></para>
            <para>Numerals fall at the end of the process because they must be resolved in light of
               a full set of vocabulary. Files are resolved recursively. That is, no <code><link
                     linkend="element-vocabulary">&lt;vocabulary&gt;</link></code> or <code><link
                     linkend="element-inclusion">&lt;inclusion></link></code> components are
               imported until the files pointed to are themselves first resolved.</para>
            <para>The description above of a resolved file is necessarily generalized. For details
               consult the function library, particularly
                  <code>/functions/incl/TAN-core-resolve-functions.xsl</code>. </para>
            <para>The second transformation <emphasis>expands</emphasis> the file. The goal is
               expand the components of a resolved document and identify any errors (see the <link
                  xlink:href="../functions/errors/TAN-errors.xml">master list of errors</link>).
               There are three levels of expansion, corresponding to the three levels of Schematron
               validation: terse, normal, and verbose.</para>
            <para>In terse expansion, each value of an attribute is copied into an element of the
               same name (e.g., two values of <code><link linkend="attribute-type"
                  >@type</link></code> become <code>&lt;type></code> and <code>&lt;type></code>). If
               the value is an ID ref, and it points to an alias, the value is converted into the
               indivdiual ID refs of the target vocabulary items. If an ID ref does not point to a
               vocabulary item of the expected type, an error message is also copied in the parent.
               Any values that are ranges are expanded, if need be. Select networked files are
               checked for basic validity. Class-2 files include a special set of rounds during
               terse validation, where their sources are adjusted, and then checked against specific
               references made in the class-2 file. (See <xref xlink:href="#pointer-syntax"/>.) In
               terse expansion, all pointing mechanisms are checked, to make sure they point to a
               valid value. Because of this basic requirement, some terse expansion can still take a
               long time on lengthy files, or ones with complex <code><link
                     linkend="element-adjustments">&lt;adjustments&gt;</link></code>.</para>
            <para>Normal expansion builds on terse expansion by interrogating networked files more
               closely. Any errors that were reported during the terse stage but were suppressed to
               avoid clutter are enabled. If a class-1 source of a class-2 file was only partially
               tokenized, to save on time, the rest of it is tokenized.</para>
            <para>Verbose expansion generally saves the most complex procedures. For example, a
                     <code><link linkend="element-model">&lt;model&gt;</link></code> of a class 1
               file will be checked, to see if there are divisions that one has that is lacking in
               the other. A class-1 <code><link linkend="element-redivision"
                     >&lt;redivision&gt;</link></code> will be analyzed, to make sure that the two
               transcriptions are identical. A catalog file in the same directory will be checked,
               to see if it has false entries.</para>
            <para>Along the way, some errors can be diagnosed for corrections. Some of these make
               there way into an expanded file through the error reports, and are returned by the
               Schematron file as Schematron Quick Fixes (SQF). XML editors that are equipped to
               handle SQFs can then prompt users for quick replacements. For example, if text has
               not been NFC Unicode-normalized, an SQF will allow a convenient, quick way to do so.
               Thus, TAN validation does not merely tell you what the problems are; it tries to help
               fix them.</para>
            <para>The description above of an expanded file is necessarily generalized. For details
               consult the function library, particularly
                  <code>/functions/incl/TAN-core-expand-functions.xsl</code>. </para>
            <para>Validation tests are run not only on the files in the <code>/examples</code>
               subdirectory, but upon the files in <code>/functions/errors</code>. The files there
               attempt to provide at least one example of every possible error, and evaluation is
               performed in reverse: file is valid if and only if every error has a corresponding
               preceding comment advertising the error.</para>
         </section>
         <section>
            <title>Sharing TAN files</title>
            <para>TAN files have been designed to be shared and linked, just like any network of
               files.  Most often, TAN files will be be created and distributed as collections, not
               single files.</para>
            <para>One way to distribute a collection is by making it available as a repository via
               Git or some other version control software (VCS). This approach has many advantages.
               The files become available to anyone who wants them, and the editorial history is
               preserved. VCS features and tools are extremely fast and useful, and they allow users
               to modify TAN collections without impacting the original source.</para>
            <para>Collections may also be distributed through shared syncing services (e.g., Drive,
               Box, or Dropbox). Or put on a server. In the latter case, it may be difficult for
               users to browse a collection. In that case, you may wish to expose the collection as
               a compressed ZIP archive. This saves on your server's bandwidth, and it still exposes
               the files for XML processing. But a ZIP archive is not suitable for linking from one
               TAN file to another, nor is it appropriate as a <code><link
                     linkend="element-master-location">&lt;master-location></link></code>. Unpacking
               a compressed file requires writing to the disk, which is treated as a security risk
               during validation, and so is disallowed. Such zipped archives are good ways to
               distribute a collection, but they should not be used as a primary repository.</para>
         </section>
         <section xml:id="tan-stylesheets-and-function-library">
            <title>Doing things with TAN files</title>
            <para>TAN files can be used in dozens of types of applications. The subdirectory
                  <code>/applications</code> is populated with folders named with actions you might
               want to perform on a TAN file, and they contain XSLT stylesheets that give you but a
               taste of what is possible. Because the applications in that directory are still under
               development, this section is devoted to some of the theory behind practical
               applications of TAN files. It is aimed particularly at those readers who are
               comfortable working with XSLT or related XML technologies.</para>
            <para>The Schematron validation process was designed with a view to the next steps in
               practical applications. The extensive function library upon which validation is based
               provides the foundation. When developing an application, the first point of order is
               normally to find an entry point in the <code>/functions</code> subdirectory to the
               TAN function library. Each XSLT file there is named after one of the formats. Point
               via <code>&lt;xsl:include></code> or <code>&lt;xsl:import></code> to the file that
               most resembles your main input. If you point to
                  <code>/functions/TAN-A-functions.xsl</code>, you will have most of the functions
               and templates used for both class-1 and class-2 files. It tends to be a good starting
               point if you are uncertain which to use.</para>
            <para>It is also common to include <code>/functions/TAN-extra-functions.xsl</code>,
               which is the entry point for all functions, global variables, and templates that have
               been developed for TAN but do not play a role in Schematron validation. Those extra
               functions include many global variables that would unnecessarily slow down Schematron
               validation.</para>
            <para>You should also pay attention to the values in <code>/parameters</code>. Some of
               the global parameters there can be used profitably to change the way an application
               runs.</para>
            <para>All XSLT transformations require four ingredients:<orderedlist>
                  <listitem>
                     <para>an input XML file</para>
                  </listitem>
                  <listitem>
                     <para>an XSLT file</para>
                  </listitem>
                  <listitem>
                     <para>a URL for the output</para>
                  </listitem>
                  <listitem>
                     <para>an XSLT engine (e.g., Saxon HE) to process #1 against #2 and send the
                        output to #3.</para>
                  </listitem>
               </orderedlist></para>
            <para>Although #1 is the principal or catalyzing input, it need not be the main input.
               Sometimes an XSLT is written with an eye toward non-XML as the main input, to be
               changed into XML. Furthermore, although there is one principal target for the output,
               there may be other documents that are created, through
                  <code>&lt;xsl:result-document></code>. Because there are really two possible types
               of input and output, we use the terms <emphasis>catalyzing input</emphasis> for #1
               and <emphasis>secondary input</emphasis> for input that comes along in the process,
               and <emphasis>primary output</emphasis> for #3 and <emphasis>secondary
                  output</emphasis> for any other output created along the way. The terms
                  <emphasis>primary</emphasis> and <emphasis>secondary</emphasis> refer only to
               their position in the process, not their importance. Indeed, there are XSLT
               applications where the secondary input and secondary output are far more important
               than the catalyzing input or primary output.</para>
            <para>When developing an application where a TAN file is the catalyzing input, it is
               often necessary to start with it in its resolved or expanded state. (See <xref
                  xlink:href="#validating_tan_files"/> on resolving and expanding TAN files.) Use
               the global variables <code><link linkend="variable-self-resolved"
                     >$self-resolved</link></code> and <code><link linkend="variable-self-expanded"
                     >$self-expanded</link></code>. </para>
            <para>For a class 2 file, <code><link linkend="variable-self-expanded"
                     >$self-expanded</link></code> becomes a sequence of documents, starting with an
               expansion of the class-2 file, and continuing with expansions of its dependencies
               (TAN-T or TAN-mor). The expanded class-1 sources will be tokenized where required,
               and marked with anchors indicating specifically where each reference in the class-2
               file applies. If a token straddles leaf <code><link linkend="element-div"
                     >&lt;div&gt;</link></code>s, it will be restored and placed at the end of the
               first leaf <code><link linkend="element-div">&lt;div&gt;</link></code>. These marked
               sources are excellent candidates for transforming for other purposes. For example,
               HTML pages can be created to link between class-2 annotations and class-1 sources, in
               a variety of ways.</para>
            <para>When taken to the verbose level, an expanded TAN-A file will conclude its
                     <code><link linkend="variable-self-expanded">$self-expanded</link></code>
               sequence with one or more documents with a root element
               <code>&lt;TAN-T_merge></code>, one file per detected work. A TAN-T_merge file has one
                     <code><link linkend="element-head">&lt;head&gt;</link></code> per class-1
               source that has been merged, and the <code><link linkend="element-body"
                     >&lt;body></link></code> contains a master set of <code><link
                     linkend="element-div">&lt;div&gt;</link></code>s that merge all the other
               sources' <code><link linkend="element-div">&lt;div&gt;</link></code>s. Each leaf
                     <code><link linkend="element-div">&lt;div&gt;</link></code> in each source
               appears in the appropriate place, but as a child, with @type changed to
                  <code>#version</code>, and other markers to signify which source it corresponds
               to. A TAN-T_merge is an appropriate basis from which to create editions of works with
               versions set in parallel. These files can be created on an ad hoc basis through the
               function <xref xlink:href="#function-merge-expanded-docs"/>.</para>
            <para>If you are fetching TAN files as secondary input, and you want to work with them,
               make use of the functions <xref xlink:href="#function-resolve-doc"/> and <xref
                  xlink:href="#function-expand-doc"/>, which will put the files in their resolved
               and expanded states. You must resolve a file before you try to expand it.</para>
            <para>If you wish to output a TAN file, you should probably prepare ahead of time a
               skeleton TAN file, make that skeleton secondary input, then infuse it with the values
               you intend, saving it as either primary or secondary output. Because the application
               you are using to create a TAN file is responsible for the file, the algorithm should
               be declared in the <code><link linkend="element-vocabulary-key"
                     >&lt;vocabulary-key></link></code> and credited with a <code><link
                     linkend="element-resp">&lt;resp></link></code>, and a <code><link
                     linkend="element-change">&lt;change></link></code> should be entered in the
               change log. Users of the file will be warned, during Schematron validation, that the
               last change was made by an algorithm. </para>
            <para>If you are working with a TAN file as catalyzing input, you may want to take
               advantage of global variables bound to networked files:</para>
            <para>
               <table frame="all">
                  <title>Global variables for networked files</title>
                  <tgroup cols="4">
                     <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                     <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                     <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                     <colspec colname="newCol4" colnum="4" colwidth="1*"/>
                     <thead>
                        <row>
                           <entry/>
                           <entry>Raw (first document available)</entry>
                           <entry>Resolved</entry>
                           <entry>Expanded</entry>
                        </row>
                     </thead>
                     <tbody>
                        <row>
                           <entry><code><link linkend="element-inclusion"
                                 >&lt;inclusion></link></code></entry>
                           <entry/>
                           <entry><code><link linkend="variable-inclusions-resolved"
                                    >$inclusions-resolved</link></code></entry>
                           <entry>—</entry>
                        </row>
                        <row>
                           <entry><code><link linkend="element-vocabulary"
                                 >&lt;vocabulary></link></code></entry>
                           <entry/>
                           <entry><code><link linkend="variable-vocabularies-resolved"
                                    >$vocabularies-resolved</link></code></entry>
                           <entry/>
                        </row>
                        <row>
                           <entry><code><link linkend="element-source"
                              >&lt;source></link></code></entry>
                           <entry/>
                           <entry><code><link linkend="variable-sources-resolved"
                                    >$sources-resolved</link></code></entry>
                           <entry><code><link linkend="variable-self-expanded"
                                 >$self-expanded</link>[tan:TAN-T]</code></entry>
                        </row>
                        <row>
                           <entry><code><link linkend="element-see-also"
                              >&lt;see-also></link></code></entry>
                           <entry><code><link linkend="variable-see-alsos-1st-da"
                                    >$see-alsos-1st-da</link></code></entry>
                           <entry><code><link linkend="variable-see-alsos-resolved"
                                    >$see-alsos-resolved</link></code></entry>
                           <entry>—</entry>
                        </row>
                     </tbody>
                  </tgroup>
               </table>
            </para>
            <para>The column labeled "raw" lists variables that hold the first documents available,
               without alteration. Variables in the next column hold the resolved form, following
               the same process described above for <code><link linkend="variable-self-resolved"
                     >$self-resolved</link></code>. The resolved forms of <code><link
                     linkend="element-inclusion">&lt;inclusion></link></code> and <code><link
                     linkend="element-vocabulary">&lt;vocabulary></link></code> are sufficient for
               validation, therefore they do not have expanded versions. Expanded sources are always
               found after the first document in <code><link linkend="variable-self-expanded"
                     >$self-expanded</link></code>.</para>
            <para>For relatively simple applications, a resolved file is sufficient. There will be
               times when you will want to fetch the vocabulary bound to a particular attribute or
               element. One of the more important functions to familiarize yourself with is
                     <code><link linkend="function-vocabulary">tan:vocabulary()</link></code>, which
               can be used to get the IRI + name pattern of a specific node, or to get all the
               possible vocabulary for a given type.</para>
         </section>
         <section>
            <title>Using TAN outside of TAN</title>
            <para>The function library behind TAN is quite powerful, and it can be used outside of
               the Text Alignment Network. Below is a list of some functions that have been
               extremely helpful both inside and outside of the TAN ecosystem. Some of the functions
               are not central to validation, so must be retrieved through
                  <code>/functions/TAN-extra-functions.xsl</code>.</para>
            <para>For a complete list of all functions, see <xref
                  xlink:href="#variables-keys-functions-and-templates"/>.</para>
            <para>
               <orderedlist>
                  <listitem>
                     <para><code><link linkend="function-batch-replace"
                           >tan:batch-replace()</link></code>: you can apply a sequence of regular
                        expressions on any string. You need to construct a series of
                           <code>&lt;replace pattern="" replacement="" [flags=""]></code> that
                        follow the rules of <code><link linkend="function-replace"
                              >tan:replace()</link></code> or <code>fn:replace()</code>.</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-chop-string"
                        >tan:chop-string()</link></code>: changes a string into a sequence of
                        characters, as defined in TAN (i.e., combining characters are always kept
                        with the base character). It is roughly equivalent to the XPath function
                        expression <code>for $i in fn:string-to-codepoints(.) return
                           fn:codepoints-to-string($i)</code>.</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-collate">tan:collate()</link></code>: like
                              <code><link linkend="function-diff">tan:diff()</link></code>, but
                        applied to any number of strings. The results are treated much like a
                        collation of manuscript readings, with the output xml fragment tethered to
                        sigla corresponding to the strings.</para>
                  </listitem>
                  <listitem>
                     <para>tan:copy-identation(): applies the white-space indentation of an element
                        to any other XML fragment. Useful for when you want to insert items in an
                        XML file and preserve/imitate its indentation.</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-diff">tan:diff()</link></code>: compare any
                        two strings for differences. Includes an option to mark the changes
                        letter-for-letter, or merely word-for-word (easier to read in some
                        contexts).</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-duplicate-items"
                           >tan:duplicate-items()</link></code>: like <code><link
                              linkend="function-duplicate-values"
                           >tan:duplicate-values()</link></code>, but applied to any item. If a
                        node, duplication is determined based on whether it is deeply equal to any
                        other node.</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-duplicate-values"
                              >tan:duplicate-values()</link></code>: finds distinct items in a
                        sequence whose values are repeated in the sequence. This function is a sort
                        of complement to <code>fn:distinct-values()</code>.</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-fill">tan:fill()</link></code>: repeats a
                        string a given number of times. Helpful for plain-text formatting.</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-get-chars-by-name"
                              >tan:get-chars-by-name()</link></code>: retrieves Unicode characters
                        based upon words in their name.</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-glob-to-regex"
                           >tan:glob-to-regex()</link></code>: changes a glob-like expression
                        (normally used for looking for filenames, e.g., *.*) into a regular
                        expression.</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-lang-code">tan:lang-code()</link></code>:
                        retrieves an ISO 639-3 code for a language of a given name.</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-lang-name">tan:lang-name()</link></code>:
                        finds the name of a language, given its ISO 639-3 code.</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-median">tan:median()</link></code>:
                        retrieves the median from a sequence of numbers</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-most-common-item"
                              >tan:most-common-item()</link></code>: from a sequence of items,
                        returns the one that occurs most frequently</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-no-outliers"
                           >tan:no-outliers()</link></code>: removes outliers from a sequence of
                        numbers</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-outliers">tan:outliers()</link></code>:
                        returns only outliers from a sequence of numbers</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-search-morpheus"
                           >tan:search-morpheus()</link></code>: retrieves lexico-morphological data
                        for Greek and Latin from the Morpheus service</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-search-wikipedia"
                              >tan:search-wikipedia()</link></code>: retrieves a set number of
                        records from Wikipedia</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-shallow-copy"
                           >tan:shallow-copy()</link></code>: returns a copy of a node to a set
                        depth. Useful for messages, to provide feedback on a particular element and
                        its attributes, without any descendants (which would make the message hard
                        to read).</para>
                  </listitem>
                  <listitem>
                     <para><code><link linkend="function-uri-relative-to"
                           >tan:uri-relative-to()</link></code>: converts an absolute URI to a
                        relative one, based on some context URI</para>
                  </listitem>
               </orderedlist>
            </para>
            <para>There are also a set of numeral functions that might be useful:<orderedlist>
                  <listitem>
                     <para>Letter numerals ↔ integers: <code><link linkend="function-aaa-to-int"
                              >tan:aaa-to-int()</link></code>, <code><link
                              linkend="function-int-to-aaa">tan:int-to-aaa()</link></code></para>
                  </listitem>
                  <listitem>
                     <para>Roman numerals → integers: <code><link linkend="function-rom-to-int"
                              >tan:rom-to-int()</link></code> (reverse not yet implemented)</para>
                  </listitem>
                  <listitem>
                     <para>Greek numerals ↔ integers: <code><link linkend="function-grc-to-int"
                              >tan:grc-to-int()</link></code>, <code><link
                              linkend="function-int-to-grc">tan:int-to-grc()</link></code></para>
                  </listitem>
                  <listitem>
                     <para>Syriac numerals → integers: <code><link linkend="function-syr-to-int"
                              >tan:syr-to-int()</link></code> (reverse not yet implemented)</para>
                  </listitem>
                  <listitem>
                     <para>Hexadecimal ↔ decimal: <code><link linkend="function-hex-to-dec"
                              >tan:hex-to-dec()</link></code>, <code><link
                              linkend="function-dec-to-hex">tan:dec-to-hex()</link></code></para>
                  </listitem>
                  <listitem>
                     <para>String range ↔ integers: <code><link
                              linkend="function-expand-numerical-sequence"
                              >tan:expand-numerical-sequence()</link></code>, <code><link
                              linkend="function-integers-to-sequence"
                              >tan:integers-to-sequence()</link></code></para>
                  </listitem>
               </orderedlist></para>
         </section>
      </chapter>
   </part>
   <part xml:id="appendixes">
      <title>Appendixes</title>
      <xi:include href="inclusions/elements-attributes-and-patterns.xml"/>
      <xi:include href="inclusions/vocabularies.xml"/>
      <xi:include href="inclusions/variables-keys-functions-and-templates.xml"/>
      <xi:include href="inclusions/errors.xml" xml:id="errors"/>
   </part>
</book>
